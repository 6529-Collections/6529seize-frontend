# Tests Directory Context

## Testing Strategy & File Organization

### Testing Structure Overview
```
__tests__/
├── components/              # Component tests (React Testing Library)
│   ├── auth/               # Authentication component tests
│   ├── waves/              # Wave-related component tests
│   ├── user/               # User profile component tests
│   └── utils/              # Utility component tests
├── hooks/                  # Custom hook tests
├── services/               # API service tests
├── utils/                  # Utility function tests
├── integration/            # Integration tests
└── scenarios/              # Complex user flow tests
```

### Testing Philosophy for Split Components

#### Test Composition Over Implementation
```typescript
// ✅ Good: Test component behavior, not internal structure
describe('UserProfile', () => {
  it('displays user information correctly', () => {
    render(<UserProfile user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
    expect(screen.getByRole('img', { name: /avatar/i })).toBeInTheDocument()
  })
  
  it('handles edit action', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />)
    
    const editButton = screen.getByRole('button', { name: /edit/i })
    await user.click(editButton)
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})

// ❌ Bad: Testing implementation details
describe('UserProfile', () => {
  it('renders UserHeader, UserDetails, and UserActions', () => {
    // This test breaks when refactoring internal structure
  })
})
```

#### Test Individual Sub-Components
```typescript
// Test focused components independently
describe('UserProfileHeader', () => {
  it('displays user name and avatar', () => {
    render(<UserProfileHeader user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByRole('img')).toHaveAttribute('src', mockUser.avatar)
  })
  
  it('shows online status indicator', () => {
    render(<UserProfileHeader user={{ ...mockUser, isOnline: true }} />)
    
    expect(screen.getByTestId('online-indicator')).toBeInTheDocument()
  })
})

describe('UserProfileActions', () => {
  it('calls edit handler when edit button clicked', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfileActions userId={mockUser.id} onEdit={mockOnEdit} />)
    
    await user.click(screen.getByRole('button', { name: /edit/i }))
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})
```

### Testing Custom Hooks in Isolation

#### Data Fetching Hooks
```typescript
// hooks/useWaveData.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { useWaveData } from '../../../hooks/useWaveData'
import { createTestQueryClient } from '../../utils/testContexts'

describe('useWaveData', () => {
  it('fetches wave data on mount', async () => {
    const { result } = renderHook(() => useWaveData('wave-123'), {
      wrapper: createTestQueryClient()
    })
    
    expect(result.current.loading).toBe(true)
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.data).toBeDefined()
    })
  })
  
  it('handles fetch errors gracefully', async () => {
    // Mock API error
    jest.spyOn(api, 'getWave').mockRejectedValueOnce(new Error('Network error'))
    
    const { result } = renderHook(() => useWaveData('invalid-id'), {
      wrapper: createTestQueryClient()
    })
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy()
      expect(result.current.data).toBeNull()
    })
  })
  
  it('refetches data when wave ID changes', async () => {
    const { result, rerender } = renderHook(
      ({ waveId }) => useWaveData(waveId),
      {
        initialProps: { waveId: 'wave-1' },
        wrapper: createTestQueryClient()
      }
    )
    
    await waitFor(() => expect(result.current.loading).toBe(false))
    
    const firstData = result.current.data
    
    // Change wave ID
    rerender({ waveId: 'wave-2' })
    
    await waitFor(() => {
      expect(result.current.data).not.toBe(firstData)
    })
  })
})
```

#### State Management Hooks
```typescript
// hooks/useFormState.test.ts
describe('useFormState', () => {
  it('initializes with default values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    expect(result.current.values).toEqual({
      name: '',
      email: ''
    })
    expect(result.current.errors).toEqual({})
    expect(result.current.isValid).toBe(false)
  })
  
  it('updates field values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    act(() => {
      result.current.setValue('name', 'John Doe')
    })
    
    expect(result.current.values.name).toBe('John Doe')
  })
  
  it('validates fields on change', () => {
    const validationRules = {
      email: (value: string) => value.includes('@') ? null : 'Invalid email'
    }
    
    const { result } = renderHook(() => useFormState(
      { email: '' },
      validationRules
    ))
    
    act(() => {
      result.current.setValue('email', 'invalid-email')
    })
    
    expect(result.current.errors.email).toBe('Invalid email')
    expect(result.current.isValid).toBe(false)
  })
})
```

### Testing Component Integration

#### Container/Presentation Pattern Testing
```typescript
// Test container logic separately from presentation
describe('UserProfileContainer', () => {
  it('fetches user data and passes to presentation component', async () => {
    const mockUser = createMockUser()
    jest.spyOn(api, 'getUser').mockResolvedValueOnce(mockUser)
    
    render(<UserProfileContainer userId="user-123" />)
    
    await waitFor(() => {
      expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    })
  })
  
  it('handles loading state', () => {
    jest.spyOn(api, 'getUser').mockImplementationOnce(
      () => new Promise(() => {}) // Never resolves
    )
    
    render(<UserProfileContainer userId="user-123" />)
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})

describe('UserProfilePresentation', () => {
  it('renders user data correctly', () => {
    const mockUser = createMockUser()
    
    render(
      <UserProfilePresentation 
        user={mockUser}
        loading={false}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
  })
  
  it('shows loading state', () => {
    render(
      <UserProfilePresentation 
        user={null}
        loading={true}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})
```

### Testing Error Boundaries

#### Error Boundary Component Testing
```typescript
// Test error boundary behavior
describe('WalletErrorBoundary', () => {
  const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }) => {
    if (shouldThrow) {
      throw new Error('Test error')
    }
    return <div>No error</div>
  }
  
  it('renders children when no error occurs', () => {
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={false} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText('No error')).toBeInTheDocument()
  })
  
  it('renders error UI when child component throws', () => {
    // Suppress console.error for this test
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation()
    
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={true} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument()
    
    consoleSpy.mockRestore()
  })
  
  it('allows recovery from error state', async () => {
    const { rerender } = render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={true} />
      </WalletErrorBoundary>
    )
    
    // Error state is shown
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    
    // Click retry button
    await user.click(screen.getByRole('button', { name: /try again/i }))
    
    // Rerender with no error
    rerender(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={false} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText('No error')).toBeInTheDocument()
  })
})
```

### Testing Complex User Flows

#### Integration Testing Patterns
```typescript
// integration/WaveCreationFlow.test.tsx
describe('Wave Creation Flow', () => {
  beforeEach(() => {
    // Setup authenticated user
    mockAuthenticatedUser()
  })
  
  it('completes full wave creation process', async () => {
    render(<WaveCreationPage />)
    
    // Step 1: Fill out wave details
    await user.type(
      screen.getByLabelText(/wave title/i),
      'My Test Wave'
    )
    
    await user.type(
      screen.getByLabelText(/description/i),
      'This is a test wave description'
    )
    
    // Step 2: Configure wave settings
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    await user.selectOptions(
      screen.getByLabelText(/wave type/i),
      'community'
    )
    
    // Step 3: Review and submit
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText('My Test Wave')).toBeInTheDocument()
    expect(screen.getByText('This is a test wave description')).toBeInTheDocument()
    
    await user.click(screen.getByRole('button', { name: /create wave/i }))
    
    // Verify success
    await waitFor(() => {
      expect(screen.getByText(/wave created successfully/i)).toBeInTheDocument()
    })
  })
  
  it('handles validation errors appropriately', async () => {
    render(<WaveCreationPage />)
    
    // Try to proceed without filling required fields
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText(/title is required/i)).toBeInTheDocument()
    expect(screen.getByText(/description is required/i)).toBeInTheDocument()
  })
})
```

### Testing Async Operations

#### API Interaction Testing
```typescript
// services/waveService.test.ts
describe('Wave Service', () => {
  beforeEach(() => {
    fetchMock.resetMocks()
  })
  
  it('fetches waves with correct parameters', async () => {
    const mockWaves = [createMockWave(), createMockWave()]
    fetchMock.mockResponseOnce(JSON.stringify({
      data: mockWaves,
      success: true
    }))
    
    const result = await waveService.getWaves({
      page: 1,
      limit: 10,
      category: 'art'
    })
    
    expect(fetchMock).toHaveBeenCalledWith(
      expect.stringContaining('/api/waves?page=1&limit=10&category=art'),
      expect.objectContaining({
        method: 'GET',
        headers: expect.objectContaining({
          'Content-Type': 'application/json'
        })
      })
    )
    
    expect(result.data).toEqual(mockWaves)
  })
  
  it('handles API errors gracefully', async () => {
    fetchMock.mockRejectOnce(new Error('Network error'))
    
    await expect(waveService.getWaves()).rejects.toThrow('Network error')
  })
  
  it('retries failed requests', async () => {
    fetchMock
      .mockRejectOnce(new Error('Network error'))
      .mockRejectOnce(new Error('Network error'))
      .mockResponseOnce(JSON.stringify({ data: [], success: true }))
    
    const result = await waveService.getWaves()
    
    expect(fetchMock).toHaveBeenCalledTimes(3)
    expect(result.success).toBe(true)
  })
})
```

### Testing Utility Functions

#### Pure Function Testing
```typescript
// utils/formatters.test.ts
describe('formatCurrency', () => {
  it('formats USD currency correctly', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56')
    expect(formatCurrency(0)).toBe('$0.00')
    expect(formatCurrency(999999.99)).toBe('$999,999.99')
  })
  
  it('handles different currencies', () => {
    expect(formatCurrency(100, 'EUR')).toBe('€100.00')
    expect(formatCurrency(100, 'GBP')).toBe('£100.00')
  })
  
  it('handles bigint Wei amounts', () => {
    const oneEth = BigInt('1000000000000000000') // 1 ETH in Wei
    expect(formatCurrency(oneEth)).toBe('$1.00')
  })
  
  it('respects decimal places', () => {
    expect(formatCurrency(1.23456, 'USD', 4)).toBe('$1.2346')
    expect(formatCurrency(1.23456, 'USD', 0)).toBe('$1')
  })
})

describe('truncateAddress', () => {
  const validAddress = '0x1234567890123456789012345678901234567890'
  
  it('truncates Ethereum addresses correctly', () => {
    expect(truncateAddress(validAddress)).toBe('0x1234...7890')
  })
  
  it('allows custom truncation lengths', () => {
    expect(truncateAddress(validAddress, 8, 6)).toBe('0x123456...567890')
  })
  
  it('throws error for invalid addresses', () => {
    expect(() => truncateAddress('invalid')).toThrow('Invalid Ethereum address')
  })
})
```

### Performance Testing

#### Component Performance Testing
```typescript
// performance/ComponentPerformance.test.tsx
describe('Large List Performance', () => {
  it('renders large lists efficiently', async () => {
    const startTime = performance.now()
    
    const largeDataSet = Array.from({ length: 1000 }, (_, i) => 
      createMockWave({ id: `wave-${i}` })
    )
    
    render(<WavesList waves={largeDataSet} />)
    
    const endTime = performance.now()
    const renderTime = endTime - startTime
    
    // Should render within reasonable time (adjust threshold as needed)
    expect(renderTime).toBeLessThan(1000) // 1 second
    
    // Verify virtual scrolling is working
    const visibleItems = screen.getAllByTestId(/wave-item/)
    expect(visibleItems.length).toBeLessThan(50) // Only visible items rendered
  })
})
```

### Test Utilities & Helpers

#### Mock Factory Functions
```typescript
// utils/mockFactories.ts
export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: faker.datatype.uuid(),
    address: faker.finance.ethereumAddress(),
    username: faker.internet.userName(),
    email: faker.internet.email(),
    avatar: faker.image.avatar(),
    createdAt: faker.date.past().toISOString(),
    isOnline: faker.datatype.boolean(),
    ...overrides
  }
}

export function createMockWave(overrides: Partial<Wave> = {}): Wave {
  return {
    id: faker.datatype.uuid(),
    title: faker.lorem.sentence(),
    description: faker.lorem.paragraph(),
    authorId: faker.datatype.uuid(),
    createdAt: faker.date.past().toISOString(),
    category: faker.helpers.arrayElement(['art', 'music', 'gaming']),
    isActive: true,
    participantCount: faker.datatype.number({ min: 0, max: 1000 }),
    ...overrides
  }
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    message: 'Success',
    ...overrides
  }
}
```

#### Test Context Providers
```typescript
// utils/testContexts.tsx
export function createTestQueryClient(): QueryClient {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false, // Disable retries in tests
        gcTime: Infinity, // Prevent garbage collection during tests
      },
      mutations: {
        retry: false,
      },
    },
  })
}

export function TestWrapper({ children }: { children: React.ReactNode }) {
  const queryClient = createTestQueryClient()
  
  return (
    <QueryClientProvider client={queryClient}>
      <WagmiProvider config={mockWagmiConfig}>
        <AuthProvider>
          {children}
        </AuthProvider>
      </WagmiProvider>
    </QueryClientProvider>
  )
}

export function renderWithProviders(
  ui: React.ReactElement,
  options?: RenderOptions
) {
  return render(ui, {
    wrapper: TestWrapper,
    ...options,
  })
}
```

### Testing Best Practices for Split Components

#### 1. Test Public Interfaces, Not Implementation
- Focus on component behavior and user interactions
- Avoid testing internal state or implementation details
- Test what users see and interact with

#### 2. Isolate Component Dependencies
- Mock external dependencies (APIs, services)
- Use test doubles for complex dependencies
- Keep tests focused on the component under test

#### 3. Test Error Scenarios
- Test error boundaries and error handling
- Verify graceful degradation
- Test recovery mechanisms

#### 4. Maintain Test Quality
- Keep tests focused and readable
- Use descriptive test names
- Group related tests logically

---

**Test behavior, not implementation. Focus on user interactions and component contracts rather than internal structure.**