# Tests Directory Context

## Core Philosophy: Simple, Focused, Maintainable Tests

**"Write tests that clearly document component behavior. Favor simple, straightforward tests over complex testing abstractions."**

## Simple Testing Strategy (2025 Best Practices)

### React 19 + Testing Library Patterns
```typescript
// ✅ Good: Clear, focused test with user interactions
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { UserCard } from '@/components/user/UserCard'

describe('UserCard', () => {
  const mockUser = { id: '1', name: 'John', avatar: '/avatar.jpg' }
  const mockOnEdit = jest.fn()

  beforeEach(() => {
    mockOnEdit.mockClear()
  })

  it('displays user information', () => {
    render(<UserCard user={mockUser} onEdit={mockOnEdit} />)
    
    expect(screen.getByText('John')).toBeInTheDocument()
    expect(screen.getByAltText('John')).toHaveAttribute('src', '/avatar.jpg')
  })

  it('calls onEdit when edit button is clicked', async () => {
    const user = userEvent.setup()
    render(<UserCard user={mockUser} onEdit={mockOnEdit} />)
    
    await user.click(screen.getByRole('button', { name: 'Edit' }))
    
    expect(mockOnEdit).toHaveBeenCalledWith('1')
    expect(mockOnEdit).toHaveBeenCalledTimes(1)
  })
})

// ❌ Avoid: Over-engineered test utilities and abstractions
function createComplexTestWrapper(config) {
  // 50 lines of setup for every test...
}
```

### Web3 Testing Patterns (Keep It Simple)
```typescript
// ✅ Good: Simple wallet connection test
describe('WalletButton', () => {
  it('shows connect button when disconnected', () => {
    render(<WalletButton connected={false} address={null} />)
    
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument()
  })

  it('shows address when connected', () => {
    const address = '0x1234567890abcdef1234567890abcdef12345678'
    render(<WalletButton connected={true} address={address} />)
    
    expect(screen.getByText('0x1234...5678')).toBeInTheDocument()
  })
})

// ❌ Avoid: Over-mocking web3 internals unless specifically testing them
```

## Testing Strategy & File Organization

### Testing Structure Overview
```
__tests__/
├── components/              # Component tests (React Testing Library)
│   ├── auth/               # Authentication component tests
│   ├── waves/              # Wave-related component tests
│   ├── user/               # User profile component tests
│   └── utils/              # Utility component tests
├── hooks/                  # Custom hook tests
├── services/               # API service tests
├── utils/                  # Utility function tests
├── integration/            # Integration tests
└── scenarios/              # Complex user flow tests
```

### Testing Philosophy for Split Components

#### Test Composition Over Implementation
```typescript
// ✅ Good: Test component behavior, not internal structure
describe('UserProfile', () => {
  it('displays user information correctly', () => {
    render(<UserProfile user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
    expect(screen.getByRole('img', { name: /avatar/i })).toBeInTheDocument()
  })
  
  it('handles edit action', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />)
    
    const editButton = screen.getByRole('button', { name: /edit/i })
    await user.click(editButton)
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})

// ❌ Bad: Testing implementation details
describe('UserProfile', () => {
  it('renders UserHeader, UserDetails, and UserActions', () => {
    // This test breaks when refactoring internal structure
  })
})
```

#### Test Individual Sub-Components
```typescript
// Test focused components independently
describe('UserProfileHeader', () => {
  it('displays user name and avatar', () => {
    render(<UserProfileHeader user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByRole('img')).toHaveAttribute('src', mockUser.avatar)
  })
  
  it('shows online status indicator', () => {
    render(<UserProfileHeader user={{ ...mockUser, isOnline: true }} />)
    
    expect(screen.getByTestId('online-indicator')).toBeInTheDocument()
  })
})

describe('UserProfileActions', () => {
  it('calls edit handler when edit button clicked', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfileActions userId={mockUser.id} onEdit={mockOnEdit} />)
    
    await user.click(screen.getByRole('button', { name: /edit/i }))
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})
```

### Testing Custom Hooks in Isolation

#### Data Fetching Hooks
```typescript
// hooks/useWaveData.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { useWaveData } from '../../../hooks/useWaveData'
import { createTestQueryClient } from '../../utils/testContexts'

describe('useWaveData', () => {
  it('fetches wave data on mount', async () => {
    const { result } = renderHook(() => useWaveData('wave-123'), {
      wrapper: createTestQueryClient()
    })
    
    expect(result.current.loading).toBe(true)
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.data).toBeDefined()
    })
  })
  
  it('handles fetch errors gracefully', async () => {
    // Mock API error
    jest.spyOn(api, 'getWave').mockRejectedValueOnce(new Error('Network error'))
    
    const { result } = renderHook(() => useWaveData('invalid-id'), {
      wrapper: createTestQueryClient()
    })
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy()
      expect(result.current.data).toBeNull()
    })
  })
  
  it('refetches data when wave ID changes', async () => {
    const { result, rerender } = renderHook(
      ({ waveId }) => useWaveData(waveId),
      {
        initialProps: { waveId: 'wave-1' },
        wrapper: createTestQueryClient()
      }
    )
    
    await waitFor(() => expect(result.current.loading).toBe(false))
    
    const firstData = result.current.data
    
    // Change wave ID
    rerender({ waveId: 'wave-2' })
    
    await waitFor(() => {
      expect(result.current.data).not.toBe(firstData)
    })
  })
})
```

#### State Management Hooks
```typescript
// hooks/useFormState.test.ts
describe('useFormState', () => {
  it('initializes with default values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    expect(result.current.values).toEqual({
      name: '',
      email: ''
    })
    expect(result.current.errors).toEqual({})
    expect(result.current.isValid).toBe(false)
  })
  
  it('updates field values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    act(() => {
      result.current.setValue('name', 'John Doe')
    })
    
    expect(result.current.values.name).toBe('John Doe')
  })
  
  it('validates fields on change', () => {
    const validationRules = {
      email: (value: string) => value.includes('@') ? null : 'Invalid email'
    }
    
    const { result } = renderHook(() => useFormState(
      { email: '' },
      validationRules
    ))
    
    act(() => {
      result.current.setValue('email', 'invalid-email')
    })
    
    expect(result.current.errors.email).toBe('Invalid email')
    expect(result.current.isValid).toBe(false)
  })
})
```

### Testing Component Integration

#### Container/Presentation Pattern Testing
```typescript
// Test container logic separately from presentation
describe('UserProfileContainer', () => {
  it('fetches user data and passes to presentation component', async () => {
    const mockUser = createMockUser()
    jest.spyOn(api, 'getUser').mockResolvedValueOnce(mockUser)
    
    render(<UserProfileContainer userId="user-123" />)
    
    await waitFor(() => {
      expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    })
  })
  
  it('handles loading state', () => {
    jest.spyOn(api, 'getUser').mockImplementationOnce(
      () => new Promise(() => {}) // Never resolves
    )
    
    render(<UserProfileContainer userId="user-123" />)
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})

describe('UserProfilePresentation', () => {
  it('renders user data correctly', () => {
    const mockUser = createMockUser()
    
    render(
      <UserProfilePresentation 
        user={mockUser}
        loading={false}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
  })
  
  it('shows loading state', () => {
    render(
      <UserProfilePresentation 
        user={null}
        loading={true}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})
```

## Fail-Fast Error Testing Strategies

### **CRITICAL: Ultra-Aggressive Error Boundary Testing Patterns**

**Testing Philosophy**: Verify that critical errors terminate immediately, security violations never have fallbacks, and error propagation works correctly.

#### 1. **Enhanced Error Boundary Testing for Fail-Fast Patterns**

```typescript
// __tests__/fail-fast/error-boundary.test.tsx
describe('Fail-Fast Error Boundary Patterns', () => {
  // Test components that throw different error types
  const SecurityViolationComponent = () => {
    throw new SecurityViolationError(
      'Unauthorized access attempt detected',
      'SECURITY_UNAUTHORIZED_ACCESS',
      { component: 'test_component' }
    );
  };

  const AuthenticationErrorComponent = () => {
    throw new AuthenticationError(
      'JWT token expired during component render',
      'AUTH_JWT_EXPIRED_RENDER',
      { component: 'test_component' }
    );
  };

  const ValidationErrorComponent = () => {
    throw new ValidationError(
      'Invalid props provided to component',
      'VALIDATION_INVALID_PROPS',
      { component: 'test_component' }
    );
  };

  const NetworkErrorComponent = () => {
    throw new NetworkError(
      'Network request failed during render',
      'NETWORK_RENDER_FAILURE',
      { component: 'test_component' }
    );
  };

  beforeEach(() => {
    // Mock security logging functions
    jest.clearAllMocks();
  });

  describe('Security Violation Error Handling', () => {
    it('should never allow recovery for security violations', () => {
      // Suppress expected error output
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      render(
        <CriticalFeatureErrorBoundary featureName="Security Test">
          <SecurityViolationComponent />
        </CriticalFeatureErrorBoundary>
      );

      // Should show security violation specific messaging
      expect(screen.getByText(/security violation detected/i)).toBeInTheDocument();
      expect(screen.getByText(/feature disabled for protection/i)).toBeInTheDocument();
      
      // Should NOT show retry button for security violations
      expect(screen.queryByText(/reset.*feature/i)).not.toBeInTheDocument();
      
      // Should show app reload option only
      expect(screen.getByText(/reload application/i)).toBeInTheDocument();
      
      // Verify security logging was called
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'security_test_boundary',
        expect.objectContaining({
          type: 'SECURITY_VIOLATION',
          code: 'SECURITY_UNAUTHORIZED_ACCESS'
        })
      );

      expect(mockLogSecurityEvent).toHaveBeenCalledWith(
        SecurityEventType.COMPONENT_SECURITY_BOUNDARY,
        expect.objectContaining({
          featureName: 'Security Test'
        })
      );

      consoleSpy.mockRestore();
    });

    it('should immediately terminate without fallback UI for security violations', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      expect(() => {
        render(<SecurityViolationComponent />);
      }).toThrow(SecurityViolationError);
      
      expect(() => {
        render(<SecurityViolationComponent />);
      }).toThrow('Unauthorized access attempt detected');

      consoleSpy.mockRestore();
    });
  });

  describe('Authentication Error Handling', () => {
    it('should fail-fast on authentication errors with recovery option', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      render(
        <CriticalFeatureErrorBoundary featureName="Auth Test">
          <AuthenticationErrorComponent />
        </CriticalFeatureErrorBoundary>
      );

      // Should show authentication-specific error state
      expect(screen.getByText(/auth test failed/i)).toBeInTheDocument();
      expect(screen.getByText(/critical error occurred/i)).toBeInTheDocument();
      
      // Should show recovery options for auth errors (not security violations)
      expect(screen.getByText(/reset.*feature/i)).toBeInTheDocument();
      expect(screen.getByText(/reload application/i)).toBeInTheDocument();

      // Verify structured error logging
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'auth_test_boundary',
        expect.objectContaining({
          type: 'AUTHENTICATION_ERROR',
          code: 'AUTH_JWT_EXPIRED_RENDER',
          severity: 'HIGH'
        })
      );

      consoleSpy.mockRestore();
    });
  });

  describe('Error Propagation Testing', () => {
    it('should propagate errors through component hierarchy', () => {
      const ParentComponent = () => (
        <div>
          <ChildComponent />
        </div>
      );

      const ChildComponent = () => {
        throw new TransactionError(
          'Transaction failed in child component',
          'TRANSACTION_CHILD_FAILURE'
        );
      };

      expect(() => {
        render(
          <TestErrorBoundary>
            <ParentComponent />
          </TestErrorBoundary>
        );
      }).toThrow(TransactionError);
    });

    it('should maintain error context through propagation', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      const DeepNestedComponent = () => {
        throw new WalletConnectionError(
          'Deep nested wallet error',
          'WALLET_DEEP_NESTED_ERROR',
          { depth: 3, componentChain: ['Parent', 'Middle', 'Deep'] }
        );
      };

      render(
        <CriticalFeatureErrorBoundary featureName="Deep Nested Test">
          <div>
            <div>
              <DeepNestedComponent />
            </div>
          </div>
        </CriticalFeatureErrorBoundary>
      );

      // Verify context preservation
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'deep_nested_test_boundary',
        expect.objectContaining({
          context: expect.objectContaining({
            depth: 3,
            componentChain: ['Parent', 'Middle', 'Deep']
          })
        })
      );

      consoleSpy.mockRestore();
    });
  });

  describe('Error Boundary Recovery Testing', () => {
    it('should allow recovery for non-security errors', async () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      let shouldThrow = true;

      const RecoverableComponent = () => {
        if (shouldThrow) {
          throw new ValidationError(
            'Recoverable validation error',
            'VALIDATION_RECOVERABLE_ERROR'
          );
        }
        return <div>Component recovered successfully</div>;
      };

      const { rerender } = render(
        <CriticalFeatureErrorBoundary featureName="Recovery Test">
          <RecoverableComponent />
        </CriticalFeatureErrorBoundary>
      );

      // Should show error state initially
      expect(screen.getByText(/recovery test failed/i)).toBeInTheDocument();
      
      // Should show reset button for recoverable errors
      const resetButton = screen.getByText(/reset.*feature/i);
      expect(resetButton).toBeInTheDocument();

      // Simulate error resolution and reset
      shouldThrow = false;
      await user.click(resetButton);

      // Should show recovered component
      await waitFor(() => {
        expect(screen.getByText('Component recovered successfully')).toBeInTheDocument();
      });

      consoleSpy.mockRestore();
    });

    it('should NOT allow recovery for critical security errors', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      render(
        <SecurityAwareRecoveryButton 
          error={new SecurityViolationError(
            'Critical security error',
            'SECURITY_CRITICAL_ERROR'
          )}
          featureName="Security Test"
          onRecover={() => {}}
        />
      );

      // Should show security violation message
      expect(screen.getByText(/security violation detected/i)).toBeInTheDocument();
      expect(screen.getByText(/recovery not available/i)).toBeInTheDocument();
      
      // Should NOT show recovery button
      expect(screen.queryByText(/try again/i)).not.toBeInTheDocument();
      
      // Should show security guidance
      expect(screen.getByText(/refresh the page/i)).toBeInTheDocument();
      expect(screen.getByText(/ensure your wallet is secure/i)).toBeInTheDocument();

      consoleSpy.mockRestore();
    });
  });

  describe('Error Logging Integration', () => {
    it('should log errors with complete security context', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      const testError = new AuthenticationError(
        'Test authentication error with context',
        'AUTH_TEST_ERROR_WITH_CONTEXT',
        {
          userId: 'user_123',
          sessionId: 'session_456',
          attemptCount: 3
        }
      );

      const ErrorThrowingComponent = () => {
        throw testError;
      };

      render(
        <CriticalFeatureErrorBoundary featureName="Logging Test">
          <ErrorThrowingComponent />
        </CriticalFeatureErrorBoundary>
      );

      // Verify comprehensive logging
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'logging_test_boundary',
        expect.objectContaining({
          type: 'AUTHENTICATION_ERROR',
          code: 'AUTH_TEST_ERROR_WITH_CONTEXT',
          severity: 'HIGH',
          context: expect.objectContaining({
            userId: 'user_123',
            sessionId: 'session_456',
            attemptCount: 3
          }),
          timestamp: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T/),
          sessionId: expect.stringMatching(/^[a-z0-9]+_[a-f0-9]+$/)
        })
      );

      consoleSpy.mockRestore();
    });
  });
});
```

#### 2. **Enhanced Component Error Testing**

```typescript
// __tests__/fail-fast/component-error-handling.test.tsx
describe('Component-Level Fail-Fast Error Handling', () => {
  describe('Input Validation Error Testing', () => {
    it('should throw SecurityViolationError for invalid wallet address props', () => {
      const invalidAddresses = [
        '0xinvalid',
        '0x123',
        'not_an_address',
        null,
        undefined,
        123,
        {}
      ];

      invalidAddresses.forEach((invalidAddress) => {
        expect(() => {
          render(
            <TestErrorBoundary>
              <CriticalWalletComponent walletAddress={invalidAddress as string} />
            </TestErrorBoundary>
          );
        }).toThrow(SecurityViolationError);
      });
    });

    it('should validate props aggressively on component mount', () => {
      const mockValidateAddress = jest.fn().mockImplementation(() => {
        throw new SecurityViolationError(
          'Address validation failed in component',
          'COMPONENT_ADDRESS_VALIDATION_FAILED'
        );
      });

      // Mock the validation function
      jest.mock('../src/utils/fail-fast-validation', () => ({
        validateEthereumAddressOrThrow: mockValidateAddress
      }));

      expect(() => {
        render(<CriticalWalletComponent walletAddress="0xinvalid" />);
      }).toThrow(SecurityViolationError);

      expect(mockValidateAddress).toHaveBeenCalledWith(
        '0xinvalid',
        expect.stringContaining('component')
      );
    });
  });

  describe('Hook Error Propagation Testing', () => {
    it('should propagate authentication errors from hooks', () => {
      const authError = new AuthenticationError(
        'Hook authentication failed',
        'HOOK_AUTH_FAILED'
      );

      jest.spyOn(walletHooks, 'useSecureWalletConnection').mockImplementation(() => {
        throw authError;
      });

      expect(() => {
        const { result } = renderHook(() =>
          useSecureWalletConnection('0x1234567890123456789012345678901234567890')
        );
      }).toThrow(AuthenticationError);

      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'wallet_connection_hook',
        expect.objectContaining({
          type: 'AUTHENTICATION_ERROR',
          code: 'HOOK_AUTH_FAILED'
        })
      );
    });

    it('should never provide fallback values for critical hook errors', () => {
      const securityError = new SecurityViolationError(
        'Security violation in hook',
        'HOOK_SECURITY_VIOLATION'
      );

      jest.spyOn(walletHooks, 'useSecureWalletConnection').mockImplementation(() => {
        throw securityError;
      });

      // Hook should throw, not return error state
      expect(() => {
        const { result } = renderHook(() =>
          useSecureWalletConnection('0x1234567890123456789012345678901234567890')
        );
        
        // This should not be reached
        expect(result.current).toBeUndefined();
      }).toThrow(SecurityViolationError);
    });
  });

  describe('Form Submission Error Testing', () => {
    it('should fail-fast on form validation errors', async () => {
      const mockOnSubmit = jest.fn();
      
      render(
        <TestErrorBoundary>
          <CriticalTransactionForm onSubmit={mockOnSubmit} />
        </TestErrorBoundary>
      );

      // Fill form with invalid data
      const recipientInput = screen.getByLabelText(/recipient address/i);
      const amountInput = screen.getByLabelText(/amount/i);

      await user.type(recipientInput, 'invalid_address');
      await user.type(amountInput, '-100'); // Negative amount

      expect(() => {
        fireEvent.click(screen.getByText(/submit transaction/i));
      }).toThrow(SecurityViolationError);

      // onSubmit should never be called with invalid data
      expect(mockOnSubmit).not.toHaveBeenCalled();
    });

    it('should sanitize error context in form submissions', async () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      const sensitiveData = {
        privateKey: '0xabcdef123456789',
        jwt: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...',
        userEmail: 'user@example.com'
      };

      const FormWithSensitiveData = () => {
        const handleSubmit = () => {
          throw new ValidationError(
            'Form validation failed',
            'FORM_VALIDATION_ERROR',
            sensitiveData
          );
        };

        return (
          <form onSubmit={handleSubmit}>
            <button type="submit">Submit</button>
          </form>
        );
      };

      expect(() => {
        render(
          <TestErrorBoundary>
            <FormWithSensitiveData />
          </TestErrorBoundary>
        );
        fireEvent.click(screen.getByText('Submit'));
      }).toThrow(ValidationError);

      // Verify sensitive data was sanitized in logs
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          context: expect.not.objectContaining({
            privateKey: sensitiveData.privateKey,
            jwt: sensitiveData.jwt,
            userEmail: sensitiveData.userEmail
          })
        })
      );

      consoleSpy.mockRestore();
    });
  });
});
```

#### 3. **Security-Focused Error Testing**

```typescript
// __tests__/fail-fast/security-error.test.tsx
describe('Security-Focused Error Testing', () => {
  describe('Sensitive Data Sanitization', () => {
    it('should never log sensitive data in error messages', () => {
      const sensitiveError = new AuthenticationError(
        'Authentication failed for user user@example.com with JWT eyJ0eXAiOiJKV1Q... and wallet 0x1234567890123456789012345678901234567890',
        'AUTH_WITH_SENSITIVE_DATA'
      );

      logCriticalError('test_context', sensitiveError);

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringMatching(/\[SEIZE_CRITICAL\]/),
        expect.objectContaining({
          message: expect.stringMatching(/\*\*\*JWT\*\*\*.*0x\*\*\*REDACTED\*\*\*/)
        })
      );

      // Verify original sensitive data is not in logs
      const loggedData = mockConsoleError.mock.calls[0][1];
      expect(JSON.stringify(loggedData)).not.toContain('user@example.com');
      expect(JSON.stringify(loggedData)).not.toContain('eyJ0eXAiOiJKV1Q');
      expect(JSON.stringify(loggedData)).not.toContain('1234567890123456789012345678901234567890');
    });

    it('should validate that security context contains no sensitive data', () => {
      const contextWithSensitiveData = {
        walletAddress: '0x1234567890123456789012345678901234567890',
        privateKey: '0xabcdef123456789',
        jwt: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...'
      };

      expect(() => {
        logSecurityEvent(SecurityEventType.USER_ACTION, contextWithSensitiveData);
      }).toThrow('SECURITY VIOLATION: SecurityEventContext contains wallet address');
    });
  });

  describe('Error Code Searchability', () => {
    it('should generate structured error codes for monitoring', () => {
      const testError = new TransactionError(
        'Transaction failed with structured code',
        'TRANSACTION_STRUCTURED_ERROR_CODE',
        { transactionId: 'tx_123', blockNumber: 12345 }
      );

      logCriticalError('structured_error_test', testError);

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringMatching(/\[SEIZE_CRITICAL\]\[HIGH\]\[TRANSACTION_STRUCTURED_ERROR_CODE\]/),
        expect.objectContaining({
          code: 'TRANSACTION_STRUCTURED_ERROR_CODE',
          type: 'TRANSACTION_ERROR',
          severity: 'HIGH',
          actionRequired: 'TRANSACTION_REVIEW_AND_RETRY'
        })
      );
    });

    it('should include session correlation IDs', () => {
      const testError = new NetworkError(
        'Network error for session correlation',
        'NETWORK_SESSION_CORRELATION_TEST'
      );

      logCriticalError('session_test', testError);

      const loggedEntry = mockConsoleError.mock.calls[0][1];
      expect(loggedEntry.sessionId).toMatch(/^[a-z0-9]+_[a-f0-9]+$/);
      expect(loggedEntry.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T/);
    });
  });

  describe('Error Recovery Testing', () => {
    it('should never allow recovery for CRITICAL severity errors', () => {
      const criticalError = new SecurityViolationError(
        'Critical security error',
        'SECURITY_CRITICAL_NO_RECOVERY'
      );

      expect(criticalError.shouldTerminateApplication()).toBe(true);
      expect(criticalError.allowsRecovery()).toBe(false);
      expect(criticalError.severity).toBe('CRITICAL');
    });

    it('should allow recovery for MEDIUM severity errors', () => {
      const recoverableError = new ValidationError(
        'Recoverable validation error',
        'VALIDATION_RECOVERABLE_ERROR'
      );

      expect(recoverableError.shouldTerminateApplication()).toBe(false);
      expect(recoverableError.allowsRecovery()).toBe(true);
      expect(recoverableError.severity).toBe('MEDIUM');
    });

    it('should require investigation for HIGH severity errors', () => {
      const authError = new AuthenticationError(
        'High severity auth error',
        'AUTH_HIGH_SEVERITY_ERROR'
      );

      logCriticalError('investigation_test', authError);

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          severity: 'HIGH',
          actionRequired: 'USER_REAUTHENTICATION_REQUIRED',
          shouldAlert: false // Not CRITICAL, but still high priority
        })
      );
    });
  });

  describe('Performance Impact Testing', () => {
    it('should handle error logging efficiently', () => {
      const startTime = performance.now();
      
      // Log multiple errors rapidly
      for (let i = 0; i < 100; i++) {
        const error = new ValidationError(
          `Performance test error ${i}`,
          'PERFORMANCE_TEST_ERROR',
          { iteration: i }
        );
        logCriticalError(`performance_test_${i}`, error);
      }
      
      const endTime = performance.now();
      const totalTime = endTime - startTime;
      
      // Should complete within reasonable time (adjust threshold as needed)
      expect(totalTime).toBeLessThan(1000); // 1 second for 100 error logs
    });

    it('should not impact component rendering performance', () => {
      const RenderPerformanceComponent = () => {
        // Simulate component with potential errors
        try {
          validateEthereumAddressOrThrow('0x1234567890123456789012345678901234567890');
          return <div>Valid component render</div>;
        } catch (error) {
          logCriticalError('render_performance_test', error as SeizeError);
          throw error;
        }
      };

      const startTime = performance.now();
      
      // Render multiple components
      for (let i = 0; i < 50; i++) {
        const { unmount } = render(
          <TestErrorBoundary>
            <RenderPerformanceComponent />
          </TestErrorBoundary>
        );
        unmount();
      }
      
      const endTime = performance.now();
      const renderTime = endTime - startTime;
      
      // Should render efficiently even with error handling
      expect(renderTime).toBeLessThan(500); // 500ms for 50 renders
    });
  });
});
```

#### 4. **Integration Testing with Fail-Fast Patterns**

```typescript
// __tests__/fail-fast/integration-error.test.tsx
describe('Integration Error Testing with Fail-Fast', () => {
  describe('End-to-End Error Scenarios', () => {
    it('should handle wallet connection failure with complete error chain', async () => {
      // Mock wallet connection to fail
      const walletError = new WalletConnectionError(
        'Wallet connection failed during integration test',
        'INTEGRATION_WALLET_CONNECTION_FAILED',
        { provider: 'MetaMask', networkId: 1 }
      );

      jest.spyOn(walletHooks, 'useSecureWalletConnection').mockImplementation(() => {
        throw walletError;
      });

      expect(() => {
        render(
          <CriticalFeatureErrorBoundary featureName="Integration Test">
            <WalletConnectedApp />
          </CriticalFeatureErrorBoundary>
        );
      }).toThrow(WalletConnectionError);

      // Verify complete error logging chain
      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'wallet_connection_hook',
        expect.objectContaining({
          code: 'INTEGRATION_WALLET_CONNECTION_FAILED',
          context: expect.objectContaining({
            provider: 'MetaMask',
            networkId: 1
          })
        })
      );
    });

    it('should test transaction flow with security validation', async () => {
      const mockTransactionParams = {
        to: '0x1234567890123456789012345678901234567890',
        value: '1.0',
        gasLimit: '21000',
        gasPrice: '20000000000'
      };

      // Test successful validation
      expect(() => {
        const validatedParams = validateTransactionParamsOrThrow(
          mockTransactionParams,
          'integration_test'
        );
        expect(validatedParams.to).toBe(mockTransactionParams.to.toLowerCase());
      }).not.toThrow();

      // Test security threshold violation
      const highValueParams = {
        ...mockTransactionParams,
        value: '10000' // Exceeds MAX_TRANSACTION_AMOUNT
      };

      expect(() => {
        validateTransactionParamsOrThrow(highValueParams, 'security_test');
      }).toThrow(SecurityViolationError);
    });
  });

  describe('API Integration Error Testing', () => {
    it('should handle API authentication failures', async () => {
      // Mock API to return 401
      global.fetch = jest.fn().mockResolvedValue({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        text: jest.fn().mockResolvedValue('Unauthorized access')
      });

      const result = await secureApiRequest('/test-endpoint', {}, 'integration_test');

      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error).toBeInstanceOf(AuthenticationError);
        expect(result.error.code).toBe('API_UNAUTHORIZED');
      }

      expect(mockLogCriticalError).toHaveBeenCalledWith(
        'api_request_error',
        expect.objectContaining({
          type: 'AUTHENTICATION_ERROR',
          code: 'API_UNAUTHORIZED'
        }),
        expect.objectContaining({
          context: 'integration_test'
        })
      );
    });

    it('should handle network failures gracefully', async () => {
      // Mock network failure
      global.fetch = jest.fn().mockRejectedValue(new Error('Network unavailable'));

      const result = await secureApiRequest('/test-endpoint', {}, 'network_test');

      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error).toBeInstanceOf(NetworkError);
        expect(result.error.code).toBe('API_UNEXPECTED_ERROR');
      }
    });
  });
});
```

---

**CRITICAL TESTING GUIDELINES FOR FAIL-FAST PATTERNS**:

1. **Always test error propagation paths** - Verify errors bubble up correctly
2. **Never test recovery for security violations** - Ensure these always terminate
3. **Test sensitive data sanitization** - Verify no secrets in error logs
4. **Test error boundary isolation** - Each boundary should catch appropriately
5. **Test performance impact** - Error handling shouldn't slow down the app
6. **Test structured error codes** - Verify searchability and correlation
7. **Mock security violations** - Test immediate termination behavior
8. **Test integration error chains** - Full end-to-end error scenarios

### Testing Error Boundaries (Legacy Pattern - Being Enhanced)

#### Error Boundary Component Testing (Legacy)
```typescript
// ❌ DEPRECATED: Basic error boundary testing without fail-fast verification
describe('WalletErrorBoundary', () => {
  const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }) => {
    if (shouldThrow) {
      throw new Error('Test error') // Generic error, not structured
    }
    return <div>No error</div>
  }
  
  it('renders children when no error occurs', () => {
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={false} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText('No error')).toBeInTheDocument()
  })
  
  // ❌ DEPRECATED: Doesn't test fail-fast patterns or structured errors
  it('renders error UI when child component throws', () => {
    // Suppress console.error for this test
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation()
    
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={true} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument()
    
    consoleSpy.mockRestore()
  })
})

### Testing Complex User Flows

#### Integration Testing Patterns
```typescript
// integration/WaveCreationFlow.test.tsx
describe('Wave Creation Flow', () => {
  beforeEach(() => {
    // Setup authenticated user
    mockAuthenticatedUser()
  })
  
  it('completes full wave creation process', async () => {
    render(<WaveCreationPage />)
    
    // Step 1: Fill out wave details
    await user.type(
      screen.getByLabelText(/wave title/i),
      'My Test Wave'
    )
    
    await user.type(
      screen.getByLabelText(/description/i),
      'This is a test wave description'
    )
    
    // Step 2: Configure wave settings
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    await user.selectOptions(
      screen.getByLabelText(/wave type/i),
      'community'
    )
    
    // Step 3: Review and submit
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText('My Test Wave')).toBeInTheDocument()
    expect(screen.getByText('This is a test wave description')).toBeInTheDocument()
    
    await user.click(screen.getByRole('button', { name: /create wave/i }))
    
    // Verify success
    await waitFor(() => {
      expect(screen.getByText(/wave created successfully/i)).toBeInTheDocument()
    })
  })
  
  it('handles validation errors appropriately', async () => {
    render(<WaveCreationPage />)
    
    // Try to proceed without filling required fields
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText(/title is required/i)).toBeInTheDocument()
    expect(screen.getByText(/description is required/i)).toBeInTheDocument()
  })
})
```

### Testing Async Operations

#### API Interaction Testing
```typescript
// services/waveService.test.ts
describe('Wave Service', () => {
  beforeEach(() => {
    fetchMock.resetMocks()
  })
  
  it('fetches waves with correct parameters', async () => {
    const mockWaves = [createMockWave(), createMockWave()]
    fetchMock.mockResponseOnce(JSON.stringify({
      data: mockWaves,
      success: true
    }))
    
    const result = await waveService.getWaves({
      page: 1,
      limit: 10,
      category: 'art'
    })
    
    expect(fetchMock).toHaveBeenCalledWith(
      expect.stringContaining('/api/waves?page=1&limit=10&category=art'),
      expect.objectContaining({
        method: 'GET',
        headers: expect.objectContaining({
          'Content-Type': 'application/json'
        })
      })
    )
    
    expect(result.data).toEqual(mockWaves)
  })
  
  it('handles API errors gracefully', async () => {
    fetchMock.mockRejectOnce(new Error('Network error'))
    
    await expect(waveService.getWaves()).rejects.toThrow('Network error')
  })
  
  it('retries failed requests', async () => {
    fetchMock
      .mockRejectOnce(new Error('Network error'))
      .mockRejectOnce(new Error('Network error'))
      .mockResponseOnce(JSON.stringify({ data: [], success: true }))
    
    const result = await waveService.getWaves()
    
    expect(fetchMock).toHaveBeenCalledTimes(3)
    expect(result.success).toBe(true)
  })
})
```

### Testing Utility Functions

#### Pure Function Testing
```typescript
// utils/formatters.test.ts
describe('formatCurrency', () => {
  it('formats USD currency correctly', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56')
    expect(formatCurrency(0)).toBe('$0.00')
    expect(formatCurrency(999999.99)).toBe('$999,999.99')
  })
  
  it('handles different currencies', () => {
    expect(formatCurrency(100, 'EUR')).toBe('€100.00')
    expect(formatCurrency(100, 'GBP')).toBe('£100.00')
  })
  
  it('handles bigint Wei amounts', () => {
    const oneEth = BigInt('1000000000000000000') // 1 ETH in Wei
    expect(formatCurrency(oneEth)).toBe('$1.00')
  })
  
  it('respects decimal places', () => {
    expect(formatCurrency(1.23456, 'USD', 4)).toBe('$1.2346')
    expect(formatCurrency(1.23456, 'USD', 0)).toBe('$1')
  })
})

describe('truncateAddress', () => {
  const validAddress = '0x1234567890123456789012345678901234567890'
  
  it('truncates Ethereum addresses correctly', () => {
    expect(truncateAddress(validAddress)).toBe('0x1234...7890')
  })
  
  it('allows custom truncation lengths', () => {
    expect(truncateAddress(validAddress, 8, 6)).toBe('0x123456...567890')
  })
  
  it('throws error for invalid addresses', () => {
    expect(() => truncateAddress('invalid')).toThrow('Invalid Ethereum address')
  })
})
```

### Performance Testing

#### Component Performance Testing
```typescript
// performance/ComponentPerformance.test.tsx
describe('Large List Performance', () => {
  it('renders large lists efficiently', async () => {
    const startTime = performance.now()
    
    const largeDataSet = Array.from({ length: 1000 }, (_, i) => 
      createMockWave({ id: `wave-${i}` })
    )
    
    render(<WavesList waves={largeDataSet} />)
    
    const endTime = performance.now()
    const renderTime = endTime - startTime
    
    // Should render within reasonable time (adjust threshold as needed)
    expect(renderTime).toBeLessThan(1000) // 1 second
    
    // Verify virtual scrolling is working
    const visibleItems = screen.getAllByTestId(/wave-item/)
    expect(visibleItems.length).toBeLessThan(50) // Only visible items rendered
  })
})
```

### Test Utilities & Helpers

#### Mock Factory Functions
```typescript
// utils/mockFactories.ts
export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: faker.datatype.uuid(),
    address: faker.finance.ethereumAddress(),
    username: faker.internet.userName(),
    email: faker.internet.email(),
    avatar: faker.image.avatar(),
    createdAt: faker.date.past().toISOString(),
    isOnline: faker.datatype.boolean(),
    ...overrides
  }
}

export function createMockWave(overrides: Partial<Wave> = {}): Wave {
  return {
    id: faker.datatype.uuid(),
    title: faker.lorem.sentence(),
    description: faker.lorem.paragraph(),
    authorId: faker.datatype.uuid(),
    createdAt: faker.date.past().toISOString(),
    category: faker.helpers.arrayElement(['art', 'music', 'gaming']),
    isActive: true,
    participantCount: faker.datatype.number({ min: 0, max: 1000 }),
    ...overrides
  }
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    message: 'Success',
    ...overrides
  }
}
```

#### Test Context Providers
```typescript
// utils/testContexts.tsx
export function createTestQueryClient(): QueryClient {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false, // Disable retries in tests
        gcTime: Infinity, // Prevent garbage collection during tests
      },
      mutations: {
        retry: false,
      },
    },
  })
}

export function TestWrapper({ children }: { children: React.ReactNode }) {
  const queryClient = createTestQueryClient()
  
  return (
    <QueryClientProvider client={queryClient}>
      <WagmiProvider config={mockWagmiConfig}>
        <AuthProvider>
          {children}
        </AuthProvider>
      </WagmiProvider>
    </QueryClientProvider>
  )
}

export function renderWithProviders(
  ui: React.ReactElement,
  options?: RenderOptions
) {
  return render(ui, {
    wrapper: TestWrapper,
    ...options,
  })
}
```

### Testing Best Practices for Split Components

#### 1. Test Public Interfaces, Not Implementation
- Focus on component behavior and user interactions
- Avoid testing internal state or implementation details
- Test what users see and interact with

#### 2. Isolate Component Dependencies
- Mock external dependencies (APIs, services)
- Use test doubles for complex dependencies
- Keep tests focused on the component under test

#### 3. Test Error Scenarios
- Test error boundaries and error handling
- Verify graceful degradation
- Test recovery mechanisms

#### 4. Maintain Test Quality
- Keep tests focused and readable
- Use descriptive test names
- Group related tests logically

## Testing TailwindCSS Components & Styling

### **TailwindCSS-Specific Testing Patterns**

#### 1. **Testing Responsive Classes**
```typescript
// Testing responsive TailwindCSS classes
describe('ResponsiveComponent', () => {
  it('applies correct responsive classes', () => {
    render(<ResponsiveGrid testId="responsive-grid" />)
    const grid = screen.getByTestId('responsive-grid')
    
    // Test base classes
    expect(grid).toHaveClass('tw-grid', 'tw-grid-cols-1')
    
    // Test responsive classes (these are in the DOM even if not active)
    expect(grid.className).toMatch(/sm:tw-grid-cols-2/)
    expect(grid.className).toMatch(/lg:tw-grid-cols-3/)
    expect(grid.className).toMatch(/tw-3xl:tw-grid-cols-4/)
  })
})
```

#### 2. **Testing TailwindCSS Variant Classes**
```typescript
describe('ButtonComponent Variants', () => {
  it('applies primary variant classes correctly', () => {
    render(<InteractiveButton variant="primary">Click me</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-bg-primary-500')
    expect(button).toHaveClass('tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-primary-600/)
  })
  
  it('applies secondary variant classes correctly', () => {
    render(<InteractiveButton variant="secondary">Click me</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-bg-iron-600')
    expect(button).toHaveClass('tw-text-iron-50')
  })
  
  it('applies state-based classes correctly', () => {
    render(<InteractiveButton loading disabled>Loading...</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-cursor-wait', 'tw-opacity-75')
    expect(button).toHaveClass('tw-cursor-not-allowed', 'tw-opacity-50')
  })
})
```

#### 3. **Testing Custom Design System Classes**
```typescript
describe('Custom TailwindCSS Classes', () => {
  it('uses custom iron color scale', () => {
    render(<Card variant="elevated" />)
    const card = screen.getByTestId('card')
    
    expect(card).toHaveClass('tw-bg-iron-900')
    expect(card).toHaveClass('tw-border-iron-700')
  })
  
  it('uses custom animations', () => {
    render(<LoadingSpinner />)
    const spinner = screen.getByTestId('loading-spinner')
    
    expect(spinner).toHaveClass('tw-animate-loading-bar')
  })
  
  it('uses custom shadows', () => {
    render(<DropButton active />)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-shadow-drop-btn-active')
  })
})
```

### **Headless UI + TailwindCSS Testing**

#### 1. **Testing Headless UI with TailwindCSS State Classes**
```typescript
describe('Headless UI Modal with TailwindCSS', () => {
  it('applies correct TailwindCSS classes to dialog components', () => {
    render(
      <Modal open={true} onClose={jest.fn()} title="Test Modal">
        <p>Modal content</p>
      </Modal>
    )
    
    // Test Dialog classes
    const dialog = screen.getByRole('dialog')
    expect(dialog).toHaveClass('tw-relative', 'tw-z-50')
    
    // Test DialogPanel classes
    const panel = screen.getByRole('dialog').querySelector('[role="dialog"] > div > div')
    expect(panel).toHaveClass('tw-bg-iron-900', 'tw-border', 'tw-border-iron-700')
  })
  
  it('applies data-attribute based styling', () => {
    render(
      <Disclosure>
        <DisclosureButton className="tw-flex tw-items-center tw-gap-2">
          Toggle
        </DisclosureButton>
        <DisclosurePanel>Content</DisclosurePanel>
      </Disclosure>
    )
    
    const button = screen.getByRole('button')
    
    // Check for data attributes that TailwindCSS can target
    fireEvent.click(button)
    
    // After opening, data attributes should be present for styling
    expect(button).toHaveAttribute('data-open', '')
  })
})
```

#### 2. **Testing Menu Component State Styling**
```typescript
describe('Headless UI Menu with TailwindCSS', () => {
  it('applies focus styles to menu items', async () => {
    const items = [
      { label: 'Option 1', onClick: jest.fn() },
      { label: 'Option 2', onClick: jest.fn() }
    ]
    
    render(<DropdownMenu trigger={<span>Menu</span>} items={items} />)
    
    // Open menu
    fireEvent.click(screen.getByText('Menu'))
    
    // Find menu items
    const option1 = screen.getByText('Option 1')
    
    // Test focus state classes (these might be applied via render props)
    fireEvent.mouseEnter(option1)
    
    // Check for focus state styling classes
    expect(option1.closest('button')).toHaveClass('tw-bg-primary-500')
  })
})
```

### **Mobile and Responsive Testing**

#### 1. **Testing Safe Area Classes**
```typescript
describe('Mobile Layout with Safe Area', () => {
  it('applies safe area inset classes', () => {
    render(<MobileLayout>Content</MobileLayout>)
    const layout = screen.getByTestId('mobile-layout')
    
    // Test safe area classes
    expect(layout.className).toMatch(/tw-pt-\[env\(safe-area-inset-top,0px\)\]/)
    expect(layout.className).toMatch(/tw-pb-\[env\(safe-area-inset-bottom,0px\)\]/)
  })
  
  it('applies touch-optimized button classes', () => {
    render(<MobileButton>Touch me</MobileButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-min-h-[44px]', 'tw-min-w-[44px]')
    expect(button).toHaveClass('tw-touch-manipulation')
  })
})
```

#### 2. **Testing Container Query Classes**
```typescript
describe('Container Query Components', () => {
  it('applies container query classes', () => {
    render(<AdaptiveCard>Adaptive content</AdaptiveCard>)
    const container = screen.getByTestId('adaptive-card')
    
    expect(container).toHaveClass('tw-@container')
    expect(container.querySelector('div')).toHaveClass('tw-flex-col')
    
    // Test container query responsive class
    expect(container.querySelector('div')?.className).toMatch(/@md:tw-flex-row/)
  })
})
```

### **Web3-Specific Component Testing**

#### 1. **Testing Wallet Connection States**
```typescript
describe('Wallet Connection Button', () => {
  it('applies correct styling for disconnected state', () => {
    render(
      <WalletConnectButton
        connected={false}
        onConnect={jest.fn()}
        onDisconnect={jest.fn()}
      />
    )
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('tw-bg-primary-500', 'tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-primary-600/)
  })
  
  it('applies correct styling for connected state', () => {
    render(
      <WalletConnectButton
        connected={true}
        address="0x1234567890abcdef1234567890abcdef12345678"
        onConnect={jest.fn()}
        onDisconnect={jest.fn()}
      />
    )
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('tw-bg-success', 'tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-green/)
    
    // Test that the pulse animation is applied to the indicator
    const indicator = button.querySelector('div')
    expect(indicator).toHaveClass('tw-animate-pulse')
  })
})
```

#### 2. **Testing Transaction Status Styling**
```typescript
describe('Transaction Status Component', () => {
  const testCases = [
    {
      status: 'pending' as const,
      expectedClasses: ['tw-text-yellow-400', 'tw-bg-yellow-400/10'],
      expectedIcon: 'tw-animate-spin'
    },
    {
      status: 'confirmed' as const,
      expectedClasses: ['tw-text-green-400', 'tw-bg-green-400/10'],
      expectedIcon: ''
    },
    {
      status: 'failed' as const,
      expectedClasses: ['tw-text-red-400', 'tw-bg-red-400/10'],
      expectedIcon: 'tw-animate-shake'
    }
  ]
  
  testCases.forEach(({ status, expectedClasses, expectedIcon }) => {
    it(`applies correct styling for ${status} status`, () => {
      render(<TransactionStatus status={status} hash="0x123" />)
      
      const container = screen.getByTestId('transaction-status')
      expectedClasses.forEach(className => {
        expect(container).toHaveClass(className)
      })
      
      if (expectedIcon) {
        const indicator = container.querySelector('.tw-rounded-full')
        expect(indicator).toHaveClass(expectedIcon)
      }
    })
  })
})
```

### **Performance and Animation Testing**

#### 1. **Testing Animation Classes**
```typescript
describe('Animated Components', () => {
  it('applies GPU-accelerated transform classes', () => {
    render(<AnimatedModal isOpen={true} />)
    const modal = screen.getByTestId('animated-modal')
    
    expect(modal).toHaveClass('tw-transform')
    expect(modal).toHaveClass('tw-transition-all')
    expect(modal).toHaveClass('tw-opacity-100', 'tw-scale-100')
  })
  
  it('applies correct animation states', () => {
    const { rerender } = render(<AnimatedModal isOpen={false} />)
    const modal = screen.getByTestId('animated-modal')
    
    expect(modal).toHaveClass('tw-opacity-0', 'tw-scale-95')
    
    rerender(<AnimatedModal isOpen={true} />)
    expect(modal).toHaveClass('tw-opacity-100', 'tw-scale-100')
  })
})
```

#### 2. **Testing Memoized Component Classes**
```typescript
describe('Optimized Components', () => {
  it('applies correct variant classes from memoized computation', () => {
    const { rerender } = render(<OptimizedCard variant="default" data={mockData} />)
    const card = screen.getByTestId('optimized-card')
    
    expect(card).toHaveClass('tw-bg-iron-900', 'tw-p-6', 'tw-shadow-lg')
    
    // Test variant change
    rerender(<OptimizedCard variant="featured" data={mockData} />)
    expect(card).toHaveClass('tw-border-primary-500', 'tw-bg-gradient-to-br')
  })
})
```

### **Testing TailwindCSS Utility Functions**

#### 1. **Testing Class Composition Utilities**
```typescript
import { cn } from '../src/utils/cn'
import { getButtonClasses } from '../src/utils/variants/button'

describe('TailwindCSS Utility Functions', () => {
  it('composes classes correctly with cn utility', () => {
    const result = cn(
      'tw-px-4 tw-py-2',
      true && 'tw-bg-primary-500',
      false && 'tw-bg-secondary-500',
      'tw-text-white'
    )
    
    expect(result).toBe('tw-px-4 tw-py-2 tw-bg-primary-500 tw-text-white')
  })
  
  it('generates button classes correctly', () => {
    const primaryMedium = getButtonClasses('primary', 'md')
    
    expect(primaryMedium).toMatch(/tw-bg-primary-500/)
    expect(primaryMedium).toMatch(/tw-px-4/)
    expect(primaryMedium).toMatch(/tw-py-2/)
    expect(primaryMedium).toMatch(/tw-text-sm/)
  })
})
```

#### 2. **Testing Theme Utility Functions**
```typescript
import { getIronClass, getPrimaryClass } from '../src/utils/theme'

describe('Theme Utility Functions', () => {
  it('generates iron scale classes correctly', () => {
    expect(getIronClass(900, 'bg')).toBe('tw-bg-iron-900')
    expect(getIronClass(300, 'text')).toBe('tw-text-iron-300')
    expect(getIronClass(600, 'border')).toBe('tw-border-iron-600')
  })
  
  it('generates primary scale classes correctly', () => {
    expect(getPrimaryClass(500, 'bg')).toBe('tw-bg-primary-500')
    expect(getPrimaryClass(600, 'text')).toBe('tw-text-primary-600')
  })
})
```

### **Visual Regression Testing with Playwright**

#### 1. **Testing TailwindCSS Styles Across Viewports**
```typescript
// e2e/tailwind-responsive.spec.ts
import { test, expect } from '@playwright/test'

test.describe('TailwindCSS Responsive Behavior', () => {
  test('grid layout responds correctly to viewport changes', async ({ page }) => {
    await page.goto('/component-showcase/grid')
    
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 812 })
    const grid = page.locator('[data-testid="responsive-grid"]')
    
    // Verify mobile layout
    await expect(grid).toHaveClass(/tw-grid-cols-1/)
    
    // Test tablet viewport
    await page.setViewportSize({ width: 768, height: 1024 })
    await expect(grid).toHaveClass(/sm:tw-grid-cols-2/)
    
    // Test desktop viewport
    await page.setViewportSize({ width: 1280, height: 720 })
    await expect(grid).toHaveClass(/lg:tw-grid-cols-3/)
    
    // Test custom 3xl breakpoint
    await page.setViewportSize({ width: 2048, height: 1080 })
    await expect(grid).toHaveClass(/tw-3xl:tw-grid-cols-4/)
  })
  
  test('dark mode styling applies correctly', async ({ page }) => {
    await page.goto('/component-showcase')
    
    // Test light mode
    await expect(page.locator('html')).not.toHaveClass('dark')
    const card = page.locator('[data-testid="theme-card"]')
    await expect(card).toHaveClass(/tw-bg-white/)
    
    // Toggle dark mode
    await page.click('[data-testid="theme-toggle"]')
    await expect(page.locator('html')).toHaveClass('dark')
    await expect(card).toHaveClass(/dark:tw-bg-iron-900/)
  })
})
```

#### 2. **Testing Animation and Transition Classes**
```typescript
test.describe('TailwindCSS Animations', () => {
  test('modal animations work correctly', async ({ page }) => {
    await page.goto('/component-showcase/modal')
    
    // Test modal opening animation
    await page.click('[data-testid="open-modal"]')
    const modal = page.locator('[data-testid="modal"]')
    
    // Check for animation classes
    await expect(modal).toHaveClass(/tw-transition-all/)
    await expect(modal).toHaveClass(/tw-duration-300/)
    
    // Wait for animation to complete and check final state
    await page.waitForTimeout(350)
    await expect(modal).toHaveClass(/tw-opacity-100/)
    await expect(modal).toHaveClass(/tw-scale-100/)
  })
})
```

### **Testing Custom TailwindCSS Configuration**

#### 1. **Testing Custom Colors and Classes**
```typescript
describe('Custom TailwindCSS Configuration', () => {
  it('supports custom iron color scale', () => {
    render(<div className="tw-bg-iron-950 tw-text-iron-50" data-testid="custom-colors" />)
    const element = screen.getByTestId('custom-colors')
    
    expect(element).toHaveClass('tw-bg-iron-950')
    expect(element).toHaveClass('tw-text-iron-50')
  })
  
  it('supports custom animations', () => {
    render(<div className="tw-animate-loading-bar" data-testid="custom-animation" />)
    const element = screen.getByTestId('custom-animation')
    
    expect(element).toHaveClass('tw-animate-loading-bar')
  })
  
  it('supports custom shadows', () => {
    render(<button className="tw-shadow-drop-btn-active" data-testid="custom-shadow" />)
    const element = screen.getByTestId('custom-shadow')
    
    expect(element).toHaveClass('tw-shadow-drop-btn-active')
  })
})
```

---

**Test behavior, not implementation. Focus on user interactions and component contracts rather than internal structure. ALWAYS test that TailwindCSS classes are applied correctly with tw- prefix.**