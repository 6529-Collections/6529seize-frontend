# Tests Directory Context

## Testing Strategy & File Organization

### Testing Structure Overview
```
__tests__/
├── components/              # Component tests (React Testing Library)
│   ├── auth/               # Authentication component tests
│   ├── waves/              # Wave-related component tests
│   ├── user/               # User profile component tests
│   └── utils/              # Utility component tests
├── hooks/                  # Custom hook tests
├── services/               # API service tests
├── utils/                  # Utility function tests
├── integration/            # Integration tests
└── scenarios/              # Complex user flow tests
```

### Testing Philosophy for Split Components

#### Test Composition Over Implementation
```typescript
// ✅ Good: Test component behavior, not internal structure
describe('UserProfile', () => {
  it('displays user information correctly', () => {
    render(<UserProfile user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
    expect(screen.getByRole('img', { name: /avatar/i })).toBeInTheDocument()
  })
  
  it('handles edit action', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />)
    
    const editButton = screen.getByRole('button', { name: /edit/i })
    await user.click(editButton)
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})

// ❌ Bad: Testing implementation details
describe('UserProfile', () => {
  it('renders UserHeader, UserDetails, and UserActions', () => {
    // This test breaks when refactoring internal structure
  })
})
```

#### Test Individual Sub-Components
```typescript
// Test focused components independently
describe('UserProfileHeader', () => {
  it('displays user name and avatar', () => {
    render(<UserProfileHeader user={mockUser} />)
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByRole('img')).toHaveAttribute('src', mockUser.avatar)
  })
  
  it('shows online status indicator', () => {
    render(<UserProfileHeader user={{ ...mockUser, isOnline: true }} />)
    
    expect(screen.getByTestId('online-indicator')).toBeInTheDocument()
  })
})

describe('UserProfileActions', () => {
  it('calls edit handler when edit button clicked', async () => {
    const mockOnEdit = jest.fn()
    render(<UserProfileActions userId={mockUser.id} onEdit={mockOnEdit} />)
    
    await user.click(screen.getByRole('button', { name: /edit/i }))
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser.id)
  })
})
```

### Testing Custom Hooks in Isolation

#### Data Fetching Hooks
```typescript
// hooks/useWaveData.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { useWaveData } from '../../../hooks/useWaveData'
import { createTestQueryClient } from '../../utils/testContexts'

describe('useWaveData', () => {
  it('fetches wave data on mount', async () => {
    const { result } = renderHook(() => useWaveData('wave-123'), {
      wrapper: createTestQueryClient()
    })
    
    expect(result.current.loading).toBe(true)
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.data).toBeDefined()
    })
  })
  
  it('handles fetch errors gracefully', async () => {
    // Mock API error
    jest.spyOn(api, 'getWave').mockRejectedValueOnce(new Error('Network error'))
    
    const { result } = renderHook(() => useWaveData('invalid-id'), {
      wrapper: createTestQueryClient()
    })
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy()
      expect(result.current.data).toBeNull()
    })
  })
  
  it('refetches data when wave ID changes', async () => {
    const { result, rerender } = renderHook(
      ({ waveId }) => useWaveData(waveId),
      {
        initialProps: { waveId: 'wave-1' },
        wrapper: createTestQueryClient()
      }
    )
    
    await waitFor(() => expect(result.current.loading).toBe(false))
    
    const firstData = result.current.data
    
    // Change wave ID
    rerender({ waveId: 'wave-2' })
    
    await waitFor(() => {
      expect(result.current.data).not.toBe(firstData)
    })
  })
})
```

#### State Management Hooks
```typescript
// hooks/useFormState.test.ts
describe('useFormState', () => {
  it('initializes with default values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    expect(result.current.values).toEqual({
      name: '',
      email: ''
    })
    expect(result.current.errors).toEqual({})
    expect(result.current.isValid).toBe(false)
  })
  
  it('updates field values', () => {
    const { result } = renderHook(() => useFormState({
      name: '',
      email: ''
    }))
    
    act(() => {
      result.current.setValue('name', 'John Doe')
    })
    
    expect(result.current.values.name).toBe('John Doe')
  })
  
  it('validates fields on change', () => {
    const validationRules = {
      email: (value: string) => value.includes('@') ? null : 'Invalid email'
    }
    
    const { result } = renderHook(() => useFormState(
      { email: '' },
      validationRules
    ))
    
    act(() => {
      result.current.setValue('email', 'invalid-email')
    })
    
    expect(result.current.errors.email).toBe('Invalid email')
    expect(result.current.isValid).toBe(false)
  })
})
```

### Testing Component Integration

#### Container/Presentation Pattern Testing
```typescript
// Test container logic separately from presentation
describe('UserProfileContainer', () => {
  it('fetches user data and passes to presentation component', async () => {
    const mockUser = createMockUser()
    jest.spyOn(api, 'getUser').mockResolvedValueOnce(mockUser)
    
    render(<UserProfileContainer userId="user-123" />)
    
    await waitFor(() => {
      expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    })
  })
  
  it('handles loading state', () => {
    jest.spyOn(api, 'getUser').mockImplementationOnce(
      () => new Promise(() => {}) // Never resolves
    )
    
    render(<UserProfileContainer userId="user-123" />)
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})

describe('UserProfilePresentation', () => {
  it('renders user data correctly', () => {
    const mockUser = createMockUser()
    
    render(
      <UserProfilePresentation 
        user={mockUser}
        loading={false}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
    expect(screen.getByText(mockUser.email)).toBeInTheDocument()
  })
  
  it('shows loading state', () => {
    render(
      <UserProfilePresentation 
        user={null}
        loading={true}
        error={null}
        onEdit={jest.fn()}
      />
    )
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })
})
```

### Testing Error Boundaries

#### Error Boundary Component Testing
```typescript
// Test error boundary behavior
describe('WalletErrorBoundary', () => {
  const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }) => {
    if (shouldThrow) {
      throw new Error('Test error')
    }
    return <div>No error</div>
  }
  
  it('renders children when no error occurs', () => {
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={false} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText('No error')).toBeInTheDocument()
  })
  
  it('renders error UI when child component throws', () => {
    // Suppress console.error for this test
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation()
    
    render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={true} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument()
    
    consoleSpy.mockRestore()
  })
  
  it('allows recovery from error state', async () => {
    const { rerender } = render(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={true} />
      </WalletErrorBoundary>
    )
    
    // Error state is shown
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    
    // Click retry button
    await user.click(screen.getByRole('button', { name: /try again/i }))
    
    // Rerender with no error
    rerender(
      <WalletErrorBoundary>
        <ThrowingComponent shouldThrow={false} />
      </WalletErrorBoundary>
    )
    
    expect(screen.getByText('No error')).toBeInTheDocument()
  })
})
```

### Testing Complex User Flows

#### Integration Testing Patterns
```typescript
// integration/WaveCreationFlow.test.tsx
describe('Wave Creation Flow', () => {
  beforeEach(() => {
    // Setup authenticated user
    mockAuthenticatedUser()
  })
  
  it('completes full wave creation process', async () => {
    render(<WaveCreationPage />)
    
    // Step 1: Fill out wave details
    await user.type(
      screen.getByLabelText(/wave title/i),
      'My Test Wave'
    )
    
    await user.type(
      screen.getByLabelText(/description/i),
      'This is a test wave description'
    )
    
    // Step 2: Configure wave settings
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    await user.selectOptions(
      screen.getByLabelText(/wave type/i),
      'community'
    )
    
    // Step 3: Review and submit
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText('My Test Wave')).toBeInTheDocument()
    expect(screen.getByText('This is a test wave description')).toBeInTheDocument()
    
    await user.click(screen.getByRole('button', { name: /create wave/i }))
    
    // Verify success
    await waitFor(() => {
      expect(screen.getByText(/wave created successfully/i)).toBeInTheDocument()
    })
  })
  
  it('handles validation errors appropriately', async () => {
    render(<WaveCreationPage />)
    
    // Try to proceed without filling required fields
    await user.click(screen.getByRole('button', { name: /next/i }))
    
    expect(screen.getByText(/title is required/i)).toBeInTheDocument()
    expect(screen.getByText(/description is required/i)).toBeInTheDocument()
  })
})
```

### Testing Async Operations

#### API Interaction Testing
```typescript
// services/waveService.test.ts
describe('Wave Service', () => {
  beforeEach(() => {
    fetchMock.resetMocks()
  })
  
  it('fetches waves with correct parameters', async () => {
    const mockWaves = [createMockWave(), createMockWave()]
    fetchMock.mockResponseOnce(JSON.stringify({
      data: mockWaves,
      success: true
    }))
    
    const result = await waveService.getWaves({
      page: 1,
      limit: 10,
      category: 'art'
    })
    
    expect(fetchMock).toHaveBeenCalledWith(
      expect.stringContaining('/api/waves?page=1&limit=10&category=art'),
      expect.objectContaining({
        method: 'GET',
        headers: expect.objectContaining({
          'Content-Type': 'application/json'
        })
      })
    )
    
    expect(result.data).toEqual(mockWaves)
  })
  
  it('handles API errors gracefully', async () => {
    fetchMock.mockRejectOnce(new Error('Network error'))
    
    await expect(waveService.getWaves()).rejects.toThrow('Network error')
  })
  
  it('retries failed requests', async () => {
    fetchMock
      .mockRejectOnce(new Error('Network error'))
      .mockRejectOnce(new Error('Network error'))
      .mockResponseOnce(JSON.stringify({ data: [], success: true }))
    
    const result = await waveService.getWaves()
    
    expect(fetchMock).toHaveBeenCalledTimes(3)
    expect(result.success).toBe(true)
  })
})
```

### Testing Utility Functions

#### Pure Function Testing
```typescript
// utils/formatters.test.ts
describe('formatCurrency', () => {
  it('formats USD currency correctly', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56')
    expect(formatCurrency(0)).toBe('$0.00')
    expect(formatCurrency(999999.99)).toBe('$999,999.99')
  })
  
  it('handles different currencies', () => {
    expect(formatCurrency(100, 'EUR')).toBe('€100.00')
    expect(formatCurrency(100, 'GBP')).toBe('£100.00')
  })
  
  it('handles bigint Wei amounts', () => {
    const oneEth = BigInt('1000000000000000000') // 1 ETH in Wei
    expect(formatCurrency(oneEth)).toBe('$1.00')
  })
  
  it('respects decimal places', () => {
    expect(formatCurrency(1.23456, 'USD', 4)).toBe('$1.2346')
    expect(formatCurrency(1.23456, 'USD', 0)).toBe('$1')
  })
})

describe('truncateAddress', () => {
  const validAddress = '0x1234567890123456789012345678901234567890'
  
  it('truncates Ethereum addresses correctly', () => {
    expect(truncateAddress(validAddress)).toBe('0x1234...7890')
  })
  
  it('allows custom truncation lengths', () => {
    expect(truncateAddress(validAddress, 8, 6)).toBe('0x123456...567890')
  })
  
  it('throws error for invalid addresses', () => {
    expect(() => truncateAddress('invalid')).toThrow('Invalid Ethereum address')
  })
})
```

### Performance Testing

#### Component Performance Testing
```typescript
// performance/ComponentPerformance.test.tsx
describe('Large List Performance', () => {
  it('renders large lists efficiently', async () => {
    const startTime = performance.now()
    
    const largeDataSet = Array.from({ length: 1000 }, (_, i) => 
      createMockWave({ id: `wave-${i}` })
    )
    
    render(<WavesList waves={largeDataSet} />)
    
    const endTime = performance.now()
    const renderTime = endTime - startTime
    
    // Should render within reasonable time (adjust threshold as needed)
    expect(renderTime).toBeLessThan(1000) // 1 second
    
    // Verify virtual scrolling is working
    const visibleItems = screen.getAllByTestId(/wave-item/)
    expect(visibleItems.length).toBeLessThan(50) // Only visible items rendered
  })
})
```

### Test Utilities & Helpers

#### Mock Factory Functions
```typescript
// utils/mockFactories.ts
export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: faker.datatype.uuid(),
    address: faker.finance.ethereumAddress(),
    username: faker.internet.userName(),
    email: faker.internet.email(),
    avatar: faker.image.avatar(),
    createdAt: faker.date.past().toISOString(),
    isOnline: faker.datatype.boolean(),
    ...overrides
  }
}

export function createMockWave(overrides: Partial<Wave> = {}): Wave {
  return {
    id: faker.datatype.uuid(),
    title: faker.lorem.sentence(),
    description: faker.lorem.paragraph(),
    authorId: faker.datatype.uuid(),
    createdAt: faker.date.past().toISOString(),
    category: faker.helpers.arrayElement(['art', 'music', 'gaming']),
    isActive: true,
    participantCount: faker.datatype.number({ min: 0, max: 1000 }),
    ...overrides
  }
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    message: 'Success',
    ...overrides
  }
}
```

#### Test Context Providers
```typescript
// utils/testContexts.tsx
export function createTestQueryClient(): QueryClient {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false, // Disable retries in tests
        gcTime: Infinity, // Prevent garbage collection during tests
      },
      mutations: {
        retry: false,
      },
    },
  })
}

export function TestWrapper({ children }: { children: React.ReactNode }) {
  const queryClient = createTestQueryClient()
  
  return (
    <QueryClientProvider client={queryClient}>
      <WagmiProvider config={mockWagmiConfig}>
        <AuthProvider>
          {children}
        </AuthProvider>
      </WagmiProvider>
    </QueryClientProvider>
  )
}

export function renderWithProviders(
  ui: React.ReactElement,
  options?: RenderOptions
) {
  return render(ui, {
    wrapper: TestWrapper,
    ...options,
  })
}
```

### Testing Best Practices for Split Components

#### 1. Test Public Interfaces, Not Implementation
- Focus on component behavior and user interactions
- Avoid testing internal state or implementation details
- Test what users see and interact with

#### 2. Isolate Component Dependencies
- Mock external dependencies (APIs, services)
- Use test doubles for complex dependencies
- Keep tests focused on the component under test

#### 3. Test Error Scenarios
- Test error boundaries and error handling
- Verify graceful degradation
- Test recovery mechanisms

#### 4. Maintain Test Quality
- Keep tests focused and readable
- Use descriptive test names
- Group related tests logically

## Testing TailwindCSS Components & Styling

### **TailwindCSS-Specific Testing Patterns**

#### 1. **Testing Responsive Classes**
```typescript
// Testing responsive TailwindCSS classes
describe('ResponsiveComponent', () => {
  it('applies correct responsive classes', () => {
    render(<ResponsiveGrid testId="responsive-grid" />)
    const grid = screen.getByTestId('responsive-grid')
    
    // Test base classes
    expect(grid).toHaveClass('tw-grid', 'tw-grid-cols-1')
    
    // Test responsive classes (these are in the DOM even if not active)
    expect(grid.className).toMatch(/sm:tw-grid-cols-2/)
    expect(grid.className).toMatch(/lg:tw-grid-cols-3/)
    expect(grid.className).toMatch(/tw-3xl:tw-grid-cols-4/)
  })
})
```

#### 2. **Testing TailwindCSS Variant Classes**
```typescript
describe('ButtonComponent Variants', () => {
  it('applies primary variant classes correctly', () => {
    render(<InteractiveButton variant="primary">Click me</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-bg-primary-500')
    expect(button).toHaveClass('tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-primary-600/)
  })
  
  it('applies secondary variant classes correctly', () => {
    render(<InteractiveButton variant="secondary">Click me</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-bg-iron-600')
    expect(button).toHaveClass('tw-text-iron-50')
  })
  
  it('applies state-based classes correctly', () => {
    render(<InteractiveButton loading disabled>Loading...</InteractiveButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-cursor-wait', 'tw-opacity-75')
    expect(button).toHaveClass('tw-cursor-not-allowed', 'tw-opacity-50')
  })
})
```

#### 3. **Testing Custom Design System Classes**
```typescript
describe('Custom TailwindCSS Classes', () => {
  it('uses custom iron color scale', () => {
    render(<Card variant="elevated" />)
    const card = screen.getByTestId('card')
    
    expect(card).toHaveClass('tw-bg-iron-900')
    expect(card).toHaveClass('tw-border-iron-700')
  })
  
  it('uses custom animations', () => {
    render(<LoadingSpinner />)
    const spinner = screen.getByTestId('loading-spinner')
    
    expect(spinner).toHaveClass('tw-animate-loading-bar')
  })
  
  it('uses custom shadows', () => {
    render(<DropButton active />)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-shadow-drop-btn-active')
  })
})
```

### **Headless UI + TailwindCSS Testing**

#### 1. **Testing Headless UI with TailwindCSS State Classes**
```typescript
describe('Headless UI Modal with TailwindCSS', () => {
  it('applies correct TailwindCSS classes to dialog components', () => {
    render(
      <Modal open={true} onClose={jest.fn()} title="Test Modal">
        <p>Modal content</p>
      </Modal>
    )
    
    // Test Dialog classes
    const dialog = screen.getByRole('dialog')
    expect(dialog).toHaveClass('tw-relative', 'tw-z-50')
    
    // Test DialogPanel classes
    const panel = screen.getByRole('dialog').querySelector('[role="dialog"] > div > div')
    expect(panel).toHaveClass('tw-bg-iron-900', 'tw-border', 'tw-border-iron-700')
  })
  
  it('applies data-attribute based styling', () => {
    render(
      <Disclosure>
        <DisclosureButton className="tw-flex tw-items-center tw-gap-2">
          Toggle
        </DisclosureButton>
        <DisclosurePanel>Content</DisclosurePanel>
      </Disclosure>
    )
    
    const button = screen.getByRole('button')
    
    // Check for data attributes that TailwindCSS can target
    fireEvent.click(button)
    
    // After opening, data attributes should be present for styling
    expect(button).toHaveAttribute('data-open', '')
  })
})
```

#### 2. **Testing Menu Component State Styling**
```typescript
describe('Headless UI Menu with TailwindCSS', () => {
  it('applies focus styles to menu items', async () => {
    const items = [
      { label: 'Option 1', onClick: jest.fn() },
      { label: 'Option 2', onClick: jest.fn() }
    ]
    
    render(<DropdownMenu trigger={<span>Menu</span>} items={items} />)
    
    // Open menu
    fireEvent.click(screen.getByText('Menu'))
    
    // Find menu items
    const option1 = screen.getByText('Option 1')
    
    // Test focus state classes (these might be applied via render props)
    fireEvent.mouseEnter(option1)
    
    // Check for focus state styling classes
    expect(option1.closest('button')).toHaveClass('tw-bg-primary-500')
  })
})
```

### **Mobile and Responsive Testing**

#### 1. **Testing Safe Area Classes**
```typescript
describe('Mobile Layout with Safe Area', () => {
  it('applies safe area inset classes', () => {
    render(<MobileLayout>Content</MobileLayout>)
    const layout = screen.getByTestId('mobile-layout')
    
    // Test safe area classes
    expect(layout.className).toMatch(/tw-pt-\[env\(safe-area-inset-top,0px\)\]/)
    expect(layout.className).toMatch(/tw-pb-\[env\(safe-area-inset-bottom,0px\)\]/)
  })
  
  it('applies touch-optimized button classes', () => {
    render(<MobileButton>Touch me</MobileButton>)
    const button = screen.getByRole('button')
    
    expect(button).toHaveClass('tw-min-h-[44px]', 'tw-min-w-[44px]')
    expect(button).toHaveClass('tw-touch-manipulation')
  })
})
```

#### 2. **Testing Container Query Classes**
```typescript
describe('Container Query Components', () => {
  it('applies container query classes', () => {
    render(<AdaptiveCard>Adaptive content</AdaptiveCard>)
    const container = screen.getByTestId('adaptive-card')
    
    expect(container).toHaveClass('tw-@container')
    expect(container.querySelector('div')).toHaveClass('tw-flex-col')
    
    // Test container query responsive class
    expect(container.querySelector('div')?.className).toMatch(/@md:tw-flex-row/)
  })
})
```

### **Web3-Specific Component Testing**

#### 1. **Testing Wallet Connection States**
```typescript
describe('Wallet Connection Button', () => {
  it('applies correct styling for disconnected state', () => {
    render(
      <WalletConnectButton
        connected={false}
        onConnect={jest.fn()}
        onDisconnect={jest.fn()}
      />
    )
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('tw-bg-primary-500', 'tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-primary-600/)
  })
  
  it('applies correct styling for connected state', () => {
    render(
      <WalletConnectButton
        connected={true}
        address="0x1234567890abcdef1234567890abcdef12345678"
        onConnect={jest.fn()}
        onDisconnect={jest.fn()}
      />
    )
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('tw-bg-success', 'tw-text-white')
    expect(button.className).toMatch(/hover:tw-bg-green/)
    
    // Test that the pulse animation is applied to the indicator
    const indicator = button.querySelector('div')
    expect(indicator).toHaveClass('tw-animate-pulse')
  })
})
```

#### 2. **Testing Transaction Status Styling**
```typescript
describe('Transaction Status Component', () => {
  const testCases = [
    {
      status: 'pending' as const,
      expectedClasses: ['tw-text-yellow-400', 'tw-bg-yellow-400/10'],
      expectedIcon: 'tw-animate-spin'
    },
    {
      status: 'confirmed' as const,
      expectedClasses: ['tw-text-green-400', 'tw-bg-green-400/10'],
      expectedIcon: ''
    },
    {
      status: 'failed' as const,
      expectedClasses: ['tw-text-red-400', 'tw-bg-red-400/10'],
      expectedIcon: 'tw-animate-shake'
    }
  ]
  
  testCases.forEach(({ status, expectedClasses, expectedIcon }) => {
    it(`applies correct styling for ${status} status`, () => {
      render(<TransactionStatus status={status} hash="0x123" />)
      
      const container = screen.getByTestId('transaction-status')
      expectedClasses.forEach(className => {
        expect(container).toHaveClass(className)
      })
      
      if (expectedIcon) {
        const indicator = container.querySelector('.tw-rounded-full')
        expect(indicator).toHaveClass(expectedIcon)
      }
    })
  })
})
```

### **Performance and Animation Testing**

#### 1. **Testing Animation Classes**
```typescript
describe('Animated Components', () => {
  it('applies GPU-accelerated transform classes', () => {
    render(<AnimatedModal isOpen={true} />)
    const modal = screen.getByTestId('animated-modal')
    
    expect(modal).toHaveClass('tw-transform')
    expect(modal).toHaveClass('tw-transition-all')
    expect(modal).toHaveClass('tw-opacity-100', 'tw-scale-100')
  })
  
  it('applies correct animation states', () => {
    const { rerender } = render(<AnimatedModal isOpen={false} />)
    const modal = screen.getByTestId('animated-modal')
    
    expect(modal).toHaveClass('tw-opacity-0', 'tw-scale-95')
    
    rerender(<AnimatedModal isOpen={true} />)
    expect(modal).toHaveClass('tw-opacity-100', 'tw-scale-100')
  })
})
```

#### 2. **Testing Memoized Component Classes**
```typescript
describe('Optimized Components', () => {
  it('applies correct variant classes from memoized computation', () => {
    const { rerender } = render(<OptimizedCard variant="default" data={mockData} />)
    const card = screen.getByTestId('optimized-card')
    
    expect(card).toHaveClass('tw-bg-iron-900', 'tw-p-6', 'tw-shadow-lg')
    
    // Test variant change
    rerender(<OptimizedCard variant="featured" data={mockData} />)
    expect(card).toHaveClass('tw-border-primary-500', 'tw-bg-gradient-to-br')
  })
})
```

### **Testing TailwindCSS Utility Functions**

#### 1. **Testing Class Composition Utilities**
```typescript
import { cn } from '../src/utils/cn'
import { getButtonClasses } from '../src/utils/variants/button'

describe('TailwindCSS Utility Functions', () => {
  it('composes classes correctly with cn utility', () => {
    const result = cn(
      'tw-px-4 tw-py-2',
      true && 'tw-bg-primary-500',
      false && 'tw-bg-secondary-500',
      'tw-text-white'
    )
    
    expect(result).toBe('tw-px-4 tw-py-2 tw-bg-primary-500 tw-text-white')
  })
  
  it('generates button classes correctly', () => {
    const primaryMedium = getButtonClasses('primary', 'md')
    
    expect(primaryMedium).toMatch(/tw-bg-primary-500/)
    expect(primaryMedium).toMatch(/tw-px-4/)
    expect(primaryMedium).toMatch(/tw-py-2/)
    expect(primaryMedium).toMatch(/tw-text-sm/)
  })
})
```

#### 2. **Testing Theme Utility Functions**
```typescript
import { getIronClass, getPrimaryClass } from '../src/utils/theme'

describe('Theme Utility Functions', () => {
  it('generates iron scale classes correctly', () => {
    expect(getIronClass(900, 'bg')).toBe('tw-bg-iron-900')
    expect(getIronClass(300, 'text')).toBe('tw-text-iron-300')
    expect(getIronClass(600, 'border')).toBe('tw-border-iron-600')
  })
  
  it('generates primary scale classes correctly', () => {
    expect(getPrimaryClass(500, 'bg')).toBe('tw-bg-primary-500')
    expect(getPrimaryClass(600, 'text')).toBe('tw-text-primary-600')
  })
})
```

### **Visual Regression Testing with Playwright**

#### 1. **Testing TailwindCSS Styles Across Viewports**
```typescript
// e2e/tailwind-responsive.spec.ts
import { test, expect } from '@playwright/test'

test.describe('TailwindCSS Responsive Behavior', () => {
  test('grid layout responds correctly to viewport changes', async ({ page }) => {
    await page.goto('/component-showcase/grid')
    
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 812 })
    const grid = page.locator('[data-testid="responsive-grid"]')
    
    // Verify mobile layout
    await expect(grid).toHaveClass(/tw-grid-cols-1/)
    
    // Test tablet viewport
    await page.setViewportSize({ width: 768, height: 1024 })
    await expect(grid).toHaveClass(/sm:tw-grid-cols-2/)
    
    // Test desktop viewport
    await page.setViewportSize({ width: 1280, height: 720 })
    await expect(grid).toHaveClass(/lg:tw-grid-cols-3/)
    
    // Test custom 3xl breakpoint
    await page.setViewportSize({ width: 2048, height: 1080 })
    await expect(grid).toHaveClass(/tw-3xl:tw-grid-cols-4/)
  })
  
  test('dark mode styling applies correctly', async ({ page }) => {
    await page.goto('/component-showcase')
    
    // Test light mode
    await expect(page.locator('html')).not.toHaveClass('dark')
    const card = page.locator('[data-testid="theme-card"]')
    await expect(card).toHaveClass(/tw-bg-white/)
    
    // Toggle dark mode
    await page.click('[data-testid="theme-toggle"]')
    await expect(page.locator('html')).toHaveClass('dark')
    await expect(card).toHaveClass(/dark:tw-bg-iron-900/)
  })
})
```

#### 2. **Testing Animation and Transition Classes**
```typescript
test.describe('TailwindCSS Animations', () => {
  test('modal animations work correctly', async ({ page }) => {
    await page.goto('/component-showcase/modal')
    
    // Test modal opening animation
    await page.click('[data-testid="open-modal"]')
    const modal = page.locator('[data-testid="modal"]')
    
    // Check for animation classes
    await expect(modal).toHaveClass(/tw-transition-all/)
    await expect(modal).toHaveClass(/tw-duration-300/)
    
    // Wait for animation to complete and check final state
    await page.waitForTimeout(350)
    await expect(modal).toHaveClass(/tw-opacity-100/)
    await expect(modal).toHaveClass(/tw-scale-100/)
  })
})
```

### **Testing Custom TailwindCSS Configuration**

#### 1. **Testing Custom Colors and Classes**
```typescript
describe('Custom TailwindCSS Configuration', () => {
  it('supports custom iron color scale', () => {
    render(<div className="tw-bg-iron-950 tw-text-iron-50" data-testid="custom-colors" />)
    const element = screen.getByTestId('custom-colors')
    
    expect(element).toHaveClass('tw-bg-iron-950')
    expect(element).toHaveClass('tw-text-iron-50')
  })
  
  it('supports custom animations', () => {
    render(<div className="tw-animate-loading-bar" data-testid="custom-animation" />)
    const element = screen.getByTestId('custom-animation')
    
    expect(element).toHaveClass('tw-animate-loading-bar')
  })
  
  it('supports custom shadows', () => {
    render(<button className="tw-shadow-drop-btn-active" data-testid="custom-shadow" />)
    const element = screen.getByTestId('custom-shadow')
    
    expect(element).toHaveClass('tw-shadow-drop-btn-active')
  })
})
```

---

**Test behavior, not implementation. Focus on user interactions and component contracts rather than internal structure. ALWAYS test that TailwindCSS classes are applied correctly with tw- prefix.**