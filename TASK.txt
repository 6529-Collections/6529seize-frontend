**Overall Objective:**

Refactor the basic React component located at `components/waves/drops/WaveDropsNonReverseContainer.tsx` into a robust, high-quality, scrollable container named `WaveDropsReverseContainer`. This component will use `flex-col-reverse` for a bottom-to-top content flow (like chat interfaces). It must reliably handle loading older content when scrolling up, maintain visual scroll position during loads, automatically scroll to new items appearing at the bottom (only if the user is already scrolled there), and report scroll events.

**Starting File:** `components/waves/drops/WaveDropsNonReverseContainer.tsx` (Assume it's the basic version with only the `div` and props).

**Detailed Steps:**

**Phase 1: Setup and File Structure**

1.  **Rename:**
    *   Rename the file to `components/waves/drops/WaveDropsReverseContainer.tsx`.
    *   Rename the component function inside the file to `WaveDropsReverseContainer`.
    *   Update the `displayName` static property to `"WaveDropsReverseContainer"`.
2.  **Create Hook Directory:** Create a new directory `hooks/scroll/` if it doesn't already exist.
3.  **Create Hook Files:** Create the following empty files within `hooks/scroll/`:
    *   `useIntersectionObserver.ts`
    *   `useScrollPositionRestorer.ts`
    *   `useStickToBottom.ts`

**Phase 2: Implement Custom Hooks**

1.  **Implement `hooks/scroll/useIntersectionObserver.ts`:**
    *   **Purpose:** Generic hook to manage an `IntersectionObserver`.
    *   **Signature:**
        ```typescript
        import { RefObject, useEffect, useRef } from 'react';

        interface UseIntersectionObserverOptions extends IntersectionObserverInit {
          freezeOnceVisible?: boolean; // Optional: To disconnect observer once target is visible
        }

        export function useIntersectionObserver(
          targetRef: RefObject<Element | null>,
          options: UseIntersectionObserverOptions,
          callback: (entry: IntersectionObserverEntry) => void,
          enabled: boolean = true // Allow disabling the observer
        ): void;
        ```
    *   **Logic:** Use `useEffect`. Create observer with `options` when `enabled` and `targetRef.current` exist. Observe the target. The observer's internal callback should call the passed `callback`. Include cleanup to `disconnect` the observer. Handle the `freezeOnceVisible` option if implemented. Ensure dependencies (`options.rootMargin`, `options.threshold`, `enabled`, `callback`, `targetRef`) are correctly managed.

2.  **Implement `hooks/scroll/useScrollPositionRestorer.ts`:**
    *   **Purpose:** Maintain visual scroll position when older items are prepended (typically during `isFetching`).
    *   **Signature:**
        ```typescript
        import { RefObject, useLayoutEffect, useRef } from 'react';

        export function useScrollPositionRestorer(
          scrollContainerRef: RefObject<HTMLElement | null>,
          isFetching: boolean
        ): void;
        ```
    *   **Logic:**
        *   Use refs: `isFetchingPreviousRef = useRef<boolean>(false)`, `scrollHeightBeforeFetchRef = useRef<number>(0)`, `shouldRestoreRef = useRef<boolean>(false)`.
        *   Use `useLayoutEffect` (runs before paint):
            *   Check if `isFetching` just became `true` (compare with `isFetchingPreviousRef`).
            *   If so, check if `scrollContainerRef.current.scrollTop` is near the top (e.g., `< 10`). If yes, set `shouldRestoreRef.current = true` and record `scrollHeightBeforeFetchRef.current = scrollContainerRef.current.scrollHeight`.
            *   Check if `isFetching` just became `false` *and* `shouldRestoreRef.current` is `true`.
            *   If so, calculate `heightDifference = scrollContainerRef.current.scrollHeight - scrollHeightBeforeFetchRef.current`.
            *   If `heightDifference > 0`, adjust scroll: `scrollContainerRef.current.scrollTop += heightDifference;`.
            *   Reset `shouldRestoreRef.current = false;`.
            *   Always update `isFetchingPreviousRef.current = isFetching` at the end of the effect.

3.  **Implement `hooks/scroll/useStickToBottom.ts`:**
    *   **Purpose:** Automatically scroll to the bottom when new content arrives, but *only if* the user was already near the bottom *before* the content change.
    *   **Signature:**
        ```typescript
        import { RefObject, useLayoutEffect, useRef } from 'react';

        export function useStickToBottom(
          scrollContainerRef: RefObject<HTMLElement | null>,
          contentLength: number, // Use length as a simple dependency trigger
          isAtBottom: boolean // Pass the *current* isAtBottom status
        ): void;
        ```
    *   **Logic:**
        *   Use refs: `wasAtBottomRef = useRef<boolean>(true)`, `previousContentLengthRef = useRef<number>(contentLength)`.
        *   Use `useLayoutEffect`:
            *   Check if `contentLength` increased compared to `previousContentLengthRef.current`.
            *   If it increased *and* `wasAtBottomRef.current` was `true`:
                *   Use `requestAnimationFrame(() => { ... });` or `setTimeout(() => { ... }, 0);` inside the effect to ensure layout is finalized before scrolling.
                *   Inside the rAF/setTimeout callback: Scroll to bottom: `scrollContainerRef.current?.scrollTo({ top: scrollContainerRef.current.scrollHeight, behavior: 'smooth' });` (or `auto`).
            *   Update `wasAtBottomRef.current = isAtBottom` *before* the content length check.
            *   Update `previousContentLengthRef.current = contentLength` at the end of the effect.
        *   **Crucial Dependency Order:** Ensure the effect depends on `contentLength` and potentially `isAtBottom` (or manage `wasAtBottomRef` update carefully relative to the effect). The goal is to capture the `isAtBottom` status *before* the length change triggers the effect's main logic.

**Phase 3: Implement Main Component (`WaveDropsReverseContainer.tsx`)**

1.  **Imports:** Import `React`, hooks (`useRef`, `useEffect`, `useLayoutEffect`, `useState`, `forwardRef`, `useCallback`), and the three custom hooks.
2.  **Props:** Define the `WaveDropsReverseContainerProps` interface:
    ```typescript
    interface WaveDropsReverseContainerProps {
      readonly children: React.ReactNode;
      readonly onTopIntersection: () => void;
      readonly isFetchingNextPage: boolean; // Note: Renamed from isFetching for clarity? Keep consistent with usage. Assuming isFetchingNextPage.
      readonly onUserScroll?: (direction: "up" | "down", isAtBottom: boolean) => void;
    }
    ```
3.  **Component Signature:** Use `forwardRef<HTMLDivElement, WaveDropsReverseContainerProps>`.
4.  **Refs:**
    *   `scrollContainerRef = useRef<HTMLDivElement>(null);`
    *   `contentWrapperRef = useRef<HTMLDivElement>(null);`
    *   `topSentinelRef = useRef<HTMLDivElement>(null);`
    *   `lastScrollTop = useRef<number>(0);`
    *   `isAtBottom = useRef<boolean>(true);`
    *   `scrollRafId = useRef<number | null>(null);` // For rAF throttling
5.  **Hook Integration:**
    *   `useScrollPositionRestorer(scrollContainerRef, isFetchingNextPage);`
    *   `useStickToBottom(scrollContainerRef, React.Children.count(children), isAtBottom.current);` // Pass length
    *   Define `handleIntersection = useCallback((entry: IntersectionObserverEntry) => { if (entry.isIntersecting) { onTopIntersection(); } }, [onTopIntersection]);`
    *   `useIntersectionObserver(topSentinelRef, { root: scrollContainerRef.current, rootMargin: '2000px 0px 0px 0px', threshold: 0 }, handleIntersection, !!scrollContainerRef.current && !isFetchingNextPage);` // Enable only when root exists and not fetching
6.  **Scroll Handler (`handleScroll`):**
    *   Implement `handleScroll = useCallback(() => { ... }, [onUserScroll]);`
    *   Inside `handleScroll`:
        *   Cancel any pending `rAF`: `if (scrollRafId.current) { cancelAnimationFrame(scrollRafId.current); }`
        *   Request a new frame: `scrollRafId.current = requestAnimationFrame(() => { ... });`
        *   Inside the `rAF` callback:
            *   Get `container = scrollContainerRef.current;` if (!container) return;
            *   Calculate `scrollTop`, `scrollHeight`, `clientHeight`.
            *   Calculate `currentIsAtBottom = scrollHeight - scrollTop - clientHeight < 5;`. Update `isAtBottom.current = currentIsAtBottom;`.
            *   Determine `direction = scrollTop > lastScrollTop.current ? 'down' : 'up';` (handle `scrollTop === 0` edge case if needed).
            *   Call `onUserScroll?.(direction, currentIsAtBottom);`
            *   Update `lastScrollTop.current = scrollTop;`.
            *   Reset `scrollRafId.current = null;`.
7.  **Rendering:**
    *   Return the main `div`:
        *   `ref={scrollContainerRef}` (and handle `forwardRef` using `useImperativeHandle` if parent needs direct access, otherwise internal ref is sufficient).
        *   `onScroll={handleScroll}`
        *   `className="tw-flex tw-flex-col-reverse tw-overflow-y-auto ... other styles ..."`
    *   Inside, render a wrapper `div`:
        *   `ref={contentWrapperRef}`
    *   Inside the wrapper, *before* children, render the sentinel:
        *   `<div ref={topSentinelRef} style={{ height: '1px' }} />`
    *   Render `{children}` after the sentinel.
8.  **Cleanup:** Add a `useEffect` cleanup function to cancel any pending `requestAnimationFrame` from `handleScroll` when the component unmounts: `return () => { if (scrollRafId.current) { cancelAnimationFrame(scrollRafId.current); } };`

**Final Check:** Ensure all props are `readonly`, types are correct, imports are present, and no unused variables or old logic remain. The code should be clean, well-formatted, and without obvious comments for trivial parts.

---
