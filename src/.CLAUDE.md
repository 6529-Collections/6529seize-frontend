# Src Directory Context

## Core Philosophy: Simple, Clear Service Layer

**"Write service layer code that does one thing well. Keep business logic separate from UI concerns. Favor clear, readable functions over clever abstractions."**

## Simple Service Patterns (2025 Best Practices)

### API Service Pattern
```typescript
// ✅ Good: Simple, clear API service
export class UserService {
  private baseUrl = '/api/users'

  async getUser(id: string): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`)
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`)
    }
    return response.json()
  }

  async updateUser(id: string, updates: Partial<User>): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    })
    if (!response.ok) {
      throw new Error(`Failed to update user: ${response.statusText}`)
    }
    return response.json()
  }
}

// ❌ Avoid: Over-engineered service with too much abstraction
class UniversalService<T, K, V> {
  // 200 lines of generic complexity that nobody understands...
}
```

### Utility Function Pattern
```typescript
// ✅ Good: Simple, focused utility functions
export function formatAddress(address: string): string {
  if (!address || address.length < 10) return address
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

export function validateEthereumAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address)
}

export function parseWeiToEth(wei: bigint): string {
  return (Number(wei) / 1e18).toFixed(4)
}

// ❌ Avoid: Trying to be too generic
export function formatAnything<T>(input: T, config: FormatConfig<T>): string {
  // Complex generic formatting logic that's hard to understand...
}
```

### Web3 Service Patterns (Security-First, Simple)
```typescript
// ✅ Good: Clear, secure wallet operations
export class WalletService {
  async connectWallet(provider: string): Promise<{ address: string; chainId: number }> {
    // Simple validation
    if (!provider) {
      throw new Error('Provider is required')
    }

    try {
      // Simple connection logic
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
      const chainId = await window.ethereum.request({ method: 'eth_chainId' })
      
      return {
        address: accounts[0],
        chainId: parseInt(chainId, 16)
      }
    } catch (error) {
      throw new Error(`Wallet connection failed: ${error.message}`)
    }
  }
}

// ❌ Avoid: Over-complex abstraction layers for wallet operations
```

## File Organization & Utility Structure

### Current Structure
```
src/
├── errors/                  # Error handling utilities
│   ├── authentication.ts   # Auth-specific errors
│   ├── wallet-auth.ts      # Wallet authentication errors
│   ├── wallet-connection.ts # Connection error handling
│   └── adapter.ts          # Adapter pattern errors
├── types/                  # TypeScript definitions
│   ├── security.ts         # Security-related types
│   └── window.d.ts         # Window object extensions
└── utils/                  # Pure utility functions
    ├── security-logger.ts  # Secure logging utilities
    └── wallet-sanitization.ts # Input sanitization
```

### File Organization Principles

#### Single Responsibility for Utilities
- **One Function Per File**: Small, focused utility functions
- **Related Functions**: Group in same file only if tightly coupled
- **Pure Functions**: No side effects, predictable outputs
- **Type Safety**: Full TypeScript coverage for all utilities

#### Error Handling Architecture
```typescript
// ✅ Good: Specific error types
class WalletConnectionError extends Error {
  constructor(message: string, public code: string) {
    super(message)
    this.name = 'WalletConnectionError'
  }
}

class AuthenticationError extends Error {
  constructor(message: string, public code: string) {
    super(message)
    this.name = 'AuthenticationError'
  }
}

// ✅ Good: Error factory functions
export function createWalletError(code: string, message: string) {
  return new WalletConnectionError(message, code)
}
```

### Utility Function Patterns

#### Pure Function Design
```typescript
// ✅ Good: Pure utility function
export function formatCurrency(
  amount: number | bigint,
  currency: string = 'USD',
  decimals: number = 2
): string {
  const numericAmount = typeof amount === 'bigint' 
    ? Number(amount) / Math.pow(10, 18) // Handle Wei conversion
    : amount
    
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  }).format(numericAmount)
}

// ✅ Good: Validation utility
export function isValidEthereumAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address)
}

// ✅ Good: Transformation utility
export function truncateAddress(
  address: string,
  startChars: number = 6,
  endChars: number = 4
): string {
  if (!isValidEthereumAddress(address)) {
    throw new Error('Invalid Ethereum address')
  }
  
  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`
}
```

### Fail-Fast Utility Architecture

### **CRITICAL: Enhanced Error Handling Utilities with Fail-Fast Patterns**

Building upon existing `security-logger.ts` and `error-sanitizer.ts` foundation:

#### 1. **Ultra-Aggressive Error Class System**

```typescript
// src/utils/enhanced-error-classes.ts
// Enhanced base error class for fail-fast patterns
export abstract class SeizeError extends Error {
  abstract readonly type: string;
  abstract readonly code: string;
  abstract readonly severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  
  readonly timestamp: string;
  readonly context: Record<string, unknown>;
  readonly sessionId: string;

  constructor(
    message: string,
    code: string,
    context: Record<string, unknown> = {},
    cause?: Error
  ) {
    super(message, { cause });
    this.name = this.constructor.name;
    this.code = code;
    this.timestamp = new Date().toISOString();
    this.context = sanitizeMetadata(context);
    this.sessionId = generateSecureSessionId();
  }

  /**
   * Creates secure log entry with sanitized data
   */
  toSecureLogEntry(): SecurityLogEntry {
    return {
      timestamp: this.timestamp,
      type: this.type,
      code: this.code,
      severity: this.severity,
      message: sanitizeErrorMessage(this.message),
      context: this.context,
      sessionId: this.sessionId,
      stack: this.stack ? sanitizeErrorMessage(this.stack) : undefined,
      cause: this.cause ? sanitizeErrorMessage(String(this.cause)) : undefined
    };
  }

  /**
   * Determines if error should trigger immediate application termination
   */
  shouldTerminateApplication(): boolean {
    return this.severity === 'CRITICAL';
  }

  /**
   * Determines if error allows user-initiated recovery
   */
  allowsRecovery(): boolean {
    return this.severity !== 'CRITICAL' && this.type !== 'SECURITY_VIOLATION';
  }
}

// Critical security errors - ALWAYS terminate
export class SecurityViolationError extends SeizeError {
  readonly type = 'SECURITY_VIOLATION';
  readonly severity = 'CRITICAL' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Authentication errors - HIGH priority, fail-fast
export class AuthenticationError extends SeizeError {
  readonly type = 'AUTHENTICATION_ERROR';
  readonly severity = 'HIGH' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Transaction errors - HIGH priority, financial implications
export class TransactionError extends SeizeError {
  readonly type = 'TRANSACTION_ERROR';
  readonly severity = 'HIGH' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Wallet connection errors - HIGH priority, security implications
export class WalletConnectionError extends SeizeError {
  readonly type = 'WALLET_CONNECTION_ERROR';
  readonly severity = 'HIGH' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Validation errors - MEDIUM priority, may allow recovery
export class ValidationError extends SeizeError {
  readonly type = 'VALIDATION_ERROR';
  readonly severity = 'MEDIUM' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Network errors - MEDIUM priority, may be transient
export class NetworkError extends SeizeError {
  readonly type = 'NETWORK_ERROR';
  readonly severity = 'MEDIUM' as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}
```

#### 2. **Enhanced Security Logging Utilities**

```typescript
// src/utils/enhanced-security-logger.ts
// Builds upon existing security-logger.ts

/**
 * Critical error logging with immediate alerts
 */
export const logCriticalError = (
  context: string,
  error: SeizeError,
  additionalContext?: Record<string, unknown>
): void => {
  const logEntry = {
    ...error.toSecureLogEntry(),
    context,
    additionalContext: additionalContext ? sanitizeMetadata(additionalContext) : undefined,
    actionRequired: getRequiredAction(error),
    shouldAlert: error.severity === 'CRITICAL',
    allowsRecovery: error.allowsRecovery()
  };

  // Immediate security alerts for critical errors
  if (error instanceof SecurityViolationError) {
    sendSecurityAlert({
      ...logEntry,
      alertLevel: 'IMMEDIATE',
      threatLevel: 'HIGH',
      requiresInvestigation: true
    });
  }

  // Enhanced structured logging
  if (process.env.NODE_ENV === 'production') {
    console.error(`[SEIZE_CRITICAL][${error.severity}][${error.code}]`, logEntry);
    
    // Send to monitoring service with structured format
    sendToMonitoringService({
      ...logEntry,
      tags: {
        application: '6529seize',
        environment: 'production',
        errorType: error.type,
        severity: error.severity
      }
    });
  } else {
    // Enhanced development logging
    console.group(`🚨 ${error.severity} ERROR: ${error.type}`);
    console.error('Error Code:', error.code);
    console.error('Context:', context);
    console.error('Message:', error.message);
    console.error('Sanitized Stack:', error.stack ? sanitizeErrorMessage(error.stack) : 'No stack');
    console.error('Allows Recovery:', error.allowsRecovery());
    console.error('Should Terminate:', error.shouldTerminateApplication());
    if (additionalContext) {
      console.error('Additional Context:', sanitizeMetadata(additionalContext));
    }
    console.groupEnd();
  }
};

/**
 * Determines required action based on error type and severity
 */
function getRequiredAction(error: SeizeError): string {
  switch (error.type) {
    case 'SECURITY_VIOLATION':
      return 'IMMEDIATE_SECURITY_INVESTIGATION_REQUIRED';
    case 'AUTHENTICATION_ERROR':
      return 'USER_REAUTHENTICATION_REQUIRED';
    case 'TRANSACTION_ERROR':
      return 'TRANSACTION_REVIEW_AND_RETRY';
    case 'WALLET_CONNECTION_ERROR':
      return 'WALLET_RECONNECTION_REQUIRED';
    case 'VALIDATION_ERROR':
      return 'USER_INPUT_CORRECTION_REQUIRED';
    case 'NETWORK_ERROR':
      return 'NETWORK_CONNECTIVITY_CHECK_REQUIRED';
    default:
      return 'STANDARD_ERROR_HANDLING_REQUIRED';
  }
}

/**
 * Generates secure session ID for error correlation
 */
function generateSecureSessionId(): string {
  const timestamp = Date.now().toString(36);
  const randomBytes = new Uint8Array(8);
  crypto.getRandomValues(randomBytes);
  const randomPart = Array.from(randomBytes, byte => byte.toString(16).padStart(2, '0')).join('');
  return `${timestamp}_${randomPart}`;
}
```

#### 3. **Fail-Fast Validation Utilities**

```typescript
// src/utils/fail-fast-validation.ts
// Ultra-aggressive validation with immediate termination

/**
 * Validates Ethereum address with fail-fast security checks
 */
export function validateEthereumAddressOrThrow(
  address: unknown,
  context: string = 'unknown_context'
): string {
  if (!address || typeof address !== 'string') {
    throw new SecurityViolationError(
      'Address validation failed: null or invalid type',
      'VALIDATION_ADDRESS_NULL_OR_INVALID_TYPE',
      { 
        context,
        receivedType: typeof address,
        addressLength: address?.toString?.()?.length || 0
      }
    );
  }

  if (!address.startsWith('0x')) {
    throw new SecurityViolationError(
      'Address validation failed: missing 0x prefix',
      'VALIDATION_ADDRESS_MISSING_PREFIX',
      { context, addressLength: address.length }
    );
  }

  if (address.length !== 42) {
    throw new SecurityViolationError(
      'Address validation failed: invalid length',
      'VALIDATION_ADDRESS_INVALID_LENGTH',
      { context, addressLength: address.length, expected: 42 }
    );
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new SecurityViolationError(
      'Address validation failed: invalid hex characters',
      'VALIDATION_ADDRESS_INVALID_HEX',
      { context }
    );
  }

  return address.toLowerCase();
}

/**
 * Validates JWT token format with fail-fast security checks
 */
export function validateJWTFormatOrThrow(
  token: unknown,
  context: string = 'unknown_context'
): string {
  if (!token || typeof token !== 'string') {
    throw new AuthenticationError(
      'JWT validation failed: null or invalid type',
      'AUTH_JWT_NULL_OR_INVALID_TYPE',
      { context, receivedType: typeof token }
    );
  }

  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new AuthenticationError(
      'JWT validation failed: invalid structure',
      'AUTH_JWT_INVALID_STRUCTURE',
      { context, partCount: parts.length, expected: 3 }
    );
  }

  // Validate each part is base64url
  for (let i = 0; i < parts.length; i++) {
    if (!isValidBase64Url(parts[i])) {
      throw new AuthenticationError(
        `JWT validation failed: invalid base64url in part ${i + 1}`,
        'AUTH_JWT_INVALID_BASE64URL',
        { context, partIndex: i }
      );
    }
  }

  return token;
}

/**
 * Validates transaction parameters with fail-fast security checks
 */
export function validateTransactionParamsOrThrow(
  params: unknown,
  context: string = 'unknown_context'
): TransactionParams {
  if (!params || typeof params !== 'object') {
    throw new TransactionError(
      'Transaction validation failed: null or invalid type',
      'TRANSACTION_PARAMS_NULL_OR_INVALID_TYPE',
      { context, receivedType: typeof params }
    );
  }

  const txParams = params as Record<string, unknown>;

  // Validate recipient address
  if (!txParams.to) {
    throw new TransactionError(
      'Transaction validation failed: missing recipient address',
      'TRANSACTION_MISSING_RECIPIENT',
      { context }
    );
  }

  const validatedRecipient = validateEthereumAddressOrThrow(txParams.to, `${context}_recipient`);

  // Validate amount
  if (!txParams.value || typeof txParams.value !== 'string') {
    throw new TransactionError(
      'Transaction validation failed: invalid amount',
      'TRANSACTION_INVALID_AMOUNT',
      { context, receivedType: typeof txParams.value }
    );
  }

  const numericValue = parseFloat(txParams.value);
  if (isNaN(numericValue) || numericValue <= 0) {
    throw new TransactionError(
      'Transaction validation failed: amount is not a positive number',
      'TRANSACTION_AMOUNT_NOT_POSITIVE',
      { context, receivedValue: txParams.value, parsedValue: numericValue }
    );
  }

  // Security check: prevent extremely large transactions
  if (numericValue > MAX_TRANSACTION_AMOUNT) {
    throw new SecurityViolationError(
      'Transaction validation failed: amount exceeds security threshold',
      'TRANSACTION_AMOUNT_SECURITY_VIOLATION',
      { 
        context, 
        amount: numericValue, 
        threshold: MAX_TRANSACTION_AMOUNT,
        ratio: numericValue / MAX_TRANSACTION_AMOUNT
      }
    );
  }

  return {
    to: validatedRecipient,
    value: txParams.value,
    gasLimit: txParams.gasLimit as string,
    gasPrice: txParams.gasPrice as string
  };
}

// Security constants
const MAX_TRANSACTION_AMOUNT = 1000; // 1000 ETH - adjust based on requirements
const isValidBase64Url = (str: string): boolean => /^[A-Za-z0-9_-]+$/.test(str);
```

#### 4. **Enhanced Result Pattern Utilities**

```typescript
// src/utils/fail-fast-result.ts
// TypeScript Result pattern for structured error handling

export type Result<T, E extends SeizeError> = 
  | { ok: true; value: T }
  | { ok: false; error: E };

/**
 * Creates successful result
 */
export const Ok = <T>(value: T): Result<T, never> => ({ ok: true, value });

/**
 * Creates error result with structured error
 */
export const Err = <E extends SeizeError>(error: E): Result<never, E> => ({ ok: false, error });

/**
 * Wraps operation in try-catch and returns Result
 */
export const tryCatch = <T, E extends SeizeError>(
  operation: () => T,
  errorHandler: (error: unknown) => E
): Result<T, E> => {
  try {
    return Ok(operation());
  } catch (error) {
    return Err(errorHandler(error));
  }
};

/**
 * Wraps async operation in try-catch and returns Result
 */
export const asyncTryCatch = async <T, E extends SeizeError>(
  operation: () => Promise<T>,
  errorHandler: (error: unknown) => E
): Promise<Result<T, E>> => {
  try {
    const value = await operation();
    return Ok(value);
  } catch (error) {
    return Err(errorHandler(error));
  }
};

/**
 * Fail-fast pattern: unwrap result or throw error
 */
export const unwrapOrThrow = <T, E extends SeizeError>(result: Result<T, E>): T => {
  if (!result.ok) {
    // Log error before throwing
    logCriticalError('result_unwrap_failure', result.error);
    throw result.error;
  }
  return result.value;
};

/**
 * Chain operations with fail-fast error propagation
 */
export const chain = <T, U, E extends SeizeError>(
  result: Result<T, E>,
  operation: (value: T) => Result<U, E>
): Result<U, E> => {
  if (!result.ok) {
    return result;
  }
  return operation(result.value);
};

/**
 * Map over successful result or propagate error
 */
export const map = <T, U, E extends SeizeError>(
  result: Result<T, E>,
  mapper: (value: T) => U
): Result<U, E> => {
  if (!result.ok) {
    return result;
  }
  return Ok(mapper(result.value));
};
```

#### 5. **Fail-Fast API Utilities**

```typescript
// src/utils/fail-fast-api.ts
// Aggressive API error handling with immediate failure

/**
 * Enhanced API request wrapper with fail-fast patterns
 */
export async function secureApiRequest<T>(
  endpoint: string,
  options: RequestInit = {},
  context: string = 'unknown_api_request'
): Promise<Result<T, NetworkError | AuthenticationError | ValidationError>> {
  const requestId = generateSecureSessionId();
  
  try {
    // Pre-flight validation
    if (!endpoint || typeof endpoint !== 'string') {
      throw new ValidationError(
        'API request failed: invalid endpoint',
        'API_INVALID_ENDPOINT',
        { context, endpoint, requestId }
      );
    }

    const url = `${process.env.NEXT_PUBLIC_API_BASE_URL}${endpoint}`;
    
    // Validate URL format
    try {
      new URL(url);
    } catch {
      throw new ValidationError(
        'API request failed: malformed URL',
        'API_MALFORMED_URL',
        { context, url: sanitizeErrorMessage(url), requestId }
      );
    }

    const requestConfig: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'X-Request-ID': requestId,
        ...options.headers
      }
    };

    logSecurityEvent(SecurityEventType.API_REQUEST_INITIATED, {
      context,
      endpoint: sanitizeErrorMessage(endpoint),
      method: requestConfig.method || 'GET',
      requestId
    });

    const response = await fetch(url, requestConfig);

    // Aggressive response validation
    if (!response.ok) {
      const errorBody = await response.text().catch(() => 'Unable to read error response');
      
      switch (response.status) {
        case 401:
          throw new AuthenticationError(
            'API request failed: unauthorized',
            'API_UNAUTHORIZED',
            { 
              context, 
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
              errorBody: sanitizeErrorMessage(errorBody)
            }
          );
        
        case 403:
          throw new AuthenticationError(
            'API request failed: forbidden',
            'API_FORBIDDEN',
            { 
              context, 
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId
            }
          );
        
        case 400:
          throw new ValidationError(
            'API request failed: bad request',
            'API_BAD_REQUEST',
            { 
              context, 
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
              errorBody: sanitizeErrorMessage(errorBody)
            }
          );
        
        default:
          throw new NetworkError(
            `API request failed with status ${response.status}`,
            'API_REQUEST_FAILED',
            { 
              context, 
              status: response.status,
              statusText: response.statusText,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId
            }
          );
      }
    }

    // Parse and validate response
    let data: T;
    try {
      data = await response.json();
    } catch (parseError) {
      throw new NetworkError(
        'API request failed: invalid JSON response',
        'API_INVALID_JSON_RESPONSE',
        { 
          context,
          endpoint: sanitizeErrorMessage(endpoint),
          requestId,
          parseError: String(parseError)
        }
      );
    }

    logSecurityEvent(SecurityEventType.API_REQUEST_COMPLETED, {
      context,
      endpoint: sanitizeErrorMessage(endpoint),
      status: response.status,
      requestId
    });

    return Ok(data);

  } catch (error) {
    if (error instanceof SeizeError) {
      logCriticalError('api_request_error', error, { context, requestId });
      return Err(error);
    }

    // Wrap unexpected errors
    const networkError = new NetworkError(
      'API request failed: unexpected error',
      'API_UNEXPECTED_ERROR',
      { 
        context,
        requestId,
        originalError: String(error)
      }
    );
    
    logCriticalError('api_unexpected_error', networkError, { context, requestId });
    return Err(networkError);
  }
}
```

### Legacy Error Handling Utilities (Being Enhanced)
```typescript
// ❌ BEING ENHANCED: Basic error handling (from existing security-logger.ts)
export function sanitizeErrorMessage(message: string): string {
  // Remove sensitive patterns
  return message
    .replace(/0x[a-fA-F0-9]+/g, '[ADDRESS_REDACTED]')
    .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL_REDACTED]')
    .replace(/\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b/g, '[CARD_REDACTED]')
}

// ❌ BEING ENHANCED: Basic error logging (from existing security-logger.ts)
export function logError(
  context: string,
  error: Error,
  metadata?: Record<string, unknown>
): void {
  const logEntry = {
    timestamp: new Date().toISOString(),
    context,
    name: error.name,
    message: sanitizeErrorMessage(error.message),
    stack: error.stack ? sanitizeErrorMessage(error.stack) : undefined,
    metadata: metadata ? sanitizeMetadata(metadata) : undefined
  }
  
  // Log to appropriate service based on environment
  if (process.env.NODE_ENV === 'development') {
    console.error('[ERROR]', logEntry)
  } else {
    // Send to monitoring service
    sendToMonitoringService(logEntry)
  }
}
```

### Type Organization Strategy

#### Domain-Specific Types
```typescript
// types/wallet.ts
export interface WalletConnection {
  address: string
  chainId: number
  isConnected: boolean
  provider: unknown
}

export interface WalletError {
  code: string
  message: string
  details?: Record<string, unknown>
}

export type WalletState = 
  | { status: 'disconnected' }
  | { status: 'connecting' }
  | { status: 'connected'; connection: WalletConnection }
  | { status: 'error'; error: WalletError }
```

#### Shared Base Types
```typescript
// types/common.ts
export interface ApiResponse<T> {
  data: T
  success: boolean
  message?: string
  error?: string
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    hasMore: boolean
  }
}

export type AsyncState<T> = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: Error }
```

#### Component Prop Types
```typescript
// types/components.ts
export interface BaseComponentProps {
  className?: string
  children?: React.ReactNode
  testId?: string
}

export interface ButtonProps extends BaseComponentProps {
  variant?: 'primary' | 'secondary' | 'danger'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  loading?: boolean
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
}

export interface ModalProps extends BaseComponentProps {
  isOpen: boolean
  onClose: () => void
  title?: string
  size?: 'small' | 'medium' | 'large' | 'fullscreen'
}
```

### Security Utilities

#### Input Sanitization
```typescript
// utils/sanitization.ts
export function sanitizeUserInput(input: string): string {
  return input
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+\s*=/gi, '')
}

export function sanitizeHtml(html: string): string {
  // Use DOMPurify or similar library in production
  return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
}

export function validateAndSanitizeAddress(address: string): string {
  const sanitized = address.trim().toLowerCase()
  
  if (!isValidEthereumAddress(sanitized)) {
    throw new Error('Invalid Ethereum address format')
  }
  
  return sanitized
}
```

#### Crypto Utilities
```typescript
// utils/crypto.ts
export function generateSecureNonce(): string {
  const array = new Uint8Array(32)
  crypto.getRandomValues(array)
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
}

export function hashMessage(message: string): string {
  const encoder = new TextEncoder()
  const data = encoder.encode(message)
  
  return crypto.subtle.digest('SHA-256', data)
    .then(hashBuffer => {
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    })
}

export function isSecureContext(): boolean {
  return typeof window !== 'undefined' && window.isSecureContext
}
```

### Data Transformation Utilities

#### Web3 Utilities
```typescript
// utils/web3.ts
export function weiToEth(wei: bigint): number {
  return Number(wei) / Math.pow(10, 18)
}

export function ethToWei(eth: number): bigint {
  return BigInt(Math.floor(eth * Math.pow(10, 18)))
}

export function formatTokenAmount(
  amount: bigint,
  decimals: number = 18,
  displayDecimals: number = 4
): string {
  const divisor = BigInt(Math.pow(10, decimals))
  const quotient = amount / divisor
  const remainder = amount % divisor
  
  const decimal = Number(remainder) / Math.pow(10, decimals)
  const total = Number(quotient) + decimal
  
  return total.toFixed(displayDecimals)
}

export function shortenTransactionHash(hash: string): string {
  return `${hash.slice(0, 6)}...${hash.slice(-4)}`
}
```

#### Date & Time Utilities
```typescript
// utils/time.ts
export function formatRelativeTime(date: Date | string): string {
  const now = new Date()
  const target = new Date(date)
  const diffMs = now.getTime() - target.getTime()
  
  const units = [
    { label: 'year', ms: 365 * 24 * 60 * 60 * 1000 },
    { label: 'month', ms: 30 * 24 * 60 * 60 * 1000 },
    { label: 'day', ms: 24 * 60 * 60 * 1000 },
    { label: 'hour', ms: 60 * 60 * 1000 },
    { label: 'minute', ms: 60 * 1000 },
    { label: 'second', ms: 1000 }
  ]
  
  for (const unit of units) {
    const value = Math.floor(diffMs / unit.ms)
    if (value > 0) {
      return `${value} ${unit.label}${value > 1 ? 's' : ''} ago`
    }
  }
  
  return 'just now'
}

export function isExpired(expiryDate: Date | string): boolean {
  return new Date(expiryDate) < new Date()
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setDate(result.getDate() + days)
  return result
}
```

### API Integration Utilities

#### HTTP Client Utilities
```typescript
// utils/api.ts
export interface ApiConfig {
  baseUrl: string
  timeout: number
  headers: Record<string, string>
}

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${process.env.NEXT_PUBLIC_API_BASE_URL}${endpoint}`
  
  const config: RequestInit = {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  }
  
  try {
    const response = await fetch(url, config)
    
    if (!response.ok) {
      throw new ApiError(
        `HTTP error! status: ${response.status}`,
        response.status
      )
    }
    
    return await response.json()
  } catch (error) {
    if (error instanceof ApiError) throw error
    
    throw new ApiError(
      `Network error: ${error.message}`,
      0,
      'NETWORK_ERROR'
    )
  }
}
```

#### Retry Utilities
```typescript
// utils/retry.ts
export interface RetryOptions {
  maxAttempts: number
  delayMs: number
  backoffMultiplier: number
  maxDelayMs: number
}

export async function retryOperation<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const config = {
    maxAttempts: 3,
    delayMs: 1000,
    backoffMultiplier: 2,
    maxDelayMs: 10000,
    ...options
  }
  
  let lastError: Error
  
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error as Error
      
      if (attempt === config.maxAttempts) {
        throw lastError
      }
      
      const delay = Math.min(
        config.delayMs * Math.pow(config.backoffMultiplier, attempt - 1),
        config.maxDelayMs
      )
      
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
  
  throw lastError!
}
```

### Local Storage Utilities

#### Safe Storage Access
```typescript
// utils/storage.ts
export function safeGetItem(key: string): string | null {
  if (typeof window === 'undefined') return null
  
  try {
    return localStorage.getItem(key)
  } catch (error) {
    console.warn(`Failed to get localStorage item "${key}":`, error)
    return null
  }
}

export function safeSetItem(key: string, value: string): boolean {
  if (typeof window === 'undefined') return false
  
  try {
    localStorage.setItem(key, value)
    return true
  } catch (error) {
    console.warn(`Failed to set localStorage item "${key}":`, error)
    return false
  }
}

export function safeRemoveItem(key: string): boolean {
  if (typeof window === 'undefined') return false
  
  try {
    localStorage.removeItem(key)
    return true
  } catch (error) {
    console.warn(`Failed to remove localStorage item "${key}":`, error)
    return false
  }
}

// Type-safe storage wrapper
export function createTypedStorage<T>(
  key: string,
  defaultValue: T,
  serialize = JSON.stringify,
  deserialize = JSON.parse
) {
  return {
    get(): T {
      const item = safeGetItem(key)
      if (item === null) return defaultValue
      
      try {
        return deserialize(item)
      } catch {
        return defaultValue
      }
    },
    
    set(value: T): boolean {
      try {
        return safeSetItem(key, serialize(value))
      } catch {
        return false
      }
    },
    
    remove(): boolean {
      return safeRemoveItem(key)
    }
  }
}
```

### Testing Utilities

#### Mock Data Generators
```typescript
// utils/test-helpers.ts
export function createMockWallet(overrides: Partial<WalletConnection> = {}): WalletConnection {
  return {
    address: '0x1234567890123456789012345678901234567890',
    chainId: 1,
    isConnected: true,
    provider: {},
    ...overrides
  }
}

export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: 'user-123',
    address: '0x1234567890123456789012345678901234567890',
    username: 'testuser',
    avatar: 'https://example.com/avatar.jpg',
    createdAt: new Date().toISOString(),
    ...overrides
  }
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    ...overrides
  }
}
```

### Performance Utilities

#### Debounce & Throttle
```typescript
// utils/performance.ts
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delayMs: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delayMs)
  }
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  intervalMs: number
): (...args: Parameters<T>) => void {
  let lastCallTime = 0
  
  return (...args: Parameters<T>) => {
    const now = Date.now()
    if (now - lastCallTime >= intervalMs) {
      lastCallTime = now
      func(...args)
    }
  }
}

export function memoize<T extends (...args: any[]) => any>(
  func: T,
  getKey?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>()
  
  return ((...args: Parameters<T>) => {
    const key = getKey ? getKey(...args) : JSON.stringify(args)
    
    if (cache.has(key)) {
      return cache.get(key)!
    }
    
    const result = func(...args)
    cache.set(key, result)
    return result
  }) as T
}
```

## TailwindCSS Utility Functions & Styling Helpers

### **TailwindCSS Class Composition Utilities**

#### 1. **Class Merging and Conditional Styling**
```typescript
// utils/cn.ts - Class composition utility
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Usage examples
const buttonClass = cn(
  'tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-transition-colors',
  variant === 'primary' && 'tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600',
  variant === 'secondary' && 'tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500',
  disabled && 'tw-opacity-50 tw-cursor-not-allowed',
  loading && 'tw-animate-pulse'
)
```

#### 2. **Responsive Class Generation**
```typescript
// utils/responsive.ts - Responsive utility helpers
export function createResponsiveClasses(
  base: string,
  breakpoints: Record<string, string>
): string {
  const classes = [base]
  
  Object.entries(breakpoints).forEach(([breakpoint, className]) => {
    if (breakpoint === 'base') return
    classes.push(`${breakpoint}:${className}`)
  })
  
  return classes.join(' ')
}

// Usage
const gridClasses = createResponsiveClasses('tw-grid-cols-1', {
  sm: 'tw-grid-cols-2',
  lg: 'tw-grid-cols-3',
  '3xl': 'tw-grid-cols-4'
})
```

#### 3. **Theme-Aware Utility Functions**
```typescript
// utils/theme.ts - Theme utility functions
export const ironScale = {
  50: '#F5F5F5',
  100: '#EFEFF1',
  200: '#ECECEE',
  300: '#CECFD4',
  400: '#93939F',
  500: '#848490',
  600: '#60606C',
  650: '#4C4C55',
  700: '#37373E',
  800: '#26272B',
  900: '#1C1C21',
  950: '#131316'
} as const

export const primaryScale = {
  200: '#84ADFF',
  300: '#84ADFF',
  400: '#528BFF',
  500: '#406AFE',
  600: '#395FE4'
} as const

export function getIronClass(shade: keyof typeof ironScale, property: 'bg' | 'text' | 'border' = 'bg') {
  return `tw-${property}-iron-${shade}`
}

export function getPrimaryClass(shade: keyof typeof primaryScale, property: 'bg' | 'text' | 'border' = 'bg') {
  return `tw-${property}-primary-${shade}`
}

// Usage
const cardBackground = getIronClass(900, 'bg') // 'tw-bg-iron-900'
const primaryText = getPrimaryClass(500, 'text') // 'tw-text-primary-500'
```

#### 4. **Animation and Transition Helpers**
```typescript
// utils/animations.ts - Animation utility functions
export const customAnimations = {
  'loading-bar': 'tw-animate-loading-bar',
  'trophy-appear': 'tw-animate-trophy-appear',
  'gradient-shift': 'tw-animate-gradient-shift',
  'fade-in': 'tw-animate-fadeIn',
  'shake': 'tw-animate-shake',
  'gallery-reveal': 'tw-animate-gallery-reveal'
} as const

export function getAnimationClass(animation: keyof typeof customAnimations): string {
  return customAnimations[animation]
}

export function createTransitionClass(
  property: string = 'all',
  duration: string = '200ms',
  timing: string = 'ease-out'
): string {
  return `tw-transition-${property} tw-duration-${duration.replace('ms', '')} tw-${timing}`
}

// Usage
const buttonTransition = createTransitionClass('colors', '200ms', 'ease-out')
// Returns: 'tw-transition-colors tw-duration-200 tw-ease-out'
```

### **Component Variant Utilities**

#### 1. **Button Variant System**
```typescript
// utils/variants/button.ts - Button variant utilities
export type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'ghost' | 'outline'
export type ButtonSize = 'sm' | 'md' | 'lg' | 'xl'

export const buttonVariants = {
  primary: 'tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600 focus:tw-ring-primary-500',
  secondary: 'tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500 focus:tw-ring-iron-500',
  danger: 'tw-bg-red-600 tw-text-white hover:tw-bg-red-700 focus:tw-ring-red-500',
  ghost: 'tw-text-iron-300 hover:tw-bg-iron-800 hover:tw-text-iron-50 focus:tw-ring-iron-700',
  outline: 'tw-border tw-border-iron-600 tw-text-iron-300 hover:tw-bg-iron-800 hover:tw-text-iron-50'
}

export const buttonSizes = {
  sm: 'tw-px-3 tw-py-1.5 tw-text-sm',
  md: 'tw-px-4 tw-py-2 tw-text-sm',
  lg: 'tw-px-6 tw-py-3 tw-text-base',
  xl: 'tw-px-8 tw-py-4 tw-text-lg'
}

export function getButtonClasses(variant: ButtonVariant, size: ButtonSize): string {
  const baseClasses = 'tw-inline-flex tw-items-center tw-justify-center tw-font-medium tw-rounded-lg tw-transition-all tw-duration-200 tw-focus:outline-none tw-focus:ring-2 tw-focus:ring-offset-2 tw-focus:ring-offset-iron-900'
  
  return cn(
    baseClasses,
    buttonVariants[variant],
    buttonSizes[size]
  )
}
```

#### 2. **Card Variant System**
```typescript
// utils/variants/card.ts - Card variant utilities
export type CardVariant = 'default' | 'elevated' | 'bordered' | 'featured' | 'compact'

export const cardVariants = {
  default: 'tw-bg-iron-900 tw-rounded-lg tw-p-6',
  elevated: 'tw-bg-iron-900 tw-rounded-lg tw-p-6 tw-shadow-lg tw-border tw-border-iron-700',
  bordered: 'tw-bg-iron-900 tw-rounded-lg tw-p-6 tw-border-2 tw-border-iron-600',
  featured: 'tw-bg-gradient-to-br tw-from-iron-900 tw-to-iron-800 tw-rounded-lg tw-p-8 tw-border-2 tw-border-primary-500 tw-shadow-xl',
  compact: 'tw-bg-iron-900 tw-rounded-lg tw-p-4 tw-border tw-border-iron-700'
}

export function getCardClasses(variant: CardVariant): string {
  return cardVariants[variant]
}
```

### **Responsive Design Utilities**

#### 1. **Breakpoint Utilities**
```typescript
// utils/responsive/breakpoints.ts - Responsive design utilities
export const breakpoints = {
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px',
  '2xl': '1536px',
  '3xl': '2048px' // Custom breakpoint
} as const

export function useBreakpoint() {
  const [currentBreakpoint, setCurrentBreakpoint] = useState<string>('sm')
  
  useEffect(() => {
    const checkBreakpoint = () => {
      const width = window.innerWidth
      
      if (width >= 2048) setCurrentBreakpoint('3xl')
      else if (width >= 1536) setCurrentBreakpoint('2xl')
      else if (width >= 1280) setCurrentBreakpoint('xl')
      else if (width >= 1024) setCurrentBreakpoint('lg')
      else if (width >= 768) setCurrentBreakpoint('md')
      else setCurrentBreakpoint('sm')
    }
    
    checkBreakpoint()
    window.addEventListener('resize', checkBreakpoint)
    
    return () => window.removeEventListener('resize', checkBreakpoint)
  }, [])
  
  return currentBreakpoint
}
```

#### 2. **Container Query Utilities**
```typescript
// utils/responsive/container-queries.ts - Container query helpers
export function createContainerClass(minWidth: string): string {
  return `tw-@container/${minWidth}`
}

export function getContainerQueryClass(breakpoint: string, classes: string): string {
  return `@${breakpoint}:${classes}`
}

// Usage
const containerClasses = [
  'tw-@container',
  getContainerQueryClass('md', 'tw-flex-row'),
  getContainerQueryClass('lg', 'tw-gap-8')
].join(' ')
```

### **Form and Input Utilities**

#### 1. **Input State Utilities**
```typescript
// utils/forms/input-states.ts - Input state styling utilities
export type InputState = 'default' | 'error' | 'success' | 'warning'

export const inputStateClasses = {
  default: {
    border: 'tw-border-iron-600 focus:tw-border-primary-500',
    ring: 'focus:tw-ring-primary-500',
    bg: 'tw-bg-iron-800'
  },
  error: {
    border: 'tw-border-red-500 focus:tw-border-red-500',
    ring: 'focus:tw-ring-red-500',
    bg: 'tw-bg-red-900/20'
  },
  success: {
    border: 'tw-border-green-500 focus:tw-border-green-500',
    ring: 'focus:tw-ring-green-500',
    bg: 'tw-bg-green-900/20'
  },
  warning: {
    border: 'tw-border-yellow-500 focus:tw-border-yellow-500',
    ring: 'focus:tw-ring-yellow-500',
    bg: 'tw-bg-yellow-900/20'
  }
}

export function getInputClasses(state: InputState = 'default'): string {
  const stateStyles = inputStateClasses[state]
  const baseClasses = 'tw-w-full tw-px-3 tw-py-2 tw-rounded-lg tw-text-iron-50 tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-offset-2 focus:tw-ring-offset-iron-900'
  
  return cn(
    baseClasses,
    stateStyles.bg,
    stateStyles.border,
    stateStyles.ring
  )
}
```

### **Mobile and Capacitor Utilities**

#### 1. **Safe Area Utilities**
```typescript
// utils/mobile/safe-area.ts - Safe area utilities
export const safeAreaClasses = {
  top: 'tw-pt-[env(safe-area-inset-top,0px)]',
  bottom: 'tw-pb-[env(safe-area-inset-bottom,0px)]',
  left: 'tw-pl-[env(safe-area-inset-left,0px)]',
  right: 'tw-pr-[env(safe-area-inset-right,0px)]'
} as const

export function getSafeAreaClasses(sides: Array<keyof typeof safeAreaClasses> = ['top', 'bottom']): string {
  return sides.map(side => safeAreaClasses[side]).join(' ')
}

export function createTouchTargetClass(minSize: string = '44px'): string {
  return `tw-min-h-[${minSize}] tw-min-w-[${minSize}] tw-touch-manipulation`
}
```

#### 2. **Performance Utilities**
```typescript
// utils/performance/gpu-acceleration.ts - GPU acceleration utilities
export const gpuAcceleratedClasses = {
  transform: 'tw-transform tw-translate3d-0',
  transition: 'tw-transition-transform',
  animation: 'tw-will-change-transform'
}

export function getGpuAcceleratedClasses(): string {
  return Object.values(gpuAcceleratedClasses).join(' ')
}
```

### **Web3-Specific Styling Utilities**

#### 1. **Wallet State Utilities**
```typescript
// utils/web3/wallet-styles.ts - Web3 wallet styling utilities
export type WalletConnectionState = 'disconnected' | 'connecting' | 'connected' | 'error'

export const walletStateStyles = {
  disconnected: {
    button: 'tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600',
    indicator: 'tw-bg-gray-400'
  },
  connecting: {
    button: 'tw-bg-yellow-500 tw-text-white tw-cursor-wait tw-animate-pulse',
    indicator: 'tw-bg-yellow-400 tw-animate-pulse'
  },
  connected: {
    button: 'tw-bg-success tw-text-white hover:tw-bg-green',
    indicator: 'tw-bg-green-400 tw-animate-pulse'
  },
  error: {
    button: 'tw-bg-red-500 tw-text-white hover:tw-bg-red-600',
    indicator: 'tw-bg-red-400'
  }
}

export function getWalletButtonClasses(state: WalletConnectionState): string {
  const baseClasses = 'tw-px-6 tw-py-3 tw-rounded-lg tw-font-semibold tw-transition-all tw-duration-200 tw-flex tw-items-center tw-gap-2'
  return cn(baseClasses, walletStateStyles[state].button)
}
```

#### 2. **Transaction Status Utilities**
```typescript
// utils/web3/transaction-styles.ts - Transaction status styling
export type TransactionStatus = 'pending' | 'confirmed' | 'failed' | 'cancelled'

export const transactionStatusStyles = {
  pending: {
    bg: 'tw-bg-yellow-400/10',
    text: 'tw-text-yellow-400',
    border: 'tw-border-yellow-400/20',
    icon: 'tw-animate-spin'
  },
  confirmed: {
    bg: 'tw-bg-green-400/10',
    text: 'tw-text-green-400',
    border: 'tw-border-green-400/20',
    icon: ''
  },
  failed: {
    bg: 'tw-bg-red-400/10',
    text: 'tw-text-red-400',
    border: 'tw-border-red-400/20',
    icon: 'tw-animate-shake'
  },
  cancelled: {
    bg: 'tw-bg-iron-400/10',
    text: 'tw-text-iron-400',
    border: 'tw-border-iron-400/20',
    icon: ''
  }
}

export function getTransactionStatusClasses(status: TransactionStatus): {
  container: string
  indicator: string
  text: string
} {
  const styles = transactionStatusStyles[status]
  
  return {
    container: cn('tw-flex tw-items-center tw-gap-2 tw-px-3 tw-py-2 tw-rounded-lg tw-border', styles.bg, styles.border),
    indicator: cn('tw-w-2 tw-h-2 tw-rounded-full', styles.text, styles.icon),
    text: cn('tw-text-sm tw-font-medium', styles.text)
  }
}
```

### **Testing Utilities for TailwindCSS**

#### 1. **Class Testing Helpers**
```typescript
// utils/testing/tailwind-helpers.ts - Testing utilities for TailwindCSS
export function hasClassPattern(element: HTMLElement, pattern: RegExp): boolean {
  return pattern.test(element.className)
}

export function hasTailwindClass(element: HTMLElement, className: string): boolean {
  return element.classList.contains(className)
}

export function extractTailwindClasses(element: HTMLElement): string[] {
  return Array.from(element.classList).filter(cls => cls.startsWith('tw-'))
}

// Usage in tests
expect(hasClassPattern(button, /tw-bg-primary-\d+/)).toBe(true)
expect(hasTailwindClass(input, 'tw-border-iron-600')).toBe(true)
expect(extractTailwindClasses(card)).toContain('tw-rounded-lg')
```

### **Development and Debugging Utilities**

#### 1. **Class Name Debugging**
```typescript
// utils/debug/class-debug.ts - Development debugging utilities
export function logAppliedClasses(element: HTMLElement, label?: string): void {
  if (process.env.NODE_ENV === 'development') {
    const tailwindClasses = extractTailwindClasses(element)
    console.log(`${label || 'Element'} Tailwind classes:`, tailwindClasses)
  }
}

export function validateRequiredClasses(element: HTMLElement, requiredClasses: string[]): boolean {
  const missing = requiredClasses.filter(cls => !element.classList.contains(cls))
  
  if (missing.length > 0 && process.env.NODE_ENV === 'development') {
    console.warn('Missing required classes:', missing)
    return false
  }
  
  return true
}
```

---

**Keep utilities pure, focused, and well-typed. Each function should have a single responsibility and predictable behavior. ALL utilities must support TailwindCSS with tw- prefix patterns.**