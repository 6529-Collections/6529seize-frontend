# Src Directory Context

## Core Philosophy: Simple, Clear Service Layer

**"Write service layer code that does one thing well. Keep business logic separate from UI concerns. Favor clear, readable functions over clever abstractions."**

## Simple Service Patterns (2025 Best Practices)

### API Service Pattern

```typescript
// ‚úÖ Good: Simple, clear API service
export class UserService {
  private baseUrl = "/api/users";

  async getUser(id: string): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }
    return response.json();
  }

  async updateUser(id: string, updates: Partial<User>): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(updates),
    });
    if (!response.ok) {
      throw new Error(`Failed to update user: ${response.statusText}`);
    }
    return response.json();
  }
}

// ‚ùå Avoid: Over-engineered service with too much abstraction
class UniversalService<T, K, V> {
  // 200 lines of generic complexity that nobody understands...
}
```

### Utility Function Pattern

```typescript
// ‚úÖ Good: Simple, focused utility functions
export function formatAddress(address: string): string {
  if (!address || address.length < 10) return address;
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
}

export function validateEthereumAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

export function parseWeiToEth(wei: bigint): string {
  return (Number(wei) / 1e18).toFixed(4);
}

// ‚ùå Avoid: Trying to be too generic
export function formatAnything<T>(input: T, config: FormatConfig<T>): string {
  // Complex generic formatting logic that's hard to understand...
}
```

### Web3 Service Patterns (Security-First, Simple)

```typescript
// ‚úÖ Good: Clear, secure wallet operations
export class WalletService {
  async connectWallet(
    provider: string
  ): Promise<{ address: string; chainId: number }> {
    // Simple validation
    if (!provider) {
      throw new Error("Provider is required");
    }

    try {
      // Simple connection logic
      const accounts = await window.ethereum.request({
        method: "eth_requestAccounts",
      });
      const chainId = await window.ethereum.request({ method: "eth_chainId" });

      return {
        address: accounts[0],
        chainId: parseInt(chainId, 16),
      };
    } catch (error) {
      throw new Error(`Wallet connection failed: ${error.message}`);
    }
  }
}

// ‚ùå Avoid: Over-complex abstraction layers for wallet operations
```

## File Organization & Utility Structure

### Current Structure

```
src/
‚îú‚îÄ‚îÄ errors/                  # Error handling utilities
‚îÇ   ‚îú‚îÄ‚îÄ authentication.ts   # Auth-specific errors
‚îÇ   ‚îú‚îÄ‚îÄ wallet-auth.ts      # Wallet authentication errors
‚îÇ   ‚îú‚îÄ‚îÄ wallet-connection.ts # Connection error handling
‚îÇ   ‚îî‚îÄ‚îÄ adapter.ts          # Adapter pattern errors
‚îú‚îÄ‚îÄ types/                  # TypeScript definitions
‚îÇ   ‚îú‚îÄ‚îÄ security.ts         # Security-related types
‚îÇ   ‚îî‚îÄ‚îÄ window.d.ts         # Window object extensions
‚îî‚îÄ‚îÄ utils/                  # Pure utility functions
    ‚îú‚îÄ‚îÄ security-logger.ts  # Secure logging utilities
    ‚îî‚îÄ‚îÄ wallet-sanitization.ts # Input sanitization
```

### File Organization Principles

#### Single Responsibility for Utilities

- **One Function Per File**: Small, focused utility functions
- **Related Functions**: Group in same file only if tightly coupled
- **Pure Functions**: No side effects, predictable outputs
- **Type Safety**: Full TypeScript coverage for all utilities

#### Error Handling Architecture

```typescript
// ‚úÖ Good: Specific error types
class WalletConnectionError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = "WalletConnectionError";
  }
}

class AuthenticationError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = "AuthenticationError";
  }
}

// ‚úÖ Good: Error factory functions
export function createWalletError(code: string, message: string) {
  return new WalletConnectionError(message, code);
}
```

### Utility Function Patterns

#### Pure Function Design

```typescript
// ‚úÖ Good: Pure utility function
export function formatCurrency(
  amount: number | bigint,
  currency: string = "USD",
  decimals: number = 2
): string {
  const numericAmount =
    typeof amount === "bigint"
      ? Number(amount) / Math.pow(10, 18) // Handle Wei conversion
      : amount;

  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals,
  }).format(numericAmount);
}

// ‚úÖ Good: Validation utility
export function isValidEthereumAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

// ‚úÖ Good: Transformation utility
export function truncateAddress(
  address: string,
  startChars: number = 6,
  endChars: number = 4
): string {
  if (!isValidEthereumAddress(address)) {
    throw new Error("Invalid Ethereum address");
  }

  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;
}
```

### Fail-Fast Utility Architecture

### **CRITICAL: Enhanced Error Handling Utilities with Fail-Fast Patterns**

Building upon existing `security-logger.ts` and `error-sanitizer.ts` foundation:

#### 1. **Ultra-Aggressive Error Class System**

```typescript
// src/utils/enhanced-error-classes.ts
// Enhanced base error class for fail-fast patterns
export abstract class SeizeError extends Error {
  abstract readonly type: string;
  abstract readonly code: string;
  abstract readonly severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

  readonly timestamp: string;
  readonly context: Record<string, unknown>;
  readonly sessionId: string;

  constructor(
    message: string,
    code: string,
    context: Record<string, unknown> = {},
    cause?: Error
  ) {
    super(message, { cause });
    this.name = this.constructor.name;
    this.code = code;
    this.timestamp = new Date().toISOString();
    this.context = sanitizeMetadata(context);
    this.sessionId = generateSecureSessionId();
  }

  /**
   * Creates secure log entry with sanitized data
   */
  toSecureLogEntry(): SecurityLogEntry {
    return {
      timestamp: this.timestamp,
      type: this.type,
      code: this.code,
      severity: this.severity,
      message: sanitizeErrorMessage(this.message),
      context: this.context,
      sessionId: this.sessionId,
      stack: this.stack ? sanitizeErrorMessage(this.stack) : undefined,
      cause: this.cause ? sanitizeErrorMessage(String(this.cause)) : undefined,
    };
  }

  /**
   * Determines if error should trigger immediate application termination
   */
  shouldTerminateApplication(): boolean {
    return this.severity === "CRITICAL";
  }

  /**
   * Determines if error allows user-initiated recovery
   */
  allowsRecovery(): boolean {
    return this.severity !== "CRITICAL" && this.type !== "SECURITY_VIOLATION";
  }
}

// Critical security errors - ALWAYS terminate
export class SecurityViolationError extends SeizeError {
  readonly type = "SECURITY_VIOLATION";
  readonly severity = "CRITICAL" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Authentication errors - HIGH priority, fail-fast
export class AuthenticationError extends SeizeError {
  readonly type = "AUTHENTICATION_ERROR";
  readonly severity = "HIGH" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Transaction errors - HIGH priority, financial implications
export class TransactionError extends SeizeError {
  readonly type = "TRANSACTION_ERROR";
  readonly severity = "HIGH" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Wallet connection errors - HIGH priority, security implications
export class WalletConnectionError extends SeizeError {
  readonly type = "WALLET_CONNECTION_ERROR";
  readonly severity = "HIGH" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Validation errors - MEDIUM priority, may allow recovery
export class ValidationError extends SeizeError {
  readonly type = "VALIDATION_ERROR";
  readonly severity = "MEDIUM" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Network errors - MEDIUM priority, may be transient
export class NetworkError extends SeizeError {
  readonly type = "NETWORK_ERROR";
  readonly severity = "MEDIUM" as const;

  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}
```

#### 2. **Enhanced Security Logging Utilities**

```typescript
// src/utils/enhanced-security-logger.ts
// Builds upon existing security-logger.ts

/**
 * Critical error logging with immediate alerts
 */
export const logCriticalError = (
  context: string,
  error: SeizeError,
  additionalContext?: Record<string, unknown>
): void => {
  const logEntry = {
    ...error.toSecureLogEntry(),
    context,
    additionalContext: additionalContext
      ? sanitizeMetadata(additionalContext)
      : undefined,
    actionRequired: getRequiredAction(error),
    shouldAlert: error.severity === "CRITICAL",
    allowsRecovery: error.allowsRecovery(),
  };

  // Immediate security alerts for critical errors
  if (error instanceof SecurityViolationError) {
    sendSecurityAlert({
      ...logEntry,
      alertLevel: "IMMEDIATE",
      threatLevel: "HIGH",
      requiresInvestigation: true,
    });
  }

  // Enhanced structured logging
  if (publicEnv.NODE_ENV === "production") {
    console.error(
      `[SEIZE_CRITICAL][${error.severity}][${error.code}]`,
      logEntry
    );

    // Send to monitoring service with structured format
    sendToMonitoringService({
      ...logEntry,
      tags: {
        application: "6529seize",
        environment: "production",
        errorType: error.type,
        severity: error.severity,
      },
    });
  } else {
    // Enhanced development logging
    console.group(`üö® ${error.severity} ERROR: ${error.type}`);
    console.error("Error Code:", error.code);
    console.error("Context:", context);
    console.error("Message:", error.message);
    console.error(
      "Sanitized Stack:",
      error.stack ? sanitizeErrorMessage(error.stack) : "No stack"
    );
    console.error("Allows Recovery:", error.allowsRecovery());
    console.error("Should Terminate:", error.shouldTerminateApplication());
    if (additionalContext) {
      console.error("Additional Context:", sanitizeMetadata(additionalContext));
    }
    console.groupEnd();
  }
};

/**
 * Determines required action based on error type and severity
 */
function getRequiredAction(error: SeizeError): string {
  switch (error.type) {
    case "SECURITY_VIOLATION":
      return "IMMEDIATE_SECURITY_INVESTIGATION_REQUIRED";
    case "AUTHENTICATION_ERROR":
      return "USER_REAUTHENTICATION_REQUIRED";
    case "TRANSACTION_ERROR":
      return "TRANSACTION_REVIEW_AND_RETRY";
    case "WALLET_CONNECTION_ERROR":
      return "WALLET_RECONNECTION_REQUIRED";
    case "VALIDATION_ERROR":
      return "USER_INPUT_CORRECTION_REQUIRED";
    case "NETWORK_ERROR":
      return "NETWORK_CONNECTIVITY_CHECK_REQUIRED";
    default:
      return "STANDARD_ERROR_HANDLING_REQUIRED";
  }
}

/**
 * Generates secure session ID for error correlation
 */
function generateSecureSessionId(): string {
  const timestamp = Date.now().toString(36);
  const randomBytes = new Uint8Array(8);
  crypto.getRandomValues(randomBytes);
  const randomPart = Array.from(randomBytes, (byte) =>
    byte.toString(16).padStart(2, "0")
  ).join("");
  return `${timestamp}_${randomPart}`;
}
```

#### 3. **Fail-Fast Validation Utilities**

```typescript
// src/utils/fail-fast-validation.ts
// Ultra-aggressive validation with immediate termination

/**
 * Validates Ethereum address with fail-fast security checks
 */
export function validateEthereumAddressOrThrow(
  address: unknown,
  context: string = "unknown_context"
): string {
  if (!address || typeof address !== "string") {
    throw new SecurityViolationError(
      "Address validation failed: null or invalid type",
      "VALIDATION_ADDRESS_NULL_OR_INVALID_TYPE",
      {
        context,
        receivedType: typeof address,
        addressLength: address?.toString?.()?.length || 0,
      }
    );
  }

  if (!address.startsWith("0x")) {
    throw new SecurityViolationError(
      "Address validation failed: missing 0x prefix",
      "VALIDATION_ADDRESS_MISSING_PREFIX",
      { context, addressLength: address.length }
    );
  }

  if (address.length !== 42) {
    throw new SecurityViolationError(
      "Address validation failed: invalid length",
      "VALIDATION_ADDRESS_INVALID_LENGTH",
      { context, addressLength: address.length, expected: 42 }
    );
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new SecurityViolationError(
      "Address validation failed: invalid hex characters",
      "VALIDATION_ADDRESS_INVALID_HEX",
      { context }
    );
  }

  return address.toLowerCase();
}

/**
 * Validates JWT token format with fail-fast security checks
 */
export function validateJWTFormatOrThrow(
  token: unknown,
  context: string = "unknown_context"
): string {
  if (!token || typeof token !== "string") {
    throw new AuthenticationError(
      "JWT validation failed: null or invalid type",
      "AUTH_JWT_NULL_OR_INVALID_TYPE",
      { context, receivedType: typeof token }
    );
  }

  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new AuthenticationError(
      "JWT validation failed: invalid structure",
      "AUTH_JWT_INVALID_STRUCTURE",
      { context, partCount: parts.length, expected: 3 }
    );
  }

  // Validate each part is base64url
  for (let i = 0; i < parts.length; i++) {
    if (!isValidBase64Url(parts[i])) {
      throw new AuthenticationError(
        `JWT validation failed: invalid base64url in part ${i + 1}`,
        "AUTH_JWT_INVALID_BASE64URL",
        { context, partIndex: i }
      );
    }
  }

  return token;
}

/**
 * Validates transaction parameters with fail-fast security checks
 */
export function validateTransactionParamsOrThrow(
  params: unknown,
  context: string = "unknown_context"
): TransactionParams {
  if (!params || typeof params !== "object") {
    throw new TransactionError(
      "Transaction validation failed: null or invalid type",
      "TRANSACTION_PARAMS_NULL_OR_INVALID_TYPE",
      { context, receivedType: typeof params }
    );
  }

  const txParams = params as Record<string, unknown>;

  // Validate recipient address
  if (!txParams.to) {
    throw new TransactionError(
      "Transaction validation failed: missing recipient address",
      "TRANSACTION_MISSING_RECIPIENT",
      { context }
    );
  }

  const validatedRecipient = validateEthereumAddressOrThrow(
    txParams.to,
    `${context}_recipient`
  );

  // Validate amount
  if (!txParams.value || typeof txParams.value !== "string") {
    throw new TransactionError(
      "Transaction validation failed: invalid amount",
      "TRANSACTION_INVALID_AMOUNT",
      { context, receivedType: typeof txParams.value }
    );
  }

  const numericValue = parseFloat(txParams.value);
  if (isNaN(numericValue) || numericValue <= 0) {
    throw new TransactionError(
      "Transaction validation failed: amount is not a positive number",
      "TRANSACTION_AMOUNT_NOT_POSITIVE",
      { context, receivedValue: txParams.value, parsedValue: numericValue }
    );
  }

  // Security check: prevent extremely large transactions
  if (numericValue > MAX_TRANSACTION_AMOUNT) {
    throw new SecurityViolationError(
      "Transaction validation failed: amount exceeds security threshold",
      "TRANSACTION_AMOUNT_SECURITY_VIOLATION",
      {
        context,
        amount: numericValue,
        threshold: MAX_TRANSACTION_AMOUNT,
        ratio: numericValue / MAX_TRANSACTION_AMOUNT,
      }
    );
  }

  return {
    to: validatedRecipient,
    value: txParams.value,
    gasLimit: txParams.gasLimit as string,
    gasPrice: txParams.gasPrice as string,
  };
}

// Security constants
const MAX_TRANSACTION_AMOUNT = 1000; // 1000 ETH - adjust based on requirements
const isValidBase64Url = (str: string): boolean => /^[A-Za-z0-9_-]+$/.test(str);
```

#### 4. **Enhanced Result Pattern Utilities**

```typescript
// src/utils/fail-fast-result.ts
// TypeScript Result pattern for structured error handling

export type Result<T, E extends SeizeError> =
  | { ok: true; value: T }
  | { ok: false; error: E };

/**
 * Creates successful result
 */
export const Ok = <T>(value: T): Result<T, never> => ({ ok: true, value });

/**
 * Creates error result with structured error
 */
export const Err = <E extends SeizeError>(error: E): Result<never, E> => ({
  ok: false,
  error,
});

/**
 * Wraps operation in try-catch and returns Result
 */
export const tryCatch = <T, E extends SeizeError>(
  operation: () => T,
  errorHandler: (error: unknown) => E
): Result<T, E> => {
  try {
    return Ok(operation());
  } catch (error) {
    return Err(errorHandler(error));
  }
};

/**
 * Wraps async operation in try-catch and returns Result
 */
export const asyncTryCatch = async <T, E extends SeizeError>(
  operation: () => Promise<T>,
  errorHandler: (error: unknown) => E
): Promise<Result<T, E>> => {
  try {
    const value = await operation();
    return Ok(value);
  } catch (error) {
    return Err(errorHandler(error));
  }
};

/**
 * Fail-fast pattern: unwrap result or throw error
 */
export const unwrapOrThrow = <T, E extends SeizeError>(
  result: Result<T, E>
): T => {
  if (!result.ok) {
    // Log error before throwing
    logCriticalError("result_unwrap_failure", result.error);
    throw result.error;
  }
  return result.value;
};

/**
 * Chain operations with fail-fast error propagation
 */
export const chain = <T, U, E extends SeizeError>(
  result: Result<T, E>,
  operation: (value: T) => Result<U, E>
): Result<U, E> => {
  if (!result.ok) {
    return result;
  }
  return operation(result.value);
};

/**
 * Map over successful result or propagate error
 */
export const map = <T, U, E extends SeizeError>(
  result: Result<T, E>,
  mapper: (value: T) => U
): Result<U, E> => {
  if (!result.ok) {
    return result;
  }
  return Ok(mapper(result.value));
};
```

#### 5. **Fail-Fast API Utilities**

```typescript
// src/utils/fail-fast-api.ts
// Aggressive API error handling with immediate failure

/**
 * Enhanced API request wrapper with fail-fast patterns
 */
export async function secureApiRequest<T>(
  endpoint: string,
  options: RequestInit = {},
  context: string = "unknown_api_request"
): Promise<Result<T, NetworkError | AuthenticationError | ValidationError>> {
  const requestId = generateSecureSessionId();

  try {
    // Pre-flight validation
    if (!endpoint || typeof endpoint !== "string") {
      throw new ValidationError(
        "API request failed: invalid endpoint",
        "API_INVALID_ENDPOINT",
        { context, endpoint, requestId }
      );
    }

    const url = `${publicEnv.NEXT_PUBLIC_API_BASE_URL}${endpoint}`;

    // Validate URL format
    try {
      new URL(url);
    } catch {
      throw new ValidationError(
        "API request failed: malformed URL",
        "API_MALFORMED_URL",
        { context, url: sanitizeErrorMessage(url), requestId }
      );
    }

    const requestConfig: RequestInit = {
      ...options,
      headers: {
        "Content-Type": "application/json",
        "X-Request-ID": requestId,
        ...options.headers,
      },
    };

    logSecurityEvent(SecurityEventType.API_REQUEST_INITIATED, {
      context,
      endpoint: sanitizeErrorMessage(endpoint),
      method: requestConfig.method || "GET",
      requestId,
    });

    const response = await fetch(url, requestConfig);

    // Aggressive response validation
    if (!response.ok) {
      const errorBody = await response
        .text()
        .catch(() => "Unable to read error response");

      switch (response.status) {
        case 401:
          throw new AuthenticationError(
            "API request failed: unauthorized",
            "API_UNAUTHORIZED",
            {
              context,
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
              errorBody: sanitizeErrorMessage(errorBody),
            }
          );

        case 403:
          throw new AuthenticationError(
            "API request failed: forbidden",
            "API_FORBIDDEN",
            {
              context,
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
            }
          );

        case 400:
          throw new ValidationError(
            "API request failed: bad request",
            "API_BAD_REQUEST",
            {
              context,
              status: response.status,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
              errorBody: sanitizeErrorMessage(errorBody),
            }
          );

        default:
          throw new NetworkError(
            `API request failed with status ${response.status}`,
            "API_REQUEST_FAILED",
            {
              context,
              status: response.status,
              statusText: response.statusText,
              endpoint: sanitizeErrorMessage(endpoint),
              requestId,
            }
          );
      }
    }

    // Parse and validate response
    let data: T;
    try {
      data = await response.json();
    } catch (parseError) {
      throw new NetworkError(
        "API request failed: invalid JSON response",
        "API_INVALID_JSON_RESPONSE",
        {
          context,
          endpoint: sanitizeErrorMessage(endpoint),
          requestId,
          parseError: String(parseError),
        }
      );
    }

    logSecurityEvent(SecurityEventType.API_REQUEST_COMPLETED, {
      context,
      endpoint: sanitizeErrorMessage(endpoint),
      status: response.status,
      requestId,
    });

    return Ok(data);
  } catch (error) {
    if (error instanceof SeizeError) {
      logCriticalError("api_request_error", error, { context, requestId });
      return Err(error);
    }

    // Wrap unexpected errors
    const networkError = new NetworkError(
      "API request failed: unexpected error",
      "API_UNEXPECTED_ERROR",
      {
        context,
        requestId,
        originalError: String(error),
      }
    );

    logCriticalError("api_unexpected_error", networkError, {
      context,
      requestId,
    });
    return Err(networkError);
  }
}
```

### Legacy Error Handling Utilities (Being Enhanced)

```typescript
// ‚ùå BEING ENHANCED: Basic error handling (from existing security-logger.ts)
export function sanitizeErrorMessage(message: string): string {
  // Remove sensitive patterns
  return message
    .replace(/0x[a-fA-F0-9]+/g, "[ADDRESS_REDACTED]")
    .replace(
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
      "[EMAIL_REDACTED]"
    )
    .replace(/\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b/g, "[CARD_REDACTED]");
}

// ‚ùå BEING ENHANCED: Basic error logging (from existing security-logger.ts)
export function logError(
  context: string,
  error: Error,
  metadata?: Record<string, unknown>
): void {
  const logEntry = {
    timestamp: new Date().toISOString(),
    context,
    name: error.name,
    message: sanitizeErrorMessage(error.message),
    stack: error.stack ? sanitizeErrorMessage(error.stack) : undefined,
    metadata: metadata ? sanitizeMetadata(metadata) : undefined,
  };

  // Log to appropriate service based on environment
  if (publicEnv.NODE_ENV === "development") {
    console.error("[ERROR]", logEntry);
  } else {
    // Send to monitoring service
    sendToMonitoringService(logEntry);
  }
}
```

### Type Organization Strategy

## **CRITICAL: All Interface Properties Must Be Readonly**

**All interface properties in src/ MUST use readonly modifiers to prevent mutation and improve type safety.**

#### Domain-Specific Types

```typescript
// types/wallet.ts
export interface WalletConnection {
  readonly address: string;
  readonly chainId: number;
  readonly isConnected: boolean;
  readonly provider: unknown;
}

export interface WalletError {
  readonly code: string;
  readonly message: string;
  readonly details?: Record<string, unknown>;
}

export type WalletState =
  | { readonly status: "disconnected" }
  | { readonly status: "connecting" }
  | { readonly status: "connected"; readonly connection: WalletConnection }
  | { readonly status: "error"; readonly error: WalletError };
```

#### Shared Base Types

```typescript
// types/common.ts
export interface ApiResponse<T> {
  readonly data: T;
  readonly success: boolean;
  readonly message?: string;
  readonly error?: string;
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  readonly pagination: {
    readonly page: number;
    readonly limit: number;
    readonly total: number;
    readonly hasMore: boolean;
  };
}

export type AsyncState<T> =
  | { readonly status: "idle" }
  | { readonly status: "loading" }
  | { readonly status: "success"; readonly data: T }
  | { readonly status: "error"; readonly error: Error };
```

#### Component Prop Types

```typescript
// types/components.ts
export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
  testId?: string;
}

export interface ButtonProps extends BaseComponentProps {
  variant?: "primary" | "secondary" | "danger";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

export interface ModalProps extends BaseComponentProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  size?: "small" | "medium" | "large" | "fullscreen";
}
```

### Security Utilities

#### Input Sanitization

```typescript
// utils/sanitization.ts
export function sanitizeUserInput(input: string): string {
  return input
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
    .replace(/javascript:/gi, "")
    .replace(/on\w+\s*=/gi, "");
}

export function sanitizeHtml(html: string): string {
  // Use DOMPurify or similar library in production
  return html.replace(
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    ""
  );
}

export function validateAndSanitizeAddress(address: string): string {
  const sanitized = address.trim().toLowerCase();

  if (!isValidEthereumAddress(sanitized)) {
    throw new Error("Invalid Ethereum address format");
  }

  return sanitized;
}
```

#### Crypto Utilities

```typescript
// utils/crypto.ts
export function generateSecureNonce(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join(
    ""
  );
}

export function hashMessage(message: string): string {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);

  return crypto.subtle.digest("SHA-256", data).then((hashBuffer) => {
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  });
}

export function isSecureContext(): boolean {
  return typeof window !== "undefined" && window.isSecureContext;
}
```

### Data Transformation Utilities

#### Web3 Utilities

```typescript
// utils/web3.ts
export function weiToEth(wei: bigint): number {
  return Number(wei) / Math.pow(10, 18);
}

export function ethToWei(eth: number): bigint {
  return BigInt(Math.floor(eth * Math.pow(10, 18)));
}

export function formatTokenAmount(
  amount: bigint,
  decimals: number = 18,
  displayDecimals: number = 4
): string {
  const divisor = BigInt(Math.pow(10, decimals));
  const quotient = amount / divisor;
  const remainder = amount % divisor;

  const decimal = Number(remainder) / Math.pow(10, decimals);
  const total = Number(quotient) + decimal;

  return total.toFixed(displayDecimals);
}

export function shortenTransactionHash(hash: string): string {
  return `${hash.slice(0, 6)}...${hash.slice(-4)}`;
}
```

#### Date & Time Utilities

```typescript
// utils/time.ts
export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const target = new Date(date);
  const diffMs = now.getTime() - target.getTime();

  const units = [
    { label: "year", ms: 365 * 24 * 60 * 60 * 1000 },
    { label: "month", ms: 30 * 24 * 60 * 60 * 1000 },
    { label: "day", ms: 24 * 60 * 60 * 1000 },
    { label: "hour", ms: 60 * 60 * 1000 },
    { label: "minute", ms: 60 * 1000 },
    { label: "second", ms: 1000 },
  ];

  for (const unit of units) {
    const value = Math.floor(diffMs / unit.ms);
    if (value > 0) {
      return `${value} ${unit.label}${value > 1 ? "s" : ""} ago`;
    }
  }

  return "just now";
}

export function isExpired(expiryDate: Date | string): boolean {
  return new Date(expiryDate) < new Date();
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}
```

### API Integration Utilities

#### HTTP Client Utilities

```typescript
// utils/api.ts
export interface ApiConfig {
  baseUrl: string;
  timeout: number;
  headers: Record<string, string>;
}

export class ApiError extends Error {
  constructor(message: string, public status: number, public code?: string) {
    super(message);
    this.name = "ApiError";
  }
}

export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${publicEnv.NEXT_PUBLIC_API_BASE_URL}${endpoint}`;

  const config: RequestInit = {
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  };

  try {
    const response = await fetch(url, config);

    if (!response.ok) {
      throw new ApiError(
        `HTTP error! status: ${response.status}`,
        response.status
      );
    }

    return await response.json();
  } catch (error) {
    if (error instanceof ApiError) throw error;

    throw new ApiError(`Network error: ${error.message}`, 0, "NETWORK_ERROR");
  }
}
```

#### Retry Utilities

```typescript
// utils/retry.ts
export interface RetryOptions {
  maxAttempts: number;
  delayMs: number;
  backoffMultiplier: number;
  maxDelayMs: number;
}

export async function retryOperation<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const config = {
    maxAttempts: 3,
    delayMs: 1000,
    backoffMultiplier: 2,
    maxDelayMs: 10000,
    ...options,
  };

  let lastError: Error;

  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;

      if (attempt === config.maxAttempts) {
        throw lastError;
      }

      const delay = Math.min(
        config.delayMs * Math.pow(config.backoffMultiplier, attempt - 1),
        config.maxDelayMs
      );

      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}
```

### Local Storage Utilities

#### Safe Storage Access

```typescript
// utils/storage.ts
export function safeGetItem(key: string): string | null {
  if (typeof window === "undefined") return null;

  try {
    return localStorage.getItem(key);
  } catch (error) {
    console.warn(`Failed to get localStorage item "${key}":`, error);
    return null;
  }
}

export function safeSetItem(key: string, value: string): boolean {
  if (typeof window === "undefined") return false;

  try {
    localStorage.setItem(key, value);
    return true;
  } catch (error) {
    console.warn(`Failed to set localStorage item "${key}":`, error);
    return false;
  }
}

export function safeRemoveItem(key: string): boolean {
  if (typeof window === "undefined") return false;

  try {
    localStorage.removeItem(key);
    return true;
  } catch (error) {
    console.warn(`Failed to remove localStorage item "${key}":`, error);
    return false;
  }
}

// Type-safe storage wrapper
export function createTypedStorage<T>(
  key: string,
  defaultValue: T,
  serialize = JSON.stringify,
  deserialize = JSON.parse
) {
  return {
    get(): T {
      const item = safeGetItem(key);
      if (item === null) return defaultValue;

      try {
        return deserialize(item);
      } catch {
        return defaultValue;
      }
    },

    set(value: T): boolean {
      try {
        return safeSetItem(key, serialize(value));
      } catch {
        return false;
      }
    },

    remove(): boolean {
      return safeRemoveItem(key);
    },
  };
}
```

### Testing Utilities

#### Mock Data Generators

```typescript
// utils/test-helpers.ts
export function createMockWallet(
  overrides: Partial<WalletConnection> = {}
): WalletConnection {
  return {
    address: "0x1234567890123456789012345678901234567890",
    chainId: 1,
    isConnected: true,
    provider: {},
    ...overrides,
  };
}

export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: "user-123",
    address: "0x1234567890123456789012345678901234567890",
    username: "testuser",
    avatar: "https://example.com/avatar.jpg",
    createdAt: new Date().toISOString(),
    ...overrides,
  };
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    ...overrides,
  };
}
```

### Performance Utilities

#### Debounce & Throttle

```typescript
// utils/performance.ts
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delayMs: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout;

  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delayMs);
  };
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  intervalMs: number
): (...args: Parameters<T>) => void {
  let lastCallTime = 0;

  return (...args: Parameters<T>) => {
    const now = Date.now();
    if (now - lastCallTime >= intervalMs) {
      lastCallTime = now;
      func(...args);
    }
  };
}

export function memoize<T extends (...args: any[]) => any>(
  func: T,
  getKey?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>();

  return ((...args: Parameters<T>) => {
    const key = getKey ? getKey(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key)!;
    }

    const result = func(...args);
    cache.set(key, result);
    return result;
  }) as T;
}
```

## TailwindCSS Utility Functions & Styling Helpers

### **TailwindCSS Class Composition Utilities**

#### 1. **Class Merging and Conditional Styling**

```typescript
// utils/cn.ts - Class composition utility
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Usage examples
const buttonClass = cn(
  "tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-transition-colors",
  variant === "primary" &&
    "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600",
  variant === "secondary" &&
    "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500",
  disabled && "tw-opacity-50 tw-cursor-not-allowed",
  loading && "tw-animate-pulse"
);
```

#### 2. **Responsive Class Generation**

```typescript
// utils/responsive.ts - Responsive utility helpers
export function createResponsiveClasses(
  base: string,
  breakpoints: Record<string, string>
): string {
  const classes = [base];

  Object.entries(breakpoints).forEach(([breakpoint, className]) => {
    if (breakpoint === "base") return;
    classes.push(`${breakpoint}:${className}`);
  });

  return classes.join(" ");
}

// Usage
const gridClasses = createResponsiveClasses("tw-grid-cols-1", {
  sm: "tw-grid-cols-2",
  lg: "tw-grid-cols-3",
  "3xl": "tw-grid-cols-4",
});
```

#### 3. **Theme-Aware Utility Functions**

```typescript
// utils/theme.ts - Theme utility functions
export const ironScale = {
  50: "#F5F5F5",
  100: "#EFEFF1",
  200: "#ECECEE",
  300: "#CECFD4",
  400: "#93939F",
  500: "#848490",
  600: "#60606C",
  650: "#4C4C55",
  700: "#37373E",
  800: "#26272B",
  900: "#1C1C21",
  950: "#131316",
} as const;

export const primaryScale = {
  200: "#84ADFF",
  300: "#84ADFF",
  400: "#528BFF",
  500: "#406AFE",
  600: "#395FE4",
} as const;

export function getIronClass(
  shade: keyof typeof ironScale,
  property: "bg" | "text" | "border" = "bg"
) {
  return `tw-${property}-iron-${shade}`;
}

export function getPrimaryClass(
  shade: keyof typeof primaryScale,
  property: "bg" | "text" | "border" = "bg"
) {
  return `tw-${property}-primary-${shade}`;
}

// Usage
const cardBackground = getIronClass(900, "bg"); // 'tw-bg-iron-900'
const primaryText = getPrimaryClass(500, "text"); // 'tw-text-primary-500'
```

#### 4. **Animation and Transition Helpers**

```typescript
// utils/animations.ts - Animation utility functions
export const customAnimations = {
  "loading-bar": "tw-animate-loading-bar",
  "trophy-appear": "tw-animate-trophy-appear",
  "gradient-shift": "tw-animate-gradient-shift",
  "fade-in": "tw-animate-fadeIn",
  shake: "tw-animate-shake",
  "gallery-reveal": "tw-animate-gallery-reveal",
} as const;

export function getAnimationClass(
  animation: keyof typeof customAnimations
): string {
  return customAnimations[animation];
}

export function createTransitionClass(
  property: string = "all",
  duration: string = "200ms",
  timing: string = "ease-out"
): string {
  return `tw-transition-${property} tw-duration-${duration.replace(
    "ms",
    ""
  )} tw-${timing}`;
}

// Usage
const buttonTransition = createTransitionClass("colors", "200ms", "ease-out");
// Returns: 'tw-transition-colors tw-duration-200 tw-ease-out'
```

### **Component Variant Utilities**

#### 1. **Button Variant System**

```typescript
// utils/variants/button.ts - Button variant utilities
export type ButtonVariant =
  | "primary"
  | "secondary"
  | "danger"
  | "ghost"
  | "outline";
export type ButtonSize = "sm" | "md" | "lg" | "xl";

export const buttonVariants = {
  primary:
    "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600 focus:tw-ring-primary-500",
  secondary:
    "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500 focus:tw-ring-iron-500",
  danger:
    "tw-bg-red-600 tw-text-white hover:tw-bg-red-700 focus:tw-ring-red-500",
  ghost:
    "tw-text-iron-300 hover:tw-bg-iron-800 hover:tw-text-iron-50 focus:tw-ring-iron-700",
  outline:
    "tw-border tw-border-iron-600 tw-text-iron-300 hover:tw-bg-iron-800 hover:tw-text-iron-50",
};

export const buttonSizes = {
  sm: "tw-px-3 tw-py-1.5 tw-text-sm",
  md: "tw-px-4 tw-py-2 tw-text-sm",
  lg: "tw-px-6 tw-py-3 tw-text-base",
  xl: "tw-px-8 tw-py-4 tw-text-lg",
};

export function getButtonClasses(
  variant: ButtonVariant,
  size: ButtonSize
): string {
  const baseClasses =
    "tw-inline-flex tw-items-center tw-justify-center tw-font-medium tw-rounded-lg tw-transition-all tw-duration-200 tw-focus:outline-none tw-focus:ring-2 tw-focus:ring-offset-2 tw-focus:ring-offset-iron-900";

  return cn(baseClasses, buttonVariants[variant], buttonSizes[size]);
}
```

#### 2. **Card Variant System**

```typescript
// utils/variants/card.ts - Card variant utilities
export type CardVariant =
  | "default"
  | "elevated"
  | "bordered"
  | "featured"
  | "compact";

export const cardVariants = {
  default: "tw-bg-iron-900 tw-rounded-lg tw-p-6",
  elevated:
    "tw-bg-iron-900 tw-rounded-lg tw-p-6 tw-shadow-lg tw-border tw-border-iron-700",
  bordered:
    "tw-bg-iron-900 tw-rounded-lg tw-p-6 tw-border-2 tw-border-iron-600",
  featured:
    "tw-bg-gradient-to-br tw-from-iron-900 tw-to-iron-800 tw-rounded-lg tw-p-8 tw-border-2 tw-border-primary-500 tw-shadow-xl",
  compact: "tw-bg-iron-900 tw-rounded-lg tw-p-4 tw-border tw-border-iron-700",
};

export function getCardClasses(variant: CardVariant): string {
  return cardVariants[variant];
}
```

### **Responsive Design Utilities**

#### 1. **Breakpoint Utilities**

```typescript
// utils/responsive/breakpoints.ts - Responsive design utilities
export const breakpoints = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px",
  "3xl": "2048px", // Custom breakpoint
} as const;

export function useBreakpoint() {
  const [currentBreakpoint, setCurrentBreakpoint] = useState<string>("sm");

  useEffect(() => {
    const checkBreakpoint = () => {
      const width = window.innerWidth;

      if (width >= 2048) setCurrentBreakpoint("3xl");
      else if (width >= 1536) setCurrentBreakpoint("2xl");
      else if (width >= 1280) setCurrentBreakpoint("xl");
      else if (width >= 1024) setCurrentBreakpoint("lg");
      else if (width >= 768) setCurrentBreakpoint("md");
      else setCurrentBreakpoint("sm");
    };

    checkBreakpoint();
    window.addEventListener("resize", checkBreakpoint);

    return () => window.removeEventListener("resize", checkBreakpoint);
  }, []);

  return currentBreakpoint;
}
```

#### 2. **Container Query Utilities**

```typescript
// utils/responsive/container-queries.ts - Container query helpers
export function createContainerClass(minWidth: string): string {
  return `tw-@container/${minWidth}`;
}

export function getContainerQueryClass(
  breakpoint: string,
  classes: string
): string {
  return `@${breakpoint}:${classes}`;
}

// Usage
const containerClasses = [
  "tw-@container",
  getContainerQueryClass("md", "tw-flex-row"),
  getContainerQueryClass("lg", "tw-gap-8"),
].join(" ");
```

### **Form and Input Utilities**

#### 1. **Input State Utilities**

```typescript
// utils/forms/input-states.ts - Input state styling utilities
export type InputState = "default" | "error" | "success" | "warning";

export const inputStateClasses = {
  default: {
    border: "tw-border-iron-600 focus:tw-border-primary-500",
    ring: "focus:tw-ring-primary-500",
    bg: "tw-bg-iron-800",
  },
  error: {
    border: "tw-border-red-500 focus:tw-border-red-500",
    ring: "focus:tw-ring-red-500",
    bg: "tw-bg-red-900/20",
  },
  success: {
    border: "tw-border-green-500 focus:tw-border-green-500",
    ring: "focus:tw-ring-green-500",
    bg: "tw-bg-green-900/20",
  },
  warning: {
    border: "tw-border-yellow-500 focus:tw-border-yellow-500",
    ring: "focus:tw-ring-yellow-500",
    bg: "tw-bg-yellow-900/20",
  },
};

export function getInputClasses(state: InputState = "default"): string {
  const stateStyles = inputStateClasses[state];
  const baseClasses =
    "tw-w-full tw-px-3 tw-py-2 tw-rounded-lg tw-text-iron-50 tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-offset-2 focus:tw-ring-offset-iron-900";

  return cn(baseClasses, stateStyles.bg, stateStyles.border, stateStyles.ring);
}
```

### **Mobile and Capacitor Utilities**

#### 1. **Safe Area Utilities**

```typescript
// utils/mobile/safe-area.ts - Safe area utilities
export const safeAreaClasses = {
  top: "tw-pt-[env(safe-area-inset-top,0px)]",
  bottom: "tw-pb-[env(safe-area-inset-bottom,0px)]",
  left: "tw-pl-[env(safe-area-inset-left,0px)]",
  right: "tw-pr-[env(safe-area-inset-right,0px)]",
} as const;

export function getSafeAreaClasses(
  sides: Array<keyof typeof safeAreaClasses> = ["top", "bottom"]
): string {
  return sides.map((side) => safeAreaClasses[side]).join(" ");
}

export function createTouchTargetClass(minSize: string = "44px"): string {
  return `tw-min-h-[${minSize}] tw-min-w-[${minSize}] tw-touch-manipulation`;
}
```

#### 2. **Performance Utilities**

```typescript
// utils/performance/gpu-acceleration.ts - GPU acceleration utilities
export const gpuAcceleratedClasses = {
  transform: "tw-transform tw-translate3d-0",
  transition: "tw-transition-transform",
  animation: "tw-will-change-transform",
};

export function getGpuAcceleratedClasses(): string {
  return Object.values(gpuAcceleratedClasses).join(" ");
}
```

### **Web3-Specific Styling Utilities**

#### 1. **Wallet State Utilities**

```typescript
// utils/web3/wallet-styles.ts - Web3 wallet styling utilities
export type WalletConnectionState =
  | "disconnected"
  | "connecting"
  | "connected"
  | "error";

export const walletStateStyles = {
  disconnected: {
    button: "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600",
    indicator: "tw-bg-gray-400",
  },
  connecting: {
    button: "tw-bg-yellow-500 tw-text-white tw-cursor-wait tw-animate-pulse",
    indicator: "tw-bg-yellow-400 tw-animate-pulse",
  },
  connected: {
    button: "tw-bg-success tw-text-white hover:tw-bg-green",
    indicator: "tw-bg-green-400 tw-animate-pulse",
  },
  error: {
    button: "tw-bg-red-500 tw-text-white hover:tw-bg-red-600",
    indicator: "tw-bg-red-400",
  },
};

export function getWalletButtonClasses(state: WalletConnectionState): string {
  const baseClasses =
    "tw-px-6 tw-py-3 tw-rounded-lg tw-font-semibold tw-transition-all tw-duration-200 tw-flex tw-items-center tw-gap-2";
  return cn(baseClasses, walletStateStyles[state].button);
}
```

#### 2. **Transaction Status Utilities**

```typescript
// utils/web3/transaction-styles.ts - Transaction status styling
export type TransactionStatus =
  | "pending"
  | "confirmed"
  | "failed"
  | "cancelled";

export const transactionStatusStyles = {
  pending: {
    bg: "tw-bg-yellow-400/10",
    text: "tw-text-yellow-400",
    border: "tw-border-yellow-400/20",
    icon: "tw-animate-spin",
  },
  confirmed: {
    bg: "tw-bg-green-400/10",
    text: "tw-text-green-400",
    border: "tw-border-green-400/20",
    icon: "",
  },
  failed: {
    bg: "tw-bg-red-400/10",
    text: "tw-text-red-400",
    border: "tw-border-red-400/20",
    icon: "tw-animate-shake",
  },
  cancelled: {
    bg: "tw-bg-iron-400/10",
    text: "tw-text-iron-400",
    border: "tw-border-iron-400/20",
    icon: "",
  },
};

export function getTransactionStatusClasses(status: TransactionStatus): {
  container: string;
  indicator: string;
  text: string;
} {
  const styles = transactionStatusStyles[status];

  return {
    container: cn(
      "tw-flex tw-items-center tw-gap-2 tw-px-3 tw-py-2 tw-rounded-lg tw-border",
      styles.bg,
      styles.border
    ),
    indicator: cn("tw-w-2 tw-h-2 tw-rounded-full", styles.text, styles.icon),
    text: cn("tw-text-sm tw-font-medium", styles.text),
  };
}
```

### **Testing Utilities for TailwindCSS**

#### 1. **Class Testing Helpers**

```typescript
// utils/testing/tailwind-helpers.ts - Testing utilities for TailwindCSS
export function hasClassPattern(
  element: HTMLElement,
  pattern: RegExp
): boolean {
  return pattern.test(element.className);
}

export function hasTailwindClass(
  element: HTMLElement,
  className: string
): boolean {
  return element.classList.contains(className);
}

export function extractTailwindClasses(element: HTMLElement): string[] {
  return Array.from(element.classList).filter((cls) => cls.startsWith("tw-"));
}

// Usage in tests
expect(hasClassPattern(button, /tw-bg-primary-\d+/)).toBe(true);
expect(hasTailwindClass(input, "tw-border-iron-600")).toBe(true);
expect(extractTailwindClasses(card)).toContain("tw-rounded-lg");
```

### **Development and Debugging Utilities**

#### 1. **Class Name Debugging**

```typescript
// utils/debug/class-debug.ts - Development debugging utilities
export function logAppliedClasses(element: HTMLElement, label?: string): void {
  if (publicEnv.NODE_ENV === "development") {
    const tailwindClasses = extractTailwindClasses(element);
    console.log(`${label || "Element"} Tailwind classes:`, tailwindClasses);
  }
}

export function validateRequiredClasses(
  element: HTMLElement,
  requiredClasses: string[]
): boolean {
  const missing = requiredClasses.filter(
    (cls) => !element.classList.contains(cls)
  );

  if (missing.length > 0 && publicEnv.NODE_ENV === "development") {
    console.warn("Missing required classes:", missing);
    return false;
  }

  return true;
}
```

---

**Keep utilities pure, focused, and well-typed. Each function should have a single responsibility and predictable behavior. ALL utilities must support TailwindCSS with tw- prefix patterns.**
