# Src Directory Context

## File Organization & Utility Structure

### Current Structure
```
src/
├── errors/                  # Error handling utilities
│   ├── authentication.ts   # Auth-specific errors
│   ├── wallet-auth.ts      # Wallet authentication errors
│   ├── wallet-connection.ts # Connection error handling
│   └── adapter.ts          # Adapter pattern errors
├── types/                  # TypeScript definitions
│   ├── security.ts         # Security-related types
│   └── window.d.ts         # Window object extensions
└── utils/                  # Pure utility functions
    ├── security-logger.ts  # Secure logging utilities
    └── wallet-sanitization.ts # Input sanitization
```

### File Organization Principles

#### Single Responsibility for Utilities
- **One Function Per File**: Small, focused utility functions
- **Related Functions**: Group in same file only if tightly coupled
- **Pure Functions**: No side effects, predictable outputs
- **Type Safety**: Full TypeScript coverage for all utilities

#### Error Handling Architecture
```typescript
// ✅ Good: Specific error types
class WalletConnectionError extends Error {
  constructor(message: string, public code: string) {
    super(message)
    this.name = 'WalletConnectionError'
  }
}

class AuthenticationError extends Error {
  constructor(message: string, public code: string) {
    super(message)
    this.name = 'AuthenticationError'
  }
}

// ✅ Good: Error factory functions
export function createWalletError(code: string, message: string) {
  return new WalletConnectionError(message, code)
}
```

### Utility Function Patterns

#### Pure Function Design
```typescript
// ✅ Good: Pure utility function
export function formatCurrency(
  amount: number | bigint,
  currency: string = 'USD',
  decimals: number = 2
): string {
  const numericAmount = typeof amount === 'bigint' 
    ? Number(amount) / Math.pow(10, 18) // Handle Wei conversion
    : amount
    
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  }).format(numericAmount)
}

// ✅ Good: Validation utility
export function isValidEthereumAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address)
}

// ✅ Good: Transformation utility
export function truncateAddress(
  address: string,
  startChars: number = 6,
  endChars: number = 4
): string {
  if (!isValidEthereumAddress(address)) {
    throw new Error('Invalid Ethereum address')
  }
  
  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`
}
```

#### Error Handling Utilities
```typescript
// Security-focused error handling
export function sanitizeErrorMessage(message: string): string {
  // Remove sensitive patterns
  return message
    .replace(/0x[a-fA-F0-9]+/g, '[ADDRESS_REDACTED]')
    .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL_REDACTED]')
    .replace(/\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b/g, '[CARD_REDACTED]')
}

// Structured error logging
export function logError(
  context: string,
  error: Error,
  metadata?: Record<string, unknown>
): void {
  const logEntry = {
    timestamp: new Date().toISOString(),
    context,
    name: error.name,
    message: sanitizeErrorMessage(error.message),
    stack: error.stack ? sanitizeErrorMessage(error.stack) : undefined,
    metadata: metadata ? sanitizeMetadata(metadata) : undefined
  }
  
  // Log to appropriate service based on environment
  if (process.env.NODE_ENV === 'development') {
    console.error('[ERROR]', logEntry)
  } else {
    // Send to monitoring service
    sendToMonitoringService(logEntry)
  }
}
```

### Type Organization Strategy

#### Domain-Specific Types
```typescript
// types/wallet.ts
export interface WalletConnection {
  address: string
  chainId: number
  isConnected: boolean
  provider: unknown
}

export interface WalletError {
  code: string
  message: string
  details?: Record<string, unknown>
}

export type WalletState = 
  | { status: 'disconnected' }
  | { status: 'connecting' }
  | { status: 'connected'; connection: WalletConnection }
  | { status: 'error'; error: WalletError }
```

#### Shared Base Types
```typescript
// types/common.ts
export interface ApiResponse<T> {
  data: T
  success: boolean
  message?: string
  error?: string
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    hasMore: boolean
  }
}

export type AsyncState<T> = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: Error }
```

#### Component Prop Types
```typescript
// types/components.ts
export interface BaseComponentProps {
  className?: string
  children?: React.ReactNode
  testId?: string
}

export interface ButtonProps extends BaseComponentProps {
  variant?: 'primary' | 'secondary' | 'danger'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  loading?: boolean
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
}

export interface ModalProps extends BaseComponentProps {
  isOpen: boolean
  onClose: () => void
  title?: string
  size?: 'small' | 'medium' | 'large' | 'fullscreen'
}
```

### Security Utilities

#### Input Sanitization
```typescript
// utils/sanitization.ts
export function sanitizeUserInput(input: string): string {
  return input
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+\s*=/gi, '')
}

export function sanitizeHtml(html: string): string {
  // Use DOMPurify or similar library in production
  return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
}

export function validateAndSanitizeAddress(address: string): string {
  const sanitized = address.trim().toLowerCase()
  
  if (!isValidEthereumAddress(sanitized)) {
    throw new Error('Invalid Ethereum address format')
  }
  
  return sanitized
}
```

#### Crypto Utilities
```typescript
// utils/crypto.ts
export function generateSecureNonce(): string {
  const array = new Uint8Array(32)
  crypto.getRandomValues(array)
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
}

export function hashMessage(message: string): string {
  const encoder = new TextEncoder()
  const data = encoder.encode(message)
  
  return crypto.subtle.digest('SHA-256', data)
    .then(hashBuffer => {
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    })
}

export function isSecureContext(): boolean {
  return typeof window !== 'undefined' && window.isSecureContext
}
```

### Data Transformation Utilities

#### Web3 Utilities
```typescript
// utils/web3.ts
export function weiToEth(wei: bigint): number {
  return Number(wei) / Math.pow(10, 18)
}

export function ethToWei(eth: number): bigint {
  return BigInt(Math.floor(eth * Math.pow(10, 18)))
}

export function formatTokenAmount(
  amount: bigint,
  decimals: number = 18,
  displayDecimals: number = 4
): string {
  const divisor = BigInt(Math.pow(10, decimals))
  const quotient = amount / divisor
  const remainder = amount % divisor
  
  const decimal = Number(remainder) / Math.pow(10, decimals)
  const total = Number(quotient) + decimal
  
  return total.toFixed(displayDecimals)
}

export function shortenTransactionHash(hash: string): string {
  return `${hash.slice(0, 6)}...${hash.slice(-4)}`
}
```

#### Date & Time Utilities
```typescript
// utils/time.ts
export function formatRelativeTime(date: Date | string): string {
  const now = new Date()
  const target = new Date(date)
  const diffMs = now.getTime() - target.getTime()
  
  const units = [
    { label: 'year', ms: 365 * 24 * 60 * 60 * 1000 },
    { label: 'month', ms: 30 * 24 * 60 * 60 * 1000 },
    { label: 'day', ms: 24 * 60 * 60 * 1000 },
    { label: 'hour', ms: 60 * 60 * 1000 },
    { label: 'minute', ms: 60 * 1000 },
    { label: 'second', ms: 1000 }
  ]
  
  for (const unit of units) {
    const value = Math.floor(diffMs / unit.ms)
    if (value > 0) {
      return `${value} ${unit.label}${value > 1 ? 's' : ''} ago`
    }
  }
  
  return 'just now'
}

export function isExpired(expiryDate: Date | string): boolean {
  return new Date(expiryDate) < new Date()
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setDate(result.getDate() + days)
  return result
}
```

### API Integration Utilities

#### HTTP Client Utilities
```typescript
// utils/api.ts
export interface ApiConfig {
  baseUrl: string
  timeout: number
  headers: Record<string, string>
}

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${process.env.NEXT_PUBLIC_API_BASE_URL}${endpoint}`
  
  const config: RequestInit = {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  }
  
  try {
    const response = await fetch(url, config)
    
    if (!response.ok) {
      throw new ApiError(
        `HTTP error! status: ${response.status}`,
        response.status
      )
    }
    
    return await response.json()
  } catch (error) {
    if (error instanceof ApiError) throw error
    
    throw new ApiError(
      `Network error: ${error.message}`,
      0,
      'NETWORK_ERROR'
    )
  }
}
```

#### Retry Utilities
```typescript
// utils/retry.ts
export interface RetryOptions {
  maxAttempts: number
  delayMs: number
  backoffMultiplier: number
  maxDelayMs: number
}

export async function retryOperation<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const config = {
    maxAttempts: 3,
    delayMs: 1000,
    backoffMultiplier: 2,
    maxDelayMs: 10000,
    ...options
  }
  
  let lastError: Error
  
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error as Error
      
      if (attempt === config.maxAttempts) {
        throw lastError
      }
      
      const delay = Math.min(
        config.delayMs * Math.pow(config.backoffMultiplier, attempt - 1),
        config.maxDelayMs
      )
      
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
  
  throw lastError!
}
```

### Local Storage Utilities

#### Safe Storage Access
```typescript
// utils/storage.ts
export function safeGetItem(key: string): string | null {
  if (typeof window === 'undefined') return null
  
  try {
    return localStorage.getItem(key)
  } catch (error) {
    console.warn(`Failed to get localStorage item "${key}":`, error)
    return null
  }
}

export function safeSetItem(key: string, value: string): boolean {
  if (typeof window === 'undefined') return false
  
  try {
    localStorage.setItem(key, value)
    return true
  } catch (error) {
    console.warn(`Failed to set localStorage item "${key}":`, error)
    return false
  }
}

export function safeRemoveItem(key: string): boolean {
  if (typeof window === 'undefined') return false
  
  try {
    localStorage.removeItem(key)
    return true
  } catch (error) {
    console.warn(`Failed to remove localStorage item "${key}":`, error)
    return false
  }
}

// Type-safe storage wrapper
export function createTypedStorage<T>(
  key: string,
  defaultValue: T,
  serialize = JSON.stringify,
  deserialize = JSON.parse
) {
  return {
    get(): T {
      const item = safeGetItem(key)
      if (item === null) return defaultValue
      
      try {
        return deserialize(item)
      } catch {
        return defaultValue
      }
    },
    
    set(value: T): boolean {
      try {
        return safeSetItem(key, serialize(value))
      } catch {
        return false
      }
    },
    
    remove(): boolean {
      return safeRemoveItem(key)
    }
  }
}
```

### Testing Utilities

#### Mock Data Generators
```typescript
// utils/test-helpers.ts
export function createMockWallet(overrides: Partial<WalletConnection> = {}): WalletConnection {
  return {
    address: '0x1234567890123456789012345678901234567890',
    chainId: 1,
    isConnected: true,
    provider: {},
    ...overrides
  }
}

export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: 'user-123',
    address: '0x1234567890123456789012345678901234567890',
    username: 'testuser',
    avatar: 'https://example.com/avatar.jpg',
    createdAt: new Date().toISOString(),
    ...overrides
  }
}

export function createMockApiResponse<T>(
  data: T,
  overrides: Partial<ApiResponse<T>> = {}
): ApiResponse<T> {
  return {
    data,
    success: true,
    ...overrides
  }
}
```

### Performance Utilities

#### Debounce & Throttle
```typescript
// utils/performance.ts
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delayMs: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delayMs)
  }
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  intervalMs: number
): (...args: Parameters<T>) => void {
  let lastCallTime = 0
  
  return (...args: Parameters<T>) => {
    const now = Date.now()
    if (now - lastCallTime >= intervalMs) {
      lastCallTime = now
      func(...args)
    }
  }
}

export function memoize<T extends (...args: any[]) => any>(
  func: T,
  getKey?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>()
  
  return ((...args: Parameters<T>) => {
    const key = getKey ? getKey(...args) : JSON.stringify(args)
    
    if (cache.has(key)) {
      return cache.get(key)!
    }
    
    const result = func(...args)
    cache.set(key, result)
    return result
  }) as T
}
```

---

**Keep utilities pure, focused, and well-typed. Each function should have a single responsibility and predictable behavior.**