<context>
# Overview
This document outlines the requirements for refactoring the `useBreadcrumbs` hook in the frontend application. The primary goal is to improve the hook's readability, scalability, and maintainability by adopting a more declarative, configuration-driven approach for handling dynamic breadcrumb generation. This refactor aims to simplify the process of adding or modifying breadcrumb logic for different route types.

# Core Features
The refactored `useBreadcrumbs` hook will retain all existing functionalities:
- Dynamically generate breadcrumb navigation data based on the current Next.js route.
- Fetch and display user-friendly names for dynamic segments (e.g., profile handles, item names) instead of raw IDs.
- Utilize `@tanstack/react-query` for efficient data fetching and caching.
- Support static paths and various predefined dynamic route patterns.
- Provide "Loading..." states during data fetching.

The key *enhancement* is not in user-facing features but in the internal architecture, leading to:
- **Improved Readability:** Logic for each route type will be co-located and declarative.
- **Enhanced Scalability:** Adding support for new dynamic route types will be significantly simpler and involve less boilerplate.
- **Better Maintainability:** Code will be easier to understand, modify, and debug.

# User Experience
The user experience will remain unchanged. The breadcrumbs generated by the refactored hook should be identical to those produced by the current implementation in terms of appearance and behavior.
</context>
<PRD>
# Technical Architecture

## Current State:
- Multiple `useQuery` hooks, one for each dynamic route type.
- Large `switch` statements in `determineRouteConfig` to identify route types.
- Similar large `switch` statements in `finalCrumbs` to assemble breadcrumb arrays.
- Fetcher functions (`fetchGradientName`, `fetchMemeName`, etc.) with some repetitive logic.

## Proposed Refactor:

### 1. Configuration-Driven Approach
- **`RouteDynamicConfig` Type Definition:**
  ```typescript
  interface RouteDynamicConfig<TData = any, TParams = any> {
    type: DynamicRouteType;
    pathPattern: RegExp;
    paramExtractor: (
      pathSegments: readonly string[],
      query: Readonly<Record<string, string | string[]>>
    ) => TParams | undefined;
    fetcher: (params: TParams) => Promise<TData | null>;
    queryKeyBuilder: (params: TParams) => readonly unknown[];
    crumbBuilder: (
      params: TParams,
      data: TData | null | undefined,
      isLoading: boolean,
      pathSegments: readonly string[],
      query: Readonly<Record<string, string | string[]>>
    ) => Crumb[];
    parentCrumbs?: readonly Crumb[];
  }
  ```
- **`DynamicRouteType` Definition:**
  ```typescript
  export type DynamicRouteType = 
    | "gradient"
    | "profile"
    | "meme"
    | "collection"
    | "wave"
    | "nextgen"
    | "meme-lab"
    | "rememe";
  ```
- **`DYNAMIC_ROUTE_CONFIGS` Array:**
  - An array of `RouteDynamicConfig` objects, one for each supported dynamic route type (gradient, profile, meme, nextgen, rememe, meme-lab, collection, wave).
  - Each object will encapsulate all logic specific to that route.

### 2. Revised `determineRouteConfig` Logic
- Iterate through `DYNAMIC_ROUTE_CONFIGS`.
- The first config whose `pathPattern` matches the current route's primary segment and whose `paramExtractor` successfully returns parameters will be chosen.
- Returns an object containing the matched `config` and extracted `params`.

### 3. Centralized Data Fetching
- A single primary `useQuery` hook will be used for most dynamic routes.
- `queryKey` and `queryFn` will be dynamically derived from the `activeRouteConfig.config.queryKeyBuilder` and `activeRouteConfig.config.fetcher` respectively.
- The `useWaveData` hook might remain separate if its fetching logic is too distinct or be integrated if its configuration can be adapted.
- Caching strategy (`staleTime`, `refetchOnWindowFocus`) will remain consistent.

### 4. Simplified Crumb Building
- The `finalCrumbs` memoized calculation will use the `activeRouteConfig.config.crumbBuilder` to generate dynamic crumbs.
- Logic for static crumbs (`buildStaticCrumbs`) will be preserved for unmatched routes.

### 5. Fetcher Function Consolidation (Optional but Recommended)
- Explore creating a higher-order or generic fetcher function to reduce boilerplate in individual fetchers if API patterns allow. Example:
  ```typescript
  async function genericFetchName<TParams extends { id: string }>(
    endpoint: string,
    params: TParams,
    entityName: string,
    apiParamsExtractor?: (params: TParams) => Record<string, any> // More flexible param construction
  ): Promise<{ name: string } | null;
  ```

### 6. `activeItem` State Simplification
- Evaluate if the `activeItem` state and its `useEffect` can be simplified or removed by directly using `pathname`, `asPath`, and `query` from `useRouter()` in `useMemo` dependencies, if this doesn't negatively impact stability or re-renders.

## System Components:
- `hooks/useBreadcrumbs.ts`: The primary file to be refactored.
- `services/api/common-api.ts`: Used by fetcher functions (no change expected here).
- `components/breadcrumb/Breadcrumb.tsx`: Consumes the output of the hook (no change expected here).
- Various entity type definitions (e.g., `ApiWave`, `NextGenToken`).

## Data Models:
- `Crumb` interface: No change expected.
- `RouteDynamicConfig` interface: New.
- API response types for fetchers: No change expected.

## APIs and Integrations:
- Existing backend APIs for fetching entity names (gradients, memes, etc.): No change.
- `@tanstack/react-query`: Continue use for data fetching.
- `next/router`: Continue use for route information.

# Development Roadmap

## Phase 1: Core Refactor & Configuration Setup
1.  **Define `RouteDynamicConfig` Interface:** Establish the structure for route configurations.
2.  **Implement Initial Configurations:** Create `RouteDynamicConfig` objects for 2-3 key dynamic route types (e.g., "gradient", "profile", "meme").
    - Implement their respective `paramExtractor`, `fetcher` (initially reusing existing ones), `queryKeyBuilder`, and `crumbBuilder` functions.
3.  **Refactor `determineRouteConfig`:** Implement the logic to use the `DYNAMIC_ROUTE_CONFIGS` array to find the active configuration and parameters.
4.  **Implement Centralized `useQuery`:** Replace individual `useQuery` calls for the configured routes with the new centralized hook.
5.  **Refactor `finalCrumbs` Logic:** Update `finalCrumbs` to use the `crumbBuilder` from the active configuration.
6.  **Testing:** Thoroughly test the refactored logic for the initial set of routes, ensuring output matches the original hook. Test static routes as well.

## Phase 2: Migrate Remaining Routes & Refine Fetchers
1.  **Migrate All Other Dynamic Routes:** Create `RouteDynamicConfig` objects for all remaining dynamic route types (nextgen, rememe, meme-lab, collection, wave).
    - Adapt existing fetcher and crumb-building logic into the new configuration structure.
    - Ensure the `useWaveData` hook is correctly integrated or handled.
2.  **Consolidate Fetcher Functions (Optional):** If feasible, refactor common logic out of the individual fetcher functions into a generic utility.
3.  **Testing:** Test all route types comprehensively. Pay attention to edge cases and different parameter combinations.

## Phase 3: Code Cleanup & Documentation
1.  **Review and Refine `activeItem` State:** Simplify or remove if possible.
2.  **Code Comments and Documentation:** Add JSDoc comments to the new `RouteDynamicConfig` interface and complex parts of the hook.
3.  **Final Code Review:** Ensure consistency, readability, and adherence to project standards.
4.  **Performance Check:** Briefly verify that the refactor hasn't introduced performance regressions (e.g., unnecessary re-renders).

## MVP Requirements:
- At least one dynamic route type fully refactored using the configuration-driven approach.
- The centralized `useQuery` and updated `determineRouteConfig` / `finalCrumbs` logic are functional.
- Static route handling remains unaffected and correct.
- No regressions in breadcrumb output for the refactored route(s).

## Future Enhancements:
- Further generalization of `crumbBuilder` functions if common patterns emerge.
- More sophisticated path pattern matching if needed (beyond simple regex on the first segment).

# Logical Dependency Chain
1.  **Foundation:** Define the `RouteDynamicConfig` interface. This is the cornerstone of the new architecture.
2.  **Core Logic:** Implement `determineRouteConfig` and the centralized `useQuery` to work with the new configuration structure. This proves the viability of the approach.
3.  **Incremental Migration:** Migrate each dynamic route type one by one into the new configuration array. This allows for iterative testing and reduces risk.
    - Start with simpler routes, then move to more complex ones (e.g., those with multiple dynamic segments or special data sources like `useWaveData`).
4.  **UI Verification:** Continuously verify that the breadcrumbs appear correctly on the frontend for each migrated route.
5.  **Refinement & Cleanup:** Once all routes are migrated, focus on optional refinements like fetcher consolidation and `activeItem` state optimization.

# Risks and Mitigations
- **Technical Complexity:** The initial setup of the configuration-driven structure might be complex.
    - **Mitigation:** Start with a simplified `RouteDynamicConfig` and a couple of routes to prove the concept. Iterate and add complexity as needed. Break down the work into smaller, manageable tasks.
- **Introducing Regressions:** Changes to a core hook like `useBreadcrumbs` could break navigation aid across the site.
    - **Mitigation:** Thorough component-level and page-level testing for each route type after refactoring. Compare output with the existing hook. Implement an incremental rollout if possible (though harder for a hook).
- **Over-Engineering:** The configuration might become too abstract or complex for the current needs.
    - **Mitigation:** Keep the configuration focused on solving the immediate problems of readability and scalability for *this* hook. Avoid adding features not directly required.
- **Time Estimation:** Refactoring can sometimes take longer than expected.
    - **Mitigation:** Prioritize getting the core mechanism working (Phase 1 MVP) and then incrementally migrate other routes. This provides a functional, partially refactored hook early on.
- **Edge Cases in `paramExtractor` or `pathPattern`:** Ensuring all URL variations are correctly handled.
    - **Mitigation:** Detailed testing with various URL structures, including those with and without query parameters, and varying numbers of path segments.

# Appendix
- Original `hooks/useBreadcrumbs.ts` file for reference.
- Discussion/notes on the proposed refactoring approach.
</PRD> 
