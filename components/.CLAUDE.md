# Components Directory Context

## Core Philosophy: Simple, Readable, Maintainable Components

**"Write components that new team members can understand in 5 minutes. Favor clear, straightforward solutions over clever abstractions."**

## File Organization & Single Responsibility Guidelines

### Component Size Standards (Keep It Simple)
- **Sweet Spot**: 100-200 lines per component (easier to understand)
- **Warning Threshold**: 300+ lines requires review for splitting opportunities  
- **Critical Threshold**: 500+ lines MUST be refactored
- **Emergency**: 700+ lines needs immediate attention (blocks maintainability)

### Simple Component Patterns
```typescript
// ✅ Good: Clear, single responsibility
function UserCard({ user, onEdit }) {
  return (
    <div className="tw-bg-iron-900 tw-p-4 tw-rounded-lg">
      <img className="tw-w-12 tw-h-12 tw-rounded-full" src={user.avatar} />
      <h3 className="tw-text-iron-50">{user.name}</h3>
      <button onClick={() => onEdit(user.id)}>Edit</button>
    </div>
  )
}

// ❌ Avoid: Trying to be too clever
function UniversalCard({ type, data, actions, config }) {
  // 200 lines of conditional rendering logic...
}
```

### Current File Organization Patterns

#### Feature-Based Structure (Recommended)
```
components/
├── auth/                    # Authentication & authorization
│   ├── error-boundary/     # Well-organized error handling
│   └── SeizeConnectContext.tsx
├── waves/                  # Social features & wave management
│   ├── create/             # Wave creation workflow
│   ├── drop/               # Individual drop components  
│   ├── hooks/              # Wave-specific hooks
│   └── ChatItemHrefButtons.tsx
├── user/                   # User profile & settings
│   ├── brain/              # User dashboard
│   ├── collected/          # NFT collections
│   ├── settings/           # User preferences
│   └── layout/             # Profile layout components
└── utils/                  # Shared UI components
    ├── button/             # Button variants
    ├── input/              # Form inputs
    └── tooltip/            # Tooltips & popovers
```

## React 19 Component Patterns (2025)

### Simple Function Component Structure
```typescript
// ✅ PREFERRED: Clear, simple function component with TypeScript
interface UserCardProps {
  user: User;
  onEdit: (id: string) => void;
  className?: string;
}

export function UserCard({ user, onEdit, className }: UserCardProps) {
  return (
    <div className={cn("tw-bg-iron-900 tw-p-4 tw-rounded-lg", className)}>
      <img className="tw-w-12 tw-h-12 tw-rounded-full" src={user.avatar} alt={user.name} />
      <h3 className="tw-text-iron-50">{user.name}</h3>
      <button className="tw-text-primary-400" onClick={() => onEdit(user.id)}>
        Edit
      </button>
    </div>
  )
}

// ❌ AVOID: Default exports (harder to refactor)
export default function UserCard() { /* ... */ }

// ❌ AVOID: Class components (React 19 focuses on function components)
export class UserCard extends Component { /* ... */ }
```

### React 19 New Features - Use When They Add Value
```typescript
// ✅ Good: useOptimistic for immediate user feedback
function EditUserForm({ user, onSave }) {
  const [optimisticUser, updateOptimistic] = useOptimistic(user)
  
  const handleSave = async (formData) => {
    // Show immediate feedback
    updateOptimistic({ ...user, name: formData.get('name') })
    
    try {
      await onSave(formData) // Updates actual data
    } catch (error) {
      // optimisticUser automatically reverts on error
    }
  }
  
  return (
    <form action={handleSave}>
      <input name="name" defaultValue={optimisticUser.name} />
      <SaveButton />
    </form>
  )
}

// ✅ Good: useFormStatus for button state
function SaveButton() {
  const { pending } = useFormStatus()
  return (
    <button disabled={pending}>
      {pending ? 'Saving...' : 'Save'}
    </button>
  )
}

// ❌ Avoid: Using new features where simple useState works fine
function SimpleCounter() {
  const [count, setCount] = useState(0) // This is still the best choice
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>
}
```

### Single Responsibility Violation Indicators

#### 1. Component Description Uses "And"
```typescript
// ❌ Bad: Multiple responsibilities
function UserProfileAndSettingsAndNavigation() {
  // Manages user data AND handles settings AND controls navigation
}

// ✅ Good: Split responsibilities
function UserProfile() { /* User data display only */ }
function UserSettings() { /* Settings management only */ }
function UserNavigation() { /* Navigation logic only */ }
```

#### 2. Multiple useEffect Hooks with Different Concerns
```typescript
// ❌ Bad: Mixed concerns
function ComplexComponent() {
  useEffect(() => {
    // Fetch user data
  }, [userId])
  
  useEffect(() => {
    // Setup WebSocket connection
  }, [])
  
  useEffect(() => {
    // Handle window resize
  }, [])
  
  useEffect(() => {
    // Analytics tracking
  }, [pageView])
}

// ✅ Good: Extract custom hooks
function useUserData(userId) { /* User data effect */ }
function useWebSocket() { /* WebSocket effect */ }
function useWindowResize() { /* Resize effect */ }
function useAnalytics(pageView) { /* Analytics effect */ }

function ComplexComponent() {
  useUserData(userId)
  useWebSocket()
  useWindowResize()
  useAnalytics(pageView)
}
```

#### 3. State Management Complexity
```typescript
// ❌ Bad: Too many state variables
function OverloadedComponent() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  const [selectedItems, setSelectedItems] = useState([])
  const [modalOpen, setModalOpen] = useState(false)
  // ... 10+ more state variables
}

// ✅ Good: Group related state
function useUserListState() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  return { users, loading, error, setUsers, setLoading, setError }
}

function useFilterState() {
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  return { filters, sortBy, page, setFilters, setSortBy, setPage }
}
```

### Component Splitting Strategies

#### 1. Extract Sub-Components (UI Composition)
```typescript
// Before: Monolithic component
function UserDashboard() {
  return (
    <div className="dashboard">
      {/* 200 lines of header JSX */}
      {/* 300 lines of sidebar JSX */}
      {/* 400 lines of main content JSX */}
      {/* 200 lines of footer JSX */}
    </div>
  )
}

// After: Composed of focused components
function DashboardHeader() { /* Header-specific logic */ }
function DashboardSidebar() { /* Sidebar-specific logic */ }
function DashboardMain() { /* Main content logic */ }
function DashboardFooter() { /* Footer-specific logic */ }

function UserDashboard() {
  return (
    <div className="dashboard">
      <DashboardHeader />
      <DashboardSidebar />
      <DashboardMain />
      <DashboardFooter />
    </div>
  )
}
```

#### 2. Extract Business Logic (Custom Hooks)
```typescript
// Before: Mixed logic and presentation
function WavesList() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return <div>{/* 200+ lines of JSX */}</div>
}

// After: Separated concerns
function useWavesData() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return { waves, loading, refetch: fetchWaves }
}

function WavesList() {
  const { waves, loading, refetch } = useWavesData()
  
  if (loading) return <WavesListSkeleton />
  return <WavesListContent waves={waves} onRefresh={refetch} />
}
```

#### 3. Container/Presentation Pattern
```typescript
// Container: Handles data and state
function UserProfileContainer({ userId }: { userId: string }) {
  const { user, loading, error } = useUserData(userId)
  const { updateUser } = useUserMutations()
  
  return (
    <UserProfilePresentation
      user={user}
      loading={loading}
      error={error}
      onUpdate={updateUser}
    />
  )
}

// Presentation: Pure rendering logic
function UserProfilePresentation({ user, loading, error, onUpdate }) {
  if (loading) return <UserProfileSkeleton />
  if (error) return <UserProfileError error={error} />
  
  return (
    <div className="user-profile">
      <UserAvatar src={user.avatar} />
      <UserDetails user={user} />
      <UserActions onUpdate={onUpdate} />
    </div>
  )
}
```

### Component Testing Strategies for Split Components

#### Testing Composition
```typescript
// Test composed components
describe('UserDashboard', () => {
  it('renders all sections', () => {
    render(<UserDashboard />)
    expect(screen.getByTestId('dashboard-header')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-sidebar')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-main')).toBeInTheDocument()
  })
})

// Test individual components
describe('DashboardHeader', () => {
  it('displays user name', () => {
    render(<DashboardHeader user={mockUser} />)
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
  })
})
```

#### Testing Custom Hooks
```typescript
// Test business logic in isolation
describe('useWavesData', () => {
  it('fetches waves on mount', async () => {
    const { result } = renderHook(() => useWavesData())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.waves).toHaveLength(3)
    })
  })
})
```

### File Naming Conventions for Split Components

#### Hierarchical Naming
```
UserProfile/
├── index.ts                     # Re-exports main component
├── UserProfile.tsx              # Main component (container)
├── UserProfilePresentation.tsx  # Presentation component
├── UserProfileHeader.tsx        # Sub-component
├── UserProfileActions.tsx       # Action buttons
├── hooks/
│   ├── useUserData.ts          # Data fetching hook
│   └── useUserMutations.ts     # Mutation hook
├── types.ts                    # TypeScript interfaces
└── UserProfile.test.tsx        # Test file
```

#### Component Variants
```
Button/
├── Button.tsx           # Base button component
├── PrimaryButton.tsx    # Primary variant
├── SecondaryButton.tsx  # Secondary variant
├── IconButton.tsx       # Icon-only variant
└── types.ts            # Shared button types
```

### Performance Optimization for Split Components

#### Lazy Loading Sub-Components
```typescript
// Lazy load heavy sub-components
const HeavyChart = lazy(() => import('./HeavyChart'))
const DataTable = lazy(() => import('./DataTable'))

function Dashboard() {
  const [activeTab, setActiveTab] = useState('overview')
  
  return (
    <div>
      <DashboardTabs activeTab={activeTab} onChange={setActiveTab} />
      
      <Suspense fallback={<ComponentSkeleton />}>
        {activeTab === 'charts' && <HeavyChart />}
        {activeTab === 'data' && <DataTable />}
      </Suspense>
    </div>
  )
}
```

#### Memoization for Split Components
```typescript
// Memoize expensive sub-components
const ExpensiveSubComponent = memo(({ data, onAction }) => {
  const processedData = useMemo(() => {
    return expensiveCalculation(data)
  }, [data])
  
  return <div>{/* Render processed data */}</div>
})

// Use callback to prevent re-renders
function ParentComponent() {
  const [data, setData] = useState([])
  
  const handleAction = useCallback((action) => {
    // Handle action
  }, [])
  
  return (
    <ExpensiveSubComponent 
      data={data} 
      onAction={handleAction} 
    />
  )
}
```

### Component Organization Patterns

#### Feature-First Organization
```
waves/
├── create/                    # Wave creation feature
│   ├── CreateWaveForm.tsx    
│   ├── CreateWavePreview.tsx  
│   └── hooks/                 
├── list/                     # Wave listing feature
│   ├── WavesList.tsx         
│   ├── WaveItem.tsx          
│   └── filters/               
└── shared/                   # Shared wave components
    ├── WaveCard.tsx          
    └── WaveActions.tsx       
```

#### Size-Based Organization
```
components/
├── atoms/                    # Small, single-purpose (< 50 lines)
│   ├── Button.tsx           
│   ├── Input.tsx            
│   └── Icon.tsx             
├── molecules/                # Medium complexity (50-150 lines)
│   ├── SearchBox.tsx        
│   ├── UserCard.tsx         
│   └── NavigationItem.tsx   
├── organisms/                # Complex components (150-300 lines)
│   ├── Header.tsx           
│   ├── Sidebar.tsx          
│   └── UserProfile.tsx      
└── templates/                # Layout components
    ├── PageLayout.tsx       
    └── DashboardLayout.tsx  
```

### Critical Refactoring Targets

#### Immediate Priority (1000+ lines)
1. **CollectionDelegation.tsx** (1,984 lines)
   - Split into: DelegationForm, DelegationStatus, DelegationHistory
   - Extract: useDelegationData, useDelegationMutations
   - Create: DelegationProvider context

2. **ReactQueryWrapper.tsx** (1,268 lines)
   - Split into: QueryProvider, MutationProvider, DevTools
   - Extract: useQueryConfig, useErrorHandling
   - Separate: Client configuration from provider logic

3. **MemeLabPage.tsx** (1,249 lines)
   - Split into: LabFilters, LabGrid, LabPagination
   - Extract: useLabData, useLabFilters, useLabPagination
   - Create: LabProvider context

### Mobile-Specific Component Considerations

#### Responsive Component Variants
```typescript
// Desktop-specific components
function DesktopNavigation() { /* Desktop nav logic */ }

// Mobile-specific components  
function MobileNavigation() { /* Mobile nav logic */ }

// Adaptive component
function Navigation() {
  const isMobile = useIsMobileDevice()
  
  return isMobile ? <MobileNavigation /> : <DesktopNavigation />
}
```

#### Touch-Optimized Components
```typescript
function TouchOptimizedButton({ children, ...props }) {
  return (
    <button
      {...props}
      style={{
        minHeight: '44px', // Touch target size
        minWidth: '44px',
        ...props.style
      }}
    >
      {children}
    </button>
  )
}
```

## Fail-Fast Component Error Handling Patterns

### **CRITICAL: Ultra-Aggressive Error Boundaries for Component Groups**

**No Graceful Degradation - Show Failure States Clearly**

#### 1. **Feature-Level Fail-Fast Error Boundaries**

```typescript
// ✅ CORRECT: Aggressive error boundary with no fallback components
function WavesFeatureErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <div className="tw-min-h-[400px] tw-bg-red-50 tw-border-2 tw-border-red-500 tw-rounded-lg tw-p-8 tw-text-center tw-m-4">
          <div className="tw-text-red-600 tw-mb-4">
            <svg className="tw-w-16 tw-h-16 tw-mx-auto tw-mb-4" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
          </div>
          <h3 className="tw-text-xl tw-font-bold tw-text-red-800 tw-mb-4">
            Waves Feature Failure
          </h3>
          <p className="tw-text-red-700 tw-mb-4 tw-max-w-md tw-mx-auto">
            The waves feature encountered a critical error and cannot function safely. 
            This failure prevents potential data corruption or security issues.
          </p>
          
          {error instanceof SecurityViolationError && (
            <div className="tw-bg-red-100 tw-border tw-border-red-400 tw-p-4 tw-rounded tw-mb-4">
              <p className="tw-text-red-800 tw-font-semibold">
                🚨 Security violation detected - feature disabled for protection
              </p>
            </div>
          )}
          
          <div className="tw-space-y-3">
            <button
              onClick={resetErrorBoundary}
              className="tw-block tw-w-full tw-bg-red-600 tw-text-white tw-px-6 tw-py-3 tw-rounded-lg tw-font-medium hover:tw-bg-red-700 tw-transition-colors"
            >
              Reset Waves Feature
            </button>
            <button
              onClick={() => window.location.reload()}
              className="tw-block tw-w-full tw-bg-gray-600 tw-text-white tw-px-6 tw-py-3 tw-rounded-lg tw-font-medium hover:tw-bg-gray-700 tw-transition-colors"
            >
              Reload Application
            </button>
          </div>
          
          <p className="tw-text-red-600 tw-text-sm tw-mt-4">
            Error ID: {error instanceof SeizeError ? error.code : 'UNKNOWN_ERROR'}
          </p>
        </div>
      )}
      onError={(error, errorInfo) => {
        // Enhanced security-focused error logging
        logCriticalError('waves_feature_boundary', error instanceof SeizeError ? error : new SeizeError(
          error.message || 'Unknown boundary error',
          'COMPONENT_BOUNDARY_ERROR',
          { componentStack: sanitizeErrorMessage(errorInfo.componentStack || '') }
        ));
        
        // Security violation reporting
        if (error instanceof SecurityViolationError) {
          logSecurityEvent(SecurityEventType.COMPONENT_SECURITY_BOUNDARY, {
            featureName: 'waves',
            source: 'error_boundary',
            componentStack: sanitizeErrorMessage(errorInfo.componentStack || '')
          });
        }
      }}
    >
      {children}
    </ErrorBoundary>
  )
}

// Usage: Aggressive wrapping with no component fallbacks
function WavesPage() {
  return (
    <WavesFeatureErrorBoundary>
      <div className="tw-space-y-6">
        {/* Each critical component is independently protected */}
        <CriticalComponentErrorBoundary featureName="Wave Creation">
          <WaveCreator />
        </CriticalComponentErrorBoundary>
        
        <CriticalComponentErrorBoundary featureName="Wave List">
          <WavesList />
        </CriticalComponentErrorBoundary>
        
        <CriticalComponentErrorBoundary featureName="Wave Filters">
          <WaveFilters />
        </CriticalComponentErrorBoundary>
      </div>
    </WavesFeatureErrorBoundary>
  )
}
```

#### 2. **Component-Level Fail-Fast Patterns**

```typescript
// ✅ CORRECT: Individual component with aggressive error handling
function CriticalWalletComponent({ 
  walletAddress 
}: { 
  walletAddress: string 
}) {
  // Fail-fast validation at component entry
  useEffect(() => {
    if (!isValidEthereumAddress(walletAddress)) {
      throw new SecurityViolationError(
        'Invalid wallet address provided to component',
        'COMPONENT_INVALID_WALLET_ADDRESS',
        { addressLength: walletAddress?.length || 0 }
      );
    }
  }, [walletAddress]);

  const { data: walletData, error } = useWalletData(walletAddress);

  // Fail-fast on critical data errors
  if (error instanceof AuthenticationError) {
    throw error; // Propagate authentication errors immediately
  }

  if (error instanceof SecurityViolationError) {
    throw error; // Never handle security violations at component level
  }

  // Only handle recoverable errors
  if (error && !(error instanceof ValidationError)) {
    throw new ComponentError(
      'Unhandled wallet data error',
      'WALLET_COMPONENT_CRITICAL_ERROR',
      { originalError: error }
    );
  }

  return (
    <div className="tw-wallet-component">
      {/* Component content */}
    </div>
  );
}

// ❌ INCORRECT: Soft error handling for critical operations
function SoftWalletComponent({ walletAddress }) {
  const { data, error } = useWalletData(walletAddress);
  
  if (error) {
    return <div>Something went wrong, but continuing...</div>; // DANGEROUS
  }
  
  return <div>{/* content */}</div>;
}
```

#### 3. **Hook-Level Fail-Fast Error Patterns**

```typescript
// ✅ CORRECT: Aggressive custom hook with immediate failure
function useSecureWalletConnection(
  address: string
): WalletConnectionResult {
  const [state, setState] = useState<WalletConnectionState>({
    status: 'disconnected'
  });

  const connect = useCallback(async () => {
    try {
      // Pre-flight security validation
      if (!isValidEthereumAddress(address)) {
        throw new SecurityViolationError(
          'Attempted connection with invalid address format',
          'WALLET_CONNECT_INVALID_ADDRESS',
          { addressLength: address?.length || 0 }
        );
      }

      setState({ status: 'connecting' });
      
      const connection = await establishWalletConnection(address);
      
      // Post-connection validation
      if (!connection || !connection.provider) {
        throw new WalletConnectionError(
          'Connection established but provider unavailable',
          'WALLET_CONNECTION_NO_PROVIDER'
        );
      }

      setState({ 
        status: 'connected', 
        connection,
        address 
      });

    } catch (error) {
      // Log and re-throw - no silent handling
      logCriticalError('wallet_connection_hook', error as SeizeError);
      
      setState({ 
        status: 'error', 
        error: error as SeizeError 
      });
      
      // Re-throw to propagate to error boundary
      throw error;
    }
  }, [address]);

  return {
    ...state,
    connect
  };
}

// ❌ INCORRECT: Hook with silent error handling
function useSoftWalletConnection(address: string) {
  const [error, setError] = useState<Error | null>(null);
  
  const connect = async () => {
    try {
      // connection logic
    } catch (err) {
      setError(err); // Silent - doesn't propagate
      return null; // Soft fallback - DANGEROUS
    }
  };
  
  return { connect, error };
}
```

#### 4. **Form Component Fail-Fast Validation**

```typescript
// ✅ CORRECT: Aggressive form validation with immediate failure
function CriticalTransactionForm({
  onSubmit
}: {
  onSubmit: (data: TransactionData) => Promise<void>
}) {
  const handleSubmit = async (formData: FormData) => {
    try {
      // Aggressive pre-validation
      const amount = formData.get('amount') as string;
      const recipient = formData.get('recipient') as string;
      
      // Fail-fast on security violations
      if (!recipient || !isValidEthereumAddress(recipient)) {
        throw new SecurityViolationError(
          'Invalid recipient address in transaction form',
          'FORM_INVALID_RECIPIENT',
          { recipientLength: recipient?.length || 0 }
        );
      }

      const numericAmount = parseFloat(amount);
      if (isNaN(numericAmount) || numericAmount <= 0) {
        throw new ValidationError(
          'Invalid transaction amount',
          'FORM_INVALID_AMOUNT',
          { amount, parsedAmount: numericAmount }
        );
      }

      // Additional security checks
      if (numericAmount > MAX_TRANSACTION_AMOUNT) {
        throw new SecurityViolationError(
          'Transaction amount exceeds security threshold',
          'FORM_AMOUNT_SECURITY_VIOLATION',
          { amount: numericAmount, threshold: MAX_TRANSACTION_AMOUNT }
        );
      }

      await onSubmit({
        amount: numericAmount,
        recipient: recipient.toLowerCase()
      });

    } catch (error) {
      // Log and re-throw - no form-level error handling
      logCriticalError('transaction_form_submit', error as SeizeError);
      throw error; // Let error boundary handle display
    }
  };

  return (
    <form action={handleSubmit} className="tw-space-y-6">
      <div>
        <label className="tw-block tw-text-sm tw-font-medium tw-text-iron-50">
          Recipient Address
        </label>
        <input
          name="recipient"
          type="text"
          className="tw-w-full tw-px-3 tw-py-2 tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-text-iron-50"
          required
        />
      </div>
      
      <div>
        <label className="tw-block tw-text-sm tw-font-medium tw-text-iron-50">
          Amount (ETH)
        </label>
        <input
          name="amount"
          type="number"
          step="0.000001"
          min="0.000001"
          max={MAX_TRANSACTION_AMOUNT}
          className="tw-w-full tw-px-3 tw-py-2 tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-text-iron-50"
          required
        />
      </div>
      
      <button
        type="submit"
        className="tw-w-full tw-bg-primary-500 tw-text-white tw-px-6 tw-py-3 tw-rounded-lg tw-font-medium hover:tw-bg-primary-600 tw-transition-colors"
      >
        Submit Transaction
      </button>
    </form>
  );
}
```

#### 5. **Component Testing with Fail-Fast Patterns**

```typescript
describe('Fail-Fast Component Patterns', () => {
  it('should throw SecurityViolationError for invalid address', () => {
    const invalidAddress = '0xinvalid';
    
    expect(() => {
      render(
        <CriticalWalletComponent walletAddress={invalidAddress} />
      );
    }).toThrow(SecurityViolationError);
    
    expect(() => {
      render(
        <CriticalWalletComponent walletAddress={invalidAddress} />
      );
    }).toThrow('Invalid wallet address provided to component');
  });

  it('should propagate authentication errors to boundary', async () => {
    const mockAuthError = new AuthenticationError(
      'JWT expired',
      'AUTH_JWT_EXPIRED'
    );
    
    jest.spyOn(walletHooks, 'useWalletData').mockReturnValue({
      data: null,
      error: mockAuthError
    });
    
    expect(() => {
      render(
        <TestErrorBoundary>
          <CriticalWalletComponent walletAddress={VALID_ADDRESS} />
        </TestErrorBoundary>
      );
    }).toThrow(AuthenticationError);
  });

  it('should never silently handle security violations', () => {
    const securityError = new SecurityViolationError(
      'Unauthorized access attempt',
      'SECURITY_UNAUTHORIZED_ACCESS'
    );
    
    // Mock hook to return security error
    jest.spyOn(walletHooks, 'useSecureWalletConnection').mockImplementation(() => {
      throw securityError;
    });
    
    expect(() => {
      const { result } = renderHook(() => 
        useSecureWalletConnection('0x123...')
      );
    }).toThrow(SecurityViolationError);
    
    // Verify error was logged
    expect(mockLogCriticalError).toHaveBeenCalledWith(
      'wallet_connection_hook',
      expect.objectContaining({
        code: 'SECURITY_UNAUTHORIZED_ACCESS'
      })
    );
  });
});
```

#### 6. **Component Performance with Error Handling**

```typescript
// ✅ CORRECT: Memoized component with fail-fast error checking
const OptimizedCriticalComponent = memo(function OptimizedCriticalComponent({
  data,
  securityContext
}: {
  data: ComponentData;
  securityContext: SecurityContext;
}) {
  // Fail-fast security validation in useMemo
  const validatedData = useMemo(() => {
    if (!securityContext.isAuthenticated) {
      throw new SecurityViolationError(
        'Component rendered without authentication',
        'COMPONENT_NO_AUTH_CONTEXT'
      );
    }

    if (!validateComponentData(data)) {
      throw new ValidationError(
        'Invalid data provided to component',
        'COMPONENT_INVALID_DATA',
        { dataKeys: Object.keys(data) }
      );
    }

    return processComponentData(data);
  }, [data, securityContext]);

  return (
    <div className="tw-optimized-component">
      {/* Render with validated data */}
    </div>
  );
});

// Strict prop comparison for security-sensitive components
function securityPropsAreEqual(
  prevProps: ComponentProps, 
  nextProps: ComponentProps
): boolean {
  // Fail-fast if security context changes
  if (prevProps.securityContext !== nextProps.securityContext) {
    return false;
  }
  
  // Deep comparison for critical data
  return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data);
}

export default memo(OptimizedCriticalComponent, securityPropsAreEqual);
```

---

**CRITICAL COMPONENT GUIDELINES**:

1. **Never return fallback UI** for critical errors (auth, security, transactions)
2. **Always propagate security violations** to error boundaries
3. **Log every error** with structured context before throwing
4. **Validate props aggressively** at component entry points
5. **Use TypeScript discriminated unions** for error states
6. **Test error propagation paths** explicitly
7. **Wrap form submissions** in try-catch with re-throw
8. **Memoize security validations** for performance

### Error Boundary Patterns for Component Groups

#### Legacy Pattern (Being Migrated)
```typescript
// ❌ DEPRECATED: Soft error handling pattern
function WavesFeatureErrorBoundary({ children }) {
  return (
    <ErrorBoundary
      FallbackComponent={WavesErrorFallback} // Shows generic fallback
      onError={(error) => logError('waves_feature', error)} // Insufficient logging
    >
      {children}
    </ErrorBoundary>
  )
}
```

## TailwindCSS Component Styling Guidelines

### **MANDATORY: All Components Must Use TailwindCSS with tw- Prefix**

#### Component-Level TailwindCSS Patterns

**1. Component Wrapper Patterns**
```tsx
// ✅ CORRECT: Standard component wrapper with TailwindCSS
function UserProfileCard({ user }: { user: User }) {
  return (
    <div className="tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-p-6 tw-shadow-lg">
      <div className="tw-flex tw-items-center tw-gap-4">
        <img 
          className="tw-w-12 tw-h-12 tw-rounded-full tw-ring-2 tw-ring-primary-500" 
          src={user.avatar} 
          alt={user.name}
        />
        <div className="tw-flex-1">
          <h3 className="tw-text-lg tw-font-semibold tw-text-iron-50">{user.name}</h3>
          <p className="tw-text-iron-300">{user.email}</p>
        </div>
      </div>
    </div>
  )
}

// ❌ INCORRECT: Bootstrap/non-prefixed classes
<div className="card p-3">
<div className="d-flex align-items-center">
```

**2. Responsive Component Layouts**
```tsx
// ✅ Mobile-first responsive patterns
function ResponsiveGrid({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 lg:tw-grid-cols-3 tw-3xl:tw-grid-cols-4 tw-gap-6">
      {children}
    </div>
  )
}

// ✅ Container query responsive components
function AdaptiveCard({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-@container tw-w-full">
      <div className="tw-flex tw-flex-col @md:tw-flex-row tw-gap-4">
        {children}
      </div>
    </div>
  )
}
```

**3. State-Based Component Styling**
```tsx
// ✅ Component state styling patterns
function InteractiveButton({ 
  variant = 'primary', 
  loading = false, 
  disabled = false,
  children 
}: {
  variant?: 'primary' | 'secondary' | 'danger'
  loading?: boolean
  disabled?: boolean
  children: React.ReactNode
}) {
  const baseClasses = "tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-transition-all tw-duration-200 tw-transform"
  
  const variantClasses = {
    primary: "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600 active:tw-scale-95",
    secondary: "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500 active:tw-scale-95",
    danger: "tw-bg-red-600 tw-text-white hover:tw-bg-red-700 active:tw-scale-95"
  }
  
  const stateClasses = {
    loading: "tw-cursor-wait tw-opacity-75",
    disabled: "tw-cursor-not-allowed tw-opacity-50 hover:tw-transform-none"
  }
  
  const className = [
    baseClasses,
    variantClasses[variant],
    loading && stateClasses.loading,
    disabled && stateClasses.disabled
  ].filter(Boolean).join(' ')
  
  return (
    <button className={className} disabled={disabled || loading}>
      {loading && <div className="tw-w-4 tw-h-4 tw-border-2 tw-border-white tw-border-t-transparent tw-rounded-full tw-animate-spin tw-mr-2 tw-inline-block" />}
      {children}
    </button>
  )
}
```

### Headless UI + TailwindCSS Component Integration

**1. Modal/Dialog Components**
```tsx
import { Dialog, DialogPanel, DialogTitle } from '@headlessui/react'

function Modal({ open, onClose, title, children }: {
  open: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
}) {
  return (
    <Dialog 
      open={open} 
      onClose={onClose} 
      className="tw-relative tw-z-50"
    >
      {/* Backdrop */}
      <div className="tw-fixed tw-inset-0 tw-bg-black/30 tw-backdrop-blur-sm" />
      
      {/* Container */}
      <div className="tw-fixed tw-inset-0 tw-flex tw-items-center tw-justify-center tw-p-4">
        <DialogPanel className="tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-xl tw-max-w-md tw-w-full tw-p-6">
          <DialogTitle className="tw-text-lg tw-font-semibold tw-text-iron-50 tw-mb-4">
            {title}
          </DialogTitle>
          {children}
        </DialogPanel>
      </div>
    </Dialog>
  )
}
```

**2. Dropdown/Menu Components**
```tsx
import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/react'

function DropdownMenu({ trigger, items }: {
  trigger: React.ReactNode
  items: Array<{ label: string; onClick: () => void; icon?: React.ComponentType }>
}) {
  return (
    <Menu className="tw-relative">
      <MenuButton className="tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-px-3 tw-py-2 tw-text-iron-50 hover:tw-bg-iron-700 tw-transition-colors">
        {trigger}
      </MenuButton>
      
      <MenuItems className="tw-absolute tw-right-0 tw-mt-2 tw-w-48 tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-lg tw-z-10">
        {items.map((item, index) => (
          <MenuItem key={index}>
            {({ focus }) => (
              <button
                onClick={item.onClick}
                className={`tw-w-full tw-px-4 tw-py-2 tw-text-left tw-flex tw-items-center tw-gap-2 tw-transition-colors ${
                  focus 
                    ? 'tw-bg-primary-500 tw-text-white' 
                    : 'tw-text-iron-300 hover:tw-text-iron-50'
                }`}
              >
                {item.icon && <item.icon className="tw-w-4 tw-h-4" />}
                {item.label}
              </button>
            )}
          </MenuItem>
        ))}
      </MenuItems>
    </Menu>
  )
}
```

**3. Form Components with TailwindCSS**
```tsx
import { Field, Label, Input, Description } from '@headlessui/react'

function FormInput({
  label,
  description,
  error,
  ...inputProps
}: {
  label: string
  description?: string
  error?: string
  [key: string]: any
}) {
  return (
    <Field className="tw-space-y-2">
      <Label className="tw-block tw-text-sm tw-font-medium tw-text-iron-50">
        {label}
      </Label>
      
      <Input 
        className={`tw-w-full tw-px-3 tw-py-2 tw-bg-iron-800 tw-border tw-rounded-lg tw-text-iron-50 tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-offset-2 focus:tw-ring-offset-iron-900 ${
          error 
            ? 'tw-border-red-500 focus:tw-ring-red-500' 
            : 'tw-border-iron-600 focus:tw-border-primary-500 focus:tw-ring-primary-500'
        }`}
        {...inputProps}
      />
      
      {description && (
        <Description className="tw-text-sm tw-text-iron-400">
          {description}
        </Description>
      )}
      
      {error && (
        <p className="tw-text-sm tw-text-red-400 tw-mt-1">{error}</p>
      )}
    </Field>
  )
}
```

### Web3-Specific Component Patterns

**1. Wallet Connection Components**
```tsx
function WalletConnectButton({ 
  connected, 
  address, 
  onConnect, 
  onDisconnect 
}: {
  connected: boolean
  address?: string
  onConnect: () => void
  onDisconnect: () => void
}) {
  if (connected && address) {
    return (
      <button 
        onClick={onDisconnect}
        className="tw-bg-success tw-text-white tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-flex tw-items-center tw-gap-2 hover:tw-bg-green tw-transition-colors"
      >
        <div className="tw-w-2 tw-h-2 tw-bg-white tw-rounded-full tw-animate-pulse" />
        {address.slice(0, 6)}...{address.slice(-4)}
      </button>
    )
  }
  
  return (
    <button 
      onClick={onConnect}
      className="tw-bg-primary-500 tw-text-white tw-px-6 tw-py-2 tw-rounded-lg tw-font-medium hover:tw-bg-primary-600 tw-transition-colors"
    >
      Connect Wallet
    </button>
  )
}
```

**2. Transaction Status Components**
```tsx
function TransactionStatus({ 
  status, 
  hash 
}: { 
  status: 'pending' | 'confirmed' | 'failed'
  hash?: string 
}) {
  const statusConfig = {
    pending: {
      color: 'tw-text-yellow-400',
      bg: 'tw-bg-yellow-400/10',
      icon: 'tw-animate-spin'
    },
    confirmed: {
      color: 'tw-text-green-400',
      bg: 'tw-bg-green-400/10',
      icon: ''
    },
    failed: {
      color: 'tw-text-red-400',
      bg: 'tw-bg-red-400/10',
      icon: ''
    }
  }
  
  const config = statusConfig[status]
  
  return (
    <div className={`tw-flex tw-items-center tw-gap-2 tw-px-3 tw-py-2 tw-rounded-lg ${config.bg}`}>
      <div className={`tw-w-2 tw-h-2 tw-rounded-full ${config.color} ${config.icon}`} />
      <span className={`tw-text-sm tw-font-medium ${config.color}`}>
        {status.charAt(0).toUpperCase() + status.slice(1)}
      </span>
      {hash && (
        <code className="tw-text-xs tw-text-iron-400 tw-font-mono">
          {hash.slice(0, 10)}...
        </code>
      )}
    </div>
  )
}
```

### Component Performance Optimization

**1. Memoized Components with TailwindCSS**
```tsx
import { memo, useMemo } from 'react'

const OptimizedCard = memo(function OptimizedCard({ 
  data, 
  variant = 'default' 
}: {
  data: CardData
  variant?: 'default' | 'compact' | 'featured'
}) {
  const className = useMemo(() => {
    const base = "tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-transition-all tw-duration-200"
    const variants = {
      default: "tw-p-6 tw-shadow-lg",
      compact: "tw-p-4 tw-shadow-md",
      featured: "tw-p-8 tw-shadow-xl tw-border-primary-500 tw-bg-gradient-to-br tw-from-iron-900 tw-to-iron-800"
    }
    return `${base} ${variants[variant]}`
  }, [variant])
  
  return (
    <div className={className}>
      {/* Component content */}
    </div>
  )
})
```

**2. Animation Performance**
```tsx
// ✅ GPU-accelerated animations
function AnimatedModal({ isOpen }: { isOpen: boolean }) {
  return (
    <div className={`
      tw-fixed tw-inset-0 tw-z-50 tw-flex tw-items-center tw-justify-center
      tw-transform tw-transition-all tw-duration-300 tw-ease-out
      ${isOpen 
        ? 'tw-opacity-100 tw-scale-100 tw-visible' 
        : 'tw-opacity-0 tw-scale-95 tw-invisible'
      }
    `}>
      {/* Modal content */}
    </div>
  )
}
```

### Mobile-Optimized Component Patterns

**1. Touch-Optimized Components**
```tsx
function MobileButton({ children, ...props }: {
  children: React.ReactNode
  [key: string]: any
}) {
  return (
    <button 
      {...props}
      className="tw-min-h-[44px] tw-min-w-[44px] tw-px-6 tw-py-3 tw-bg-primary-500 tw-text-white tw-rounded-lg tw-font-medium tw-touch-manipulation tw-transition-colors hover:tw-bg-primary-600 active:tw-scale-95"
    >
      {children}
    </button>
  )
}
```

**2. Safe Area Aware Components**
```tsx
function MobileLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-min-h-screen tw-bg-iron-950 tw-pt-[env(safe-area-inset-top,0px)] tw-pb-[env(safe-area-inset-bottom,0px)]">
      <header className="tw-px-[env(safe-area-inset-left,1rem)] tw-pr-[env(safe-area-inset-right,1rem)]">
        {/* Header content */}
      </header>
      <main className="tw-flex-1 tw-px-[env(safe-area-inset-left,1rem)] tw-pr-[env(safe-area-inset-right,1rem)]">
        {children}
      </main>
    </div>
  )
}
```

### Component Testing with TailwindCSS

**1. Testing TailwindCSS Classes**
```tsx
// Test responsive classes
it('applies responsive classes correctly', () => {
  render(<ResponsiveGrid />)
  const grid = screen.getByTestId('responsive-grid')
  
  expect(grid).toHaveClass('tw-grid-cols-1')
  expect(grid).toHaveClass('sm:tw-grid-cols-2')
  expect(grid).toHaveClass('lg:tw-grid-cols-3')
})

// Test variant classes
it('applies variant styles correctly', () => {
  render(<InteractiveButton variant="primary" />)
  const button = screen.getByRole('button')
  
  expect(button).toHaveClass('tw-bg-primary-500')
  expect(button).toHaveClass('tw-text-white')
})
```

**2. Visual Regression Testing**
```tsx
// Playwright test for visual consistency
test('component renders correctly across devices', async ({ page }) => {
  await page.goto('/component-showcase')
  
  // Test mobile view
  await page.setViewportSize({ width: 375, height: 812 })
  await expect(page.locator('[data-testid="mobile-component"]')).toBeVisible()
  
  // Test desktop view
  await page.setViewportSize({ width: 1920, height: 1080 })
  await expect(page.locator('[data-testid="desktop-component"]')).toBeVisible()
  
  // Test dark mode
  await page.locator('[data-testid="theme-toggle"]').click()
  await expect(page.locator('.dark')).toBeVisible()
})
```

---

**File splitting is essential for maintainability. Follow single responsibility principle and keep components focused on one clear purpose. ALL components must use TailwindCSS with tw- prefix.**