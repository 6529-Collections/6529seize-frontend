# Components Directory Context

## File Organization & Single Responsibility Guidelines

### Component Size Standards
- **Target Size**: 200-300 lines maximum per component
- **Warning Threshold**: 400+ lines requires review
- **Critical Threshold**: 500+ lines MUST be refactored
- **Emergency Threshold**: 700+ lines needs immediate splitting

### Current File Organization Patterns

#### Feature-Based Structure (Recommended)
```
components/
├── auth/                    # Authentication & authorization
│   ├── error-boundary/     # Well-organized error handling
│   └── SeizeConnectContext.tsx
├── waves/                  # Social features & wave management
│   ├── create/             # Wave creation workflow
│   ├── drop/               # Individual drop components  
│   ├── hooks/              # Wave-specific hooks
│   └── ChatItemHrefButtons.tsx
├── user/                   # User profile & settings
│   ├── brain/              # User dashboard
│   ├── collected/          # NFT collections
│   ├── settings/           # User preferences
│   └── layout/             # Profile layout components
└── utils/                  # Shared UI components
    ├── button/             # Button variants
    ├── input/              # Form inputs
    └── tooltip/            # Tooltips & popovers
```

### Single Responsibility Violation Indicators

#### 1. Component Description Uses "And"
```typescript
// ❌ Bad: Multiple responsibilities
function UserProfileAndSettingsAndNavigation() {
  // Manages user data AND handles settings AND controls navigation
}

// ✅ Good: Split responsibilities
function UserProfile() { /* User data display only */ }
function UserSettings() { /* Settings management only */ }
function UserNavigation() { /* Navigation logic only */ }
```

#### 2. Multiple useEffect Hooks with Different Concerns
```typescript
// ❌ Bad: Mixed concerns
function ComplexComponent() {
  useEffect(() => {
    // Fetch user data
  }, [userId])
  
  useEffect(() => {
    // Setup WebSocket connection
  }, [])
  
  useEffect(() => {
    // Handle window resize
  }, [])
  
  useEffect(() => {
    // Analytics tracking
  }, [pageView])
}

// ✅ Good: Extract custom hooks
function useUserData(userId) { /* User data effect */ }
function useWebSocket() { /* WebSocket effect */ }
function useWindowResize() { /* Resize effect */ }
function useAnalytics(pageView) { /* Analytics effect */ }

function ComplexComponent() {
  useUserData(userId)
  useWebSocket()
  useWindowResize()
  useAnalytics(pageView)
}
```

#### 3. State Management Complexity
```typescript
// ❌ Bad: Too many state variables
function OverloadedComponent() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  const [selectedItems, setSelectedItems] = useState([])
  const [modalOpen, setModalOpen] = useState(false)
  // ... 10+ more state variables
}

// ✅ Good: Group related state
function useUserListState() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  return { users, loading, error, setUsers, setLoading, setError }
}

function useFilterState() {
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  return { filters, sortBy, page, setFilters, setSortBy, setPage }
}
```

### Component Splitting Strategies

#### 1. Extract Sub-Components (UI Composition)
```typescript
// Before: Monolithic component
function UserDashboard() {
  return (
    <div className="dashboard">
      {/* 200 lines of header JSX */}
      {/* 300 lines of sidebar JSX */}
      {/* 400 lines of main content JSX */}
      {/* 200 lines of footer JSX */}
    </div>
  )
}

// After: Composed of focused components
function DashboardHeader() { /* Header-specific logic */ }
function DashboardSidebar() { /* Sidebar-specific logic */ }
function DashboardMain() { /* Main content logic */ }
function DashboardFooter() { /* Footer-specific logic */ }

function UserDashboard() {
  return (
    <div className="dashboard">
      <DashboardHeader />
      <DashboardSidebar />
      <DashboardMain />
      <DashboardFooter />
    </div>
  )
}
```

#### 2. Extract Business Logic (Custom Hooks)
```typescript
// Before: Mixed logic and presentation
function WavesList() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return <div>{/* 200+ lines of JSX */}</div>
}

// After: Separated concerns
function useWavesData() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return { waves, loading, refetch: fetchWaves }
}

function WavesList() {
  const { waves, loading, refetch } = useWavesData()
  
  if (loading) return <WavesListSkeleton />
  return <WavesListContent waves={waves} onRefresh={refetch} />
}
```

#### 3. Container/Presentation Pattern
```typescript
// Container: Handles data and state
function UserProfileContainer({ userId }: { userId: string }) {
  const { user, loading, error } = useUserData(userId)
  const { updateUser } = useUserMutations()
  
  return (
    <UserProfilePresentation
      user={user}
      loading={loading}
      error={error}
      onUpdate={updateUser}
    />
  )
}

// Presentation: Pure rendering logic
function UserProfilePresentation({ user, loading, error, onUpdate }) {
  if (loading) return <UserProfileSkeleton />
  if (error) return <UserProfileError error={error} />
  
  return (
    <div className="user-profile">
      <UserAvatar src={user.avatar} />
      <UserDetails user={user} />
      <UserActions onUpdate={onUpdate} />
    </div>
  )
}
```

### Component Testing Strategies for Split Components

#### Testing Composition
```typescript
// Test composed components
describe('UserDashboard', () => {
  it('renders all sections', () => {
    render(<UserDashboard />)
    expect(screen.getByTestId('dashboard-header')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-sidebar')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-main')).toBeInTheDocument()
  })
})

// Test individual components
describe('DashboardHeader', () => {
  it('displays user name', () => {
    render(<DashboardHeader user={mockUser} />)
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
  })
})
```

#### Testing Custom Hooks
```typescript
// Test business logic in isolation
describe('useWavesData', () => {
  it('fetches waves on mount', async () => {
    const { result } = renderHook(() => useWavesData())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.waves).toHaveLength(3)
    })
  })
})
```

### File Naming Conventions for Split Components

#### Hierarchical Naming
```
UserProfile/
├── index.ts                     # Re-exports main component
├── UserProfile.tsx              # Main component (container)
├── UserProfilePresentation.tsx  # Presentation component
├── UserProfileHeader.tsx        # Sub-component
├── UserProfileActions.tsx       # Action buttons
├── hooks/
│   ├── useUserData.ts          # Data fetching hook
│   └── useUserMutations.ts     # Mutation hook
├── types.ts                    # TypeScript interfaces
└── UserProfile.test.tsx        # Test file
```

#### Component Variants
```
Button/
├── Button.tsx           # Base button component
├── PrimaryButton.tsx    # Primary variant
├── SecondaryButton.tsx  # Secondary variant
├── IconButton.tsx       # Icon-only variant
└── types.ts            # Shared button types
```

### Performance Optimization for Split Components

#### Lazy Loading Sub-Components
```typescript
// Lazy load heavy sub-components
const HeavyChart = lazy(() => import('./HeavyChart'))
const DataTable = lazy(() => import('./DataTable'))

function Dashboard() {
  const [activeTab, setActiveTab] = useState('overview')
  
  return (
    <div>
      <DashboardTabs activeTab={activeTab} onChange={setActiveTab} />
      
      <Suspense fallback={<ComponentSkeleton />}>
        {activeTab === 'charts' && <HeavyChart />}
        {activeTab === 'data' && <DataTable />}
      </Suspense>
    </div>
  )
}
```

#### Memoization for Split Components
```typescript
// Memoize expensive sub-components
const ExpensiveSubComponent = memo(({ data, onAction }) => {
  const processedData = useMemo(() => {
    return expensiveCalculation(data)
  }, [data])
  
  return <div>{/* Render processed data */}</div>
})

// Use callback to prevent re-renders
function ParentComponent() {
  const [data, setData] = useState([])
  
  const handleAction = useCallback((action) => {
    // Handle action
  }, [])
  
  return (
    <ExpensiveSubComponent 
      data={data} 
      onAction={handleAction} 
    />
  )
}
```

### Component Organization Patterns

#### Feature-First Organization
```
waves/
├── create/                    # Wave creation feature
│   ├── CreateWaveForm.tsx    
│   ├── CreateWavePreview.tsx  
│   └── hooks/                 
├── list/                     # Wave listing feature
│   ├── WavesList.tsx         
│   ├── WaveItem.tsx          
│   └── filters/               
└── shared/                   # Shared wave components
    ├── WaveCard.tsx          
    └── WaveActions.tsx       
```

#### Size-Based Organization
```
components/
├── atoms/                    # Small, single-purpose (< 50 lines)
│   ├── Button.tsx           
│   ├── Input.tsx            
│   └── Icon.tsx             
├── molecules/                # Medium complexity (50-150 lines)
│   ├── SearchBox.tsx        
│   ├── UserCard.tsx         
│   └── NavigationItem.tsx   
├── organisms/                # Complex components (150-300 lines)
│   ├── Header.tsx           
│   ├── Sidebar.tsx          
│   └── UserProfile.tsx      
└── templates/                # Layout components
    ├── PageLayout.tsx       
    └── DashboardLayout.tsx  
```

### Critical Refactoring Targets

#### Immediate Priority (1000+ lines)
1. **CollectionDelegation.tsx** (1,984 lines)
   - Split into: DelegationForm, DelegationStatus, DelegationHistory
   - Extract: useDelegationData, useDelegationMutations
   - Create: DelegationProvider context

2. **ReactQueryWrapper.tsx** (1,268 lines)
   - Split into: QueryProvider, MutationProvider, DevTools
   - Extract: useQueryConfig, useErrorHandling
   - Separate: Client configuration from provider logic

3. **MemeLabPage.tsx** (1,249 lines)
   - Split into: LabFilters, LabGrid, LabPagination
   - Extract: useLabData, useLabFilters, useLabPagination
   - Create: LabProvider context

### Mobile-Specific Component Considerations

#### Responsive Component Variants
```typescript
// Desktop-specific components
function DesktopNavigation() { /* Desktop nav logic */ }

// Mobile-specific components  
function MobileNavigation() { /* Mobile nav logic */ }

// Adaptive component
function Navigation() {
  const isMobile = useIsMobileDevice()
  
  return isMobile ? <MobileNavigation /> : <DesktopNavigation />
}
```

#### Touch-Optimized Components
```typescript
function TouchOptimizedButton({ children, ...props }) {
  return (
    <button
      {...props}
      style={{
        minHeight: '44px', // Touch target size
        minWidth: '44px',
        ...props.style
      }}
    >
      {children}
    </button>
  )
}
```

### Error Boundary Patterns for Component Groups

#### Feature-Level Error Boundaries
```typescript
function WavesFeatureErrorBoundary({ children }) {
  return (
    <ErrorBoundary
      FallbackComponent={WavesErrorFallback}
      onError={(error) => logError('waves_feature', error)}
    >
      {children}
    </ErrorBoundary>
  )
}

function WavesPage() {
  return (
    <WavesFeatureErrorBoundary>
      <WavesList />
      <WaveCreator />
      <WaveFilters />
    </WavesFeatureErrorBoundary>
  )
}
```

---

**File splitting is essential for maintainability. Follow single responsibility principle and keep components focused on one clear purpose.**