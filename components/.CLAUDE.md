# Components Directory Context

## File Organization & Single Responsibility Guidelines

### Component Size Standards
- **Target Size**: 200-300 lines maximum per component
- **Warning Threshold**: 400+ lines requires review
- **Critical Threshold**: 500+ lines MUST be refactored
- **Emergency Threshold**: 700+ lines needs immediate splitting

### Current File Organization Patterns

#### Feature-Based Structure (Recommended)
```
components/
├── auth/                    # Authentication & authorization
│   ├── error-boundary/     # Well-organized error handling
│   └── SeizeConnectContext.tsx
├── waves/                  # Social features & wave management
│   ├── create/             # Wave creation workflow
│   ├── drop/               # Individual drop components  
│   ├── hooks/              # Wave-specific hooks
│   └── ChatItemHrefButtons.tsx
├── user/                   # User profile & settings
│   ├── brain/              # User dashboard
│   ├── collected/          # NFT collections
│   ├── settings/           # User preferences
│   └── layout/             # Profile layout components
└── utils/                  # Shared UI components
    ├── button/             # Button variants
    ├── input/              # Form inputs
    └── tooltip/            # Tooltips & popovers
```

### Single Responsibility Violation Indicators

#### 1. Component Description Uses "And"
```typescript
// ❌ Bad: Multiple responsibilities
function UserProfileAndSettingsAndNavigation() {
  // Manages user data AND handles settings AND controls navigation
}

// ✅ Good: Split responsibilities
function UserProfile() { /* User data display only */ }
function UserSettings() { /* Settings management only */ }
function UserNavigation() { /* Navigation logic only */ }
```

#### 2. Multiple useEffect Hooks with Different Concerns
```typescript
// ❌ Bad: Mixed concerns
function ComplexComponent() {
  useEffect(() => {
    // Fetch user data
  }, [userId])
  
  useEffect(() => {
    // Setup WebSocket connection
  }, [])
  
  useEffect(() => {
    // Handle window resize
  }, [])
  
  useEffect(() => {
    // Analytics tracking
  }, [pageView])
}

// ✅ Good: Extract custom hooks
function useUserData(userId) { /* User data effect */ }
function useWebSocket() { /* WebSocket effect */ }
function useWindowResize() { /* Resize effect */ }
function useAnalytics(pageView) { /* Analytics effect */ }

function ComplexComponent() {
  useUserData(userId)
  useWebSocket()
  useWindowResize()
  useAnalytics(pageView)
}
```

#### 3. State Management Complexity
```typescript
// ❌ Bad: Too many state variables
function OverloadedComponent() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  const [selectedItems, setSelectedItems] = useState([])
  const [modalOpen, setModalOpen] = useState(false)
  // ... 10+ more state variables
}

// ✅ Good: Group related state
function useUserListState() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  return { users, loading, error, setUsers, setLoading, setError }
}

function useFilterState() {
  const [filters, setFilters] = useState({})
  const [sortBy, setSortBy] = useState('name')
  const [page, setPage] = useState(1)
  return { filters, sortBy, page, setFilters, setSortBy, setPage }
}
```

### Component Splitting Strategies

#### 1. Extract Sub-Components (UI Composition)
```typescript
// Before: Monolithic component
function UserDashboard() {
  return (
    <div className="dashboard">
      {/* 200 lines of header JSX */}
      {/* 300 lines of sidebar JSX */}
      {/* 400 lines of main content JSX */}
      {/* 200 lines of footer JSX */}
    </div>
  )
}

// After: Composed of focused components
function DashboardHeader() { /* Header-specific logic */ }
function DashboardSidebar() { /* Sidebar-specific logic */ }
function DashboardMain() { /* Main content logic */ }
function DashboardFooter() { /* Footer-specific logic */ }

function UserDashboard() {
  return (
    <div className="dashboard">
      <DashboardHeader />
      <DashboardSidebar />
      <DashboardMain />
      <DashboardFooter />
    </div>
  )
}
```

#### 2. Extract Business Logic (Custom Hooks)
```typescript
// Before: Mixed logic and presentation
function WavesList() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return <div>{/* 200+ lines of JSX */}</div>
}

// After: Separated concerns
function useWavesData() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  
  const fetchWaves = async () => {
    setLoading(true)
    try {
      const response = await api.getWaves()
      setWaves(response.data)
    } catch (error) {
      console.error(error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchWaves()
  }, [])
  
  return { waves, loading, refetch: fetchWaves }
}

function WavesList() {
  const { waves, loading, refetch } = useWavesData()
  
  if (loading) return <WavesListSkeleton />
  return <WavesListContent waves={waves} onRefresh={refetch} />
}
```

#### 3. Container/Presentation Pattern
```typescript
// Container: Handles data and state
function UserProfileContainer({ userId }: { userId: string }) {
  const { user, loading, error } = useUserData(userId)
  const { updateUser } = useUserMutations()
  
  return (
    <UserProfilePresentation
      user={user}
      loading={loading}
      error={error}
      onUpdate={updateUser}
    />
  )
}

// Presentation: Pure rendering logic
function UserProfilePresentation({ user, loading, error, onUpdate }) {
  if (loading) return <UserProfileSkeleton />
  if (error) return <UserProfileError error={error} />
  
  return (
    <div className="user-profile">
      <UserAvatar src={user.avatar} />
      <UserDetails user={user} />
      <UserActions onUpdate={onUpdate} />
    </div>
  )
}
```

### Component Testing Strategies for Split Components

#### Testing Composition
```typescript
// Test composed components
describe('UserDashboard', () => {
  it('renders all sections', () => {
    render(<UserDashboard />)
    expect(screen.getByTestId('dashboard-header')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-sidebar')).toBeInTheDocument()
    expect(screen.getByTestId('dashboard-main')).toBeInTheDocument()
  })
})

// Test individual components
describe('DashboardHeader', () => {
  it('displays user name', () => {
    render(<DashboardHeader user={mockUser} />)
    expect(screen.getByText(mockUser.name)).toBeInTheDocument()
  })
})
```

#### Testing Custom Hooks
```typescript
// Test business logic in isolation
describe('useWavesData', () => {
  it('fetches waves on mount', async () => {
    const { result } = renderHook(() => useWavesData())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.waves).toHaveLength(3)
    })
  })
})
```

### File Naming Conventions for Split Components

#### Hierarchical Naming
```
UserProfile/
├── index.ts                     # Re-exports main component
├── UserProfile.tsx              # Main component (container)
├── UserProfilePresentation.tsx  # Presentation component
├── UserProfileHeader.tsx        # Sub-component
├── UserProfileActions.tsx       # Action buttons
├── hooks/
│   ├── useUserData.ts          # Data fetching hook
│   └── useUserMutations.ts     # Mutation hook
├── types.ts                    # TypeScript interfaces
└── UserProfile.test.tsx        # Test file
```

#### Component Variants
```
Button/
├── Button.tsx           # Base button component
├── PrimaryButton.tsx    # Primary variant
├── SecondaryButton.tsx  # Secondary variant
├── IconButton.tsx       # Icon-only variant
└── types.ts            # Shared button types
```

### Performance Optimization for Split Components

#### Lazy Loading Sub-Components
```typescript
// Lazy load heavy sub-components
const HeavyChart = lazy(() => import('./HeavyChart'))
const DataTable = lazy(() => import('./DataTable'))

function Dashboard() {
  const [activeTab, setActiveTab] = useState('overview')
  
  return (
    <div>
      <DashboardTabs activeTab={activeTab} onChange={setActiveTab} />
      
      <Suspense fallback={<ComponentSkeleton />}>
        {activeTab === 'charts' && <HeavyChart />}
        {activeTab === 'data' && <DataTable />}
      </Suspense>
    </div>
  )
}
```

#### Memoization for Split Components
```typescript
// Memoize expensive sub-components
const ExpensiveSubComponent = memo(({ data, onAction }) => {
  const processedData = useMemo(() => {
    return expensiveCalculation(data)
  }, [data])
  
  return <div>{/* Render processed data */}</div>
})

// Use callback to prevent re-renders
function ParentComponent() {
  const [data, setData] = useState([])
  
  const handleAction = useCallback((action) => {
    // Handle action
  }, [])
  
  return (
    <ExpensiveSubComponent 
      data={data} 
      onAction={handleAction} 
    />
  )
}
```

### Component Organization Patterns

#### Feature-First Organization
```
waves/
├── create/                    # Wave creation feature
│   ├── CreateWaveForm.tsx    
│   ├── CreateWavePreview.tsx  
│   └── hooks/                 
├── list/                     # Wave listing feature
│   ├── WavesList.tsx         
│   ├── WaveItem.tsx          
│   └── filters/               
└── shared/                   # Shared wave components
    ├── WaveCard.tsx          
    └── WaveActions.tsx       
```

#### Size-Based Organization
```
components/
├── atoms/                    # Small, single-purpose (< 50 lines)
│   ├── Button.tsx           
│   ├── Input.tsx            
│   └── Icon.tsx             
├── molecules/                # Medium complexity (50-150 lines)
│   ├── SearchBox.tsx        
│   ├── UserCard.tsx         
│   └── NavigationItem.tsx   
├── organisms/                # Complex components (150-300 lines)
│   ├── Header.tsx           
│   ├── Sidebar.tsx          
│   └── UserProfile.tsx      
└── templates/                # Layout components
    ├── PageLayout.tsx       
    └── DashboardLayout.tsx  
```

### Critical Refactoring Targets

#### Immediate Priority (1000+ lines)
1. **CollectionDelegation.tsx** (1,984 lines)
   - Split into: DelegationForm, DelegationStatus, DelegationHistory
   - Extract: useDelegationData, useDelegationMutations
   - Create: DelegationProvider context

2. **ReactQueryWrapper.tsx** (1,268 lines)
   - Split into: QueryProvider, MutationProvider, DevTools
   - Extract: useQueryConfig, useErrorHandling
   - Separate: Client configuration from provider logic

3. **MemeLabPage.tsx** (1,249 lines)
   - Split into: LabFilters, LabGrid, LabPagination
   - Extract: useLabData, useLabFilters, useLabPagination
   - Create: LabProvider context

### Mobile-Specific Component Considerations

#### Responsive Component Variants
```typescript
// Desktop-specific components
function DesktopNavigation() { /* Desktop nav logic */ }

// Mobile-specific components  
function MobileNavigation() { /* Mobile nav logic */ }

// Adaptive component
function Navigation() {
  const isMobile = useIsMobileDevice()
  
  return isMobile ? <MobileNavigation /> : <DesktopNavigation />
}
```

#### Touch-Optimized Components
```typescript
function TouchOptimizedButton({ children, ...props }) {
  return (
    <button
      {...props}
      style={{
        minHeight: '44px', // Touch target size
        minWidth: '44px',
        ...props.style
      }}
    >
      {children}
    </button>
  )
}
```

### Error Boundary Patterns for Component Groups

#### Feature-Level Error Boundaries
```typescript
function WavesFeatureErrorBoundary({ children }) {
  return (
    <ErrorBoundary
      FallbackComponent={WavesErrorFallback}
      onError={(error) => logError('waves_feature', error)}
    >
      {children}
    </ErrorBoundary>
  )
}

function WavesPage() {
  return (
    <WavesFeatureErrorBoundary>
      <WavesList />
      <WaveCreator />
      <WaveFilters />
    </WavesFeatureErrorBoundary>
  )
}
```

## TailwindCSS Component Styling Guidelines

### **MANDATORY: All Components Must Use TailwindCSS with tw- Prefix**

#### Component-Level TailwindCSS Patterns

**1. Component Wrapper Patterns**
```tsx
// ✅ CORRECT: Standard component wrapper with TailwindCSS
function UserProfileCard({ user }: { user: User }) {
  return (
    <div className="tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-p-6 tw-shadow-lg">
      <div className="tw-flex tw-items-center tw-gap-4">
        <img 
          className="tw-w-12 tw-h-12 tw-rounded-full tw-ring-2 tw-ring-primary-500" 
          src={user.avatar} 
          alt={user.name}
        />
        <div className="tw-flex-1">
          <h3 className="tw-text-lg tw-font-semibold tw-text-iron-50">{user.name}</h3>
          <p className="tw-text-iron-300">{user.email}</p>
        </div>
      </div>
    </div>
  )
}

// ❌ INCORRECT: Bootstrap/non-prefixed classes
<div className="card p-3">
<div className="d-flex align-items-center">
```

**2. Responsive Component Layouts**
```tsx
// ✅ Mobile-first responsive patterns
function ResponsiveGrid({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 lg:tw-grid-cols-3 tw-3xl:tw-grid-cols-4 tw-gap-6">
      {children}
    </div>
  )
}

// ✅ Container query responsive components
function AdaptiveCard({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-@container tw-w-full">
      <div className="tw-flex tw-flex-col @md:tw-flex-row tw-gap-4">
        {children}
      </div>
    </div>
  )
}
```

**3. State-Based Component Styling**
```tsx
// ✅ Component state styling patterns
function InteractiveButton({ 
  variant = 'primary', 
  loading = false, 
  disabled = false,
  children 
}: {
  variant?: 'primary' | 'secondary' | 'danger'
  loading?: boolean
  disabled?: boolean
  children: React.ReactNode
}) {
  const baseClasses = "tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-transition-all tw-duration-200 tw-transform"
  
  const variantClasses = {
    primary: "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600 active:tw-scale-95",
    secondary: "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500 active:tw-scale-95",
    danger: "tw-bg-red-600 tw-text-white hover:tw-bg-red-700 active:tw-scale-95"
  }
  
  const stateClasses = {
    loading: "tw-cursor-wait tw-opacity-75",
    disabled: "tw-cursor-not-allowed tw-opacity-50 hover:tw-transform-none"
  }
  
  const className = [
    baseClasses,
    variantClasses[variant],
    loading && stateClasses.loading,
    disabled && stateClasses.disabled
  ].filter(Boolean).join(' ')
  
  return (
    <button className={className} disabled={disabled || loading}>
      {loading && <div className="tw-w-4 tw-h-4 tw-border-2 tw-border-white tw-border-t-transparent tw-rounded-full tw-animate-spin tw-mr-2 tw-inline-block" />}
      {children}
    </button>
  )
}
```

### Headless UI + TailwindCSS Component Integration

**1. Modal/Dialog Components**
```tsx
import { Dialog, DialogPanel, DialogTitle } from '@headlessui/react'

function Modal({ open, onClose, title, children }: {
  open: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
}) {
  return (
    <Dialog 
      open={open} 
      onClose={onClose} 
      className="tw-relative tw-z-50"
    >
      {/* Backdrop */}
      <div className="tw-fixed tw-inset-0 tw-bg-black/30 tw-backdrop-blur-sm" />
      
      {/* Container */}
      <div className="tw-fixed tw-inset-0 tw-flex tw-items-center tw-justify-center tw-p-4">
        <DialogPanel className="tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-xl tw-max-w-md tw-w-full tw-p-6">
          <DialogTitle className="tw-text-lg tw-font-semibold tw-text-iron-50 tw-mb-4">
            {title}
          </DialogTitle>
          {children}
        </DialogPanel>
      </div>
    </Dialog>
  )
}
```

**2. Dropdown/Menu Components**
```tsx
import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/react'

function DropdownMenu({ trigger, items }: {
  trigger: React.ReactNode
  items: Array<{ label: string; onClick: () => void; icon?: React.ComponentType }>
}) {
  return (
    <Menu className="tw-relative">
      <MenuButton className="tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-px-3 tw-py-2 tw-text-iron-50 hover:tw-bg-iron-700 tw-transition-colors">
        {trigger}
      </MenuButton>
      
      <MenuItems className="tw-absolute tw-right-0 tw-mt-2 tw-w-48 tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-lg tw-z-10">
        {items.map((item, index) => (
          <MenuItem key={index}>
            {({ focus }) => (
              <button
                onClick={item.onClick}
                className={`tw-w-full tw-px-4 tw-py-2 tw-text-left tw-flex tw-items-center tw-gap-2 tw-transition-colors ${
                  focus 
                    ? 'tw-bg-primary-500 tw-text-white' 
                    : 'tw-text-iron-300 hover:tw-text-iron-50'
                }`}
              >
                {item.icon && <item.icon className="tw-w-4 tw-h-4" />}
                {item.label}
              </button>
            )}
          </MenuItem>
        ))}
      </MenuItems>
    </Menu>
  )
}
```

**3. Form Components with TailwindCSS**
```tsx
import { Field, Label, Input, Description } from '@headlessui/react'

function FormInput({
  label,
  description,
  error,
  ...inputProps
}: {
  label: string
  description?: string
  error?: string
  [key: string]: any
}) {
  return (
    <Field className="tw-space-y-2">
      <Label className="tw-block tw-text-sm tw-font-medium tw-text-iron-50">
        {label}
      </Label>
      
      <Input 
        className={`tw-w-full tw-px-3 tw-py-2 tw-bg-iron-800 tw-border tw-rounded-lg tw-text-iron-50 tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-offset-2 focus:tw-ring-offset-iron-900 ${
          error 
            ? 'tw-border-red-500 focus:tw-ring-red-500' 
            : 'tw-border-iron-600 focus:tw-border-primary-500 focus:tw-ring-primary-500'
        }`}
        {...inputProps}
      />
      
      {description && (
        <Description className="tw-text-sm tw-text-iron-400">
          {description}
        </Description>
      )}
      
      {error && (
        <p className="tw-text-sm tw-text-red-400 tw-mt-1">{error}</p>
      )}
    </Field>
  )
}
```

### Web3-Specific Component Patterns

**1. Wallet Connection Components**
```tsx
function WalletConnectButton({ 
  connected, 
  address, 
  onConnect, 
  onDisconnect 
}: {
  connected: boolean
  address?: string
  onConnect: () => void
  onDisconnect: () => void
}) {
  if (connected && address) {
    return (
      <button 
        onClick={onDisconnect}
        className="tw-bg-success tw-text-white tw-px-4 tw-py-2 tw-rounded-lg tw-font-medium tw-flex tw-items-center tw-gap-2 hover:tw-bg-green tw-transition-colors"
      >
        <div className="tw-w-2 tw-h-2 tw-bg-white tw-rounded-full tw-animate-pulse" />
        {address.slice(0, 6)}...{address.slice(-4)}
      </button>
    )
  }
  
  return (
    <button 
      onClick={onConnect}
      className="tw-bg-primary-500 tw-text-white tw-px-6 tw-py-2 tw-rounded-lg tw-font-medium hover:tw-bg-primary-600 tw-transition-colors"
    >
      Connect Wallet
    </button>
  )
}
```

**2. Transaction Status Components**
```tsx
function TransactionStatus({ 
  status, 
  hash 
}: { 
  status: 'pending' | 'confirmed' | 'failed'
  hash?: string 
}) {
  const statusConfig = {
    pending: {
      color: 'tw-text-yellow-400',
      bg: 'tw-bg-yellow-400/10',
      icon: 'tw-animate-spin'
    },
    confirmed: {
      color: 'tw-text-green-400',
      bg: 'tw-bg-green-400/10',
      icon: ''
    },
    failed: {
      color: 'tw-text-red-400',
      bg: 'tw-bg-red-400/10',
      icon: ''
    }
  }
  
  const config = statusConfig[status]
  
  return (
    <div className={`tw-flex tw-items-center tw-gap-2 tw-px-3 tw-py-2 tw-rounded-lg ${config.bg}`}>
      <div className={`tw-w-2 tw-h-2 tw-rounded-full ${config.color} ${config.icon}`} />
      <span className={`tw-text-sm tw-font-medium ${config.color}`}>
        {status.charAt(0).toUpperCase() + status.slice(1)}
      </span>
      {hash && (
        <code className="tw-text-xs tw-text-iron-400 tw-font-mono">
          {hash.slice(0, 10)}...
        </code>
      )}
    </div>
  )
}
```

### Component Performance Optimization

**1. Memoized Components with TailwindCSS**
```tsx
import { memo, useMemo } from 'react'

const OptimizedCard = memo(function OptimizedCard({ 
  data, 
  variant = 'default' 
}: {
  data: CardData
  variant?: 'default' | 'compact' | 'featured'
}) {
  const className = useMemo(() => {
    const base = "tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-transition-all tw-duration-200"
    const variants = {
      default: "tw-p-6 tw-shadow-lg",
      compact: "tw-p-4 tw-shadow-md",
      featured: "tw-p-8 tw-shadow-xl tw-border-primary-500 tw-bg-gradient-to-br tw-from-iron-900 tw-to-iron-800"
    }
    return `${base} ${variants[variant]}`
  }, [variant])
  
  return (
    <div className={className}>
      {/* Component content */}
    </div>
  )
})
```

**2. Animation Performance**
```tsx
// ✅ GPU-accelerated animations
function AnimatedModal({ isOpen }: { isOpen: boolean }) {
  return (
    <div className={`
      tw-fixed tw-inset-0 tw-z-50 tw-flex tw-items-center tw-justify-center
      tw-transform tw-transition-all tw-duration-300 tw-ease-out
      ${isOpen 
        ? 'tw-opacity-100 tw-scale-100 tw-visible' 
        : 'tw-opacity-0 tw-scale-95 tw-invisible'
      }
    `}>
      {/* Modal content */}
    </div>
  )
}
```

### Mobile-Optimized Component Patterns

**1. Touch-Optimized Components**
```tsx
function MobileButton({ children, ...props }: {
  children: React.ReactNode
  [key: string]: any
}) {
  return (
    <button 
      {...props}
      className="tw-min-h-[44px] tw-min-w-[44px] tw-px-6 tw-py-3 tw-bg-primary-500 tw-text-white tw-rounded-lg tw-font-medium tw-touch-manipulation tw-transition-colors hover:tw-bg-primary-600 active:tw-scale-95"
    >
      {children}
    </button>
  )
}
```

**2. Safe Area Aware Components**
```tsx
function MobileLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="tw-min-h-screen tw-bg-iron-950 tw-pt-[env(safe-area-inset-top,0px)] tw-pb-[env(safe-area-inset-bottom,0px)]">
      <header className="tw-px-[env(safe-area-inset-left,1rem)] tw-pr-[env(safe-area-inset-right,1rem)]">
        {/* Header content */}
      </header>
      <main className="tw-flex-1 tw-px-[env(safe-area-inset-left,1rem)] tw-pr-[env(safe-area-inset-right,1rem)]">
        {children}
      </main>
    </div>
  )
}
```

### Component Testing with TailwindCSS

**1. Testing TailwindCSS Classes**
```tsx
// Test responsive classes
it('applies responsive classes correctly', () => {
  render(<ResponsiveGrid />)
  const grid = screen.getByTestId('responsive-grid')
  
  expect(grid).toHaveClass('tw-grid-cols-1')
  expect(grid).toHaveClass('sm:tw-grid-cols-2')
  expect(grid).toHaveClass('lg:tw-grid-cols-3')
})

// Test variant classes
it('applies variant styles correctly', () => {
  render(<InteractiveButton variant="primary" />)
  const button = screen.getByRole('button')
  
  expect(button).toHaveClass('tw-bg-primary-500')
  expect(button).toHaveClass('tw-text-white')
})
```

**2. Visual Regression Testing**
```tsx
// Playwright test for visual consistency
test('component renders correctly across devices', async ({ page }) => {
  await page.goto('/component-showcase')
  
  // Test mobile view
  await page.setViewportSize({ width: 375, height: 812 })
  await expect(page.locator('[data-testid="mobile-component"]')).toBeVisible()
  
  // Test desktop view
  await page.setViewportSize({ width: 1920, height: 1080 })
  await expect(page.locator('[data-testid="desktop-component"]')).toBeVisible()
  
  // Test dark mode
  await page.locator('[data-testid="theme-toggle"]').click()
  await expect(page.locator('.dark')).toBeVisible()
})
```

---

**File splitting is essential for maintainability. Follow single responsibility principle and keep components focused on one clear purpose. ALL components must use TailwindCSS with tw- prefix.**