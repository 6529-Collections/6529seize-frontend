"use client";

import XTDHCard from "../ui/XTDHCard";
import type { Summary } from "../types";
import XTDHHeaderStats from "../header/XTDHHeaderStats";
import { useXtdhSummary } from "@/hooks/useXtdh";
import type { ApiIdentity } from "@/generated/models/ApiIdentity";

export default function XTDHOverview({
  profile,
  onGoGive,
  onGoReceive,
}: {
  readonly profile: ApiIdentity;
  readonly onGoGive: () => void;
  readonly onGoReceive: () => void;
}) {
  const { data: summary } = useXtdhSummary(
    typeof profile?.tdh_rate === "number" ? profile.tdh_rate : null,
  );
  return (
    <div className="tw-flex tw-flex-col tw-gap-4">
      <XTDHHeaderStats summary={
        summary ?? {
          baseRatePerDay: null,
          multiplier: null,
          xtdhRatePerDay: null,
          totalRatePerDay: null,
          allocatedRatePerDay: null,
          incomingRatePerDay: null,
        }
      } />

      <NextActions summary={summary ?? {
        baseRatePerDay: null,
        multiplier: null,
        xtdhRatePerDay: null,
        totalRatePerDay: null,
        allocatedRatePerDay: null,
        incomingRatePerDay: null,
      }} onGoGive={onGoGive} onGoReceive={onGoReceive} />

      <XTDHCard title="What is xTDH?">
        <div className="tw-text-iron-300 tw-text-sm tw-space-y-2">
          <p>
            Base TDH is generated by Memes & Gradients and is predictable. xTDH is a multiplier-based
            capacity you can allocate to external targets.
          </p>
          <p>
            Allocating xTDH reduces your own accrual; totals remain capped by Base TDH. Grants are
            reversible and adjust pro‑rata if your Base TDH changes.
          </p>
        </div>
      </XTDHCard>
    </div>
  );
}

function NextActions({
  summary,
  onGoGive,
  onGoReceive,
}: {
  readonly summary: Summary;
  readonly onGoGive: () => void;
  readonly onGoReceive: () => void;
}) {
  const base = numberOrZero(summary.baseRatePerDay);
  const multiplier = summary.multiplier ?? 0;
  const capacity = base * multiplier;
  const given = Math.max(0, numberOrZero(summary.allocatedRatePerDay));
  const external = Math.max(0, numberOrZero(summary.incomingRatePerDay));
  const kept = Math.max(0, capacity - given);
  const givenPct = capacity > 0 ? Math.round((given / capacity) * 100) : 0;
  const keptPct = capacity > 0 ? Math.round((kept / capacity) * 100) : 0;

  const suggestions: { text: string; action?: () => void; label?: string }[] = [];

  if (capacity === 0) {
    suggestions.push({ text: "No xTDH capacity yet (Base × Multiplier is 0)." });
  } else if (given === 0) {
    suggestions.push({ text: "You’re keeping all your xTDH." });
    suggestions.push({ text: "Allocate some to support a collection", action: onGoGive, label: "Go to Give" });
  } else if (given > capacity) {
    suggestions.push({ text: "Over capacity — pro‑rata reduction next cycle."
    });
    suggestions.push({ text: "Review and fix allocations", action: onGoGive, label: "Manage grants" });
  } else {
    if (givenPct <= 20) {
      suggestions.push({ text: `You’re keeping most of your xTDH (${keptPct}%).` });
      suggestions.push({ text: "Spotlight a collection with a small grant", action: onGoGive, label: "Give xTDH" });
    } else if (givenPct <= 80) {
      suggestions.push({ text: `You’re giving ${givenPct}% and keeping ${keptPct}%.` });
      suggestions.push({ text: "Adjust split or add targets", action: onGoGive, label: "Manage grants" });
    } else {
      suggestions.push({ text: `You’re giving most of your xTDH (${givenPct}%).` });
      suggestions.push({ text: "Ensure this matches your intent", action: onGoGive, label: "Review grants" });
    }
  }

  if (external === 0) {
    suggestions.push({ text: "Not receiving xTDH from others." });
    suggestions.push({ text: "Discover sources", action: onGoReceive, label: "View incoming" });
  } else {
    suggestions.push({ text: `Receiving ${Math.floor(external)}/day from others.` });
    suggestions.push({ text: "Review sources", action: onGoReceive, label: "View incoming" });
  }

  // Deduplicate consecutive entries describing state vs action
  const items = collapsePairs(suggestions);

  return (
    <XTDHCard title="Next actions">
      <ul className="tw-list-disc tw-pl-5 tw-text-sm tw-text-iron-300 tw-space-y-1">
        {items.map((it, idx) => (
          <li key={idx}>
            <span>{it.text}</span>
            {it.action ? (
              <button
                onClick={it.action}
                className="tw-ml-2 tw-text-primary-400 hover:tw-underline tw-font-medium"
              >
                {it.label ?? "Open"}
              </button>
            ) : null}
          </li>
        ))}
      </ul>
    </XTDHCard>
  );
}

function numberOrZero(n: number | null): number {
  return typeof n === "number" && !Number.isNaN(n) ? n : 0;
}

function collapsePairs(arr: { text: string; action?: () => void; label?: string }[]) {
  // Keep order; merge duplicates if needed in future. For now, return as-is.
  return arr;
}
