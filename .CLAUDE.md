# 6529 Seize Frontend Context

## Bash Commands
- npm run dev: Starts development server with Turbopack on port 3001
- npm run build: Builds the application for production (no lint)
- npm run build:lint: Builds the application with linting
- npm run test: Runs Jest test suite in silent mode
- npm run test:cov: Runs tests with coverage reporting
- npm run test:e2e: Runs Playwright end-to-end tests
- npm run lint: Runs ESLint on the codebase
- npm run lint:fix: Runs ESLint with auto-fix
- npm run type-check: Runs TypeScript compiler checks
- npm run knip: Removes unused code and files with Knip
- npm run generate: Generates TypeScript types from OpenAPI schema
- npm run improve-coverage: Runs coverage improvement script

## File Organization Guidelines & Single Responsibility Principles

### Component Size Limits & Split Indicators
**CRITICAL THRESHOLDS:**
- **200-300 lines**: Recommended maximum for React components
- **500+ lines**: Requires immediate review and consideration for splitting
- **700+ lines**: MUST be refactored into smaller components

**Components Currently Exceeding Limits (Need Refactoring):**
- `components/delegation/CollectionDelegation.tsx` (1,984 lines) - URGENT
- `components/react-query-wrapper/ReactQueryWrapper.tsx` (1,268 lines) - URGENT
- `components/memelab/MemeLabPage.tsx` (1,249 lines) - URGENT
- `components/waves/CreateDropContent.tsx` (1,080 lines) - URGENT
- `components/header/Header.tsx` (1,027 lines) - URGENT
- `components/nextGen/admin/NextGenAdmin.tsx` (983 lines) - HIGH PRIORITY

### Single Responsibility Split Indicators
**When to Split Components:**
1. **"And" Rule**: If component description uses "and", it has multiple responsibilities
2. **Multiple useEffect Hooks**: Different effects often indicate different concerns
3. **Mixed Concerns Pattern**: Data fetching + display + business logic in one component
4. **State Management Complexity**: More than 5-7 useState calls
5. **Event Handler Proliferation**: More than 10 event handlers
6. **Conditional Rendering Complexity**: Multiple nested ternary operators

### File Organization Structure

#### Feature-Based Organization (Current Pattern)
```
components/
├── auth/                     # Authentication-related components
│   ├── error-boundary/      # Error handling (well-organized)
│   └── SeizeConnectContext.tsx
├── waves/                   # Wave/social features
│   ├── create/              # Wave creation components
│   ├── drop/                # Individual drop components
│   └── hooks/               # Wave-specific custom hooks
├── user/                    # User profile components
│   ├── brain/               # User dashboard
│   ├── collected/           # User's NFT collection
│   └── settings/            # User preferences
└── utils/                   # Shared utility components
```

#### Component Splitting Strategies

**1. Extract Sub-Components (Composition Pattern)**
```typescript
// ❌ Bad: Monolithic component
function ComplexComponent() {
  // 500+ lines of mixed logic
  return (
    <div>
      {/* header logic */}
      {/* form logic */}
      {/* data display logic */}
    </div>
  )
}

// ✅ Good: Split into focused components
function ComplexComponentHeader() { /* header-specific logic */ }
function ComplexComponentForm() { /* form-specific logic */ }
function ComplexComponentDisplay() { /* display-specific logic */ }

function ComplexComponent() {
  return (
    <div>
      <ComplexComponentHeader />
      <ComplexComponentForm />
      <ComplexComponentDisplay />
    </div>
  )
}
```

**2. Extract Custom Hooks (Logic Separation)**
```typescript
// ❌ Bad: Business logic mixed with rendering
function WaveComponent() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  // 50+ lines of data fetching logic
  
  return <div>{/* rendering logic */}</div>
}

// ✅ Good: Extract custom hooks
function useWaveData() {
  // All data fetching logic here
  return { waves, loading, refetch }
}

function WaveComponent() {
  const { waves, loading, refetch } = useWaveData()
  return <div>{/* pure rendering logic */}</div>
}
```

**3. Separate Container and Presentation (Smart/Dumb Pattern)**
```typescript
// ❌ Bad: Data fetching mixed with presentation
function UserProfile() {
  // API calls, state management, AND rendering
}

// ✅ Good: Separate concerns
function UserProfileContainer() {
  // Data fetching and state management only
  const userData = useUserData()
  return <UserProfilePresentation data={userData} />
}

function UserProfilePresentation({ data }) {
  // Pure presentation logic only
}
```

### Performance-Focused File Organization

#### Code Splitting Strategies
1. **Route-Based Splitting**: Lazy load page-level components
```typescript
// Use React.lazy for page components
const MemeLabPage = lazy(() => import('./components/memelab/MemeLabPage'))
const WavesPage = lazy(() => import('./components/waves/WavesPage'))
```

2. **Feature-Based Splitting**: Split large feature modules
```typescript
// Split complex features into separate bundles
const AdminPanel = lazy(() => import('./components/nextGen/admin/NextGenAdmin'))
```

3. **Conditional Component Loading**: Load components only when needed
```typescript
// Load heavy components conditionally
const HeavyChart = lazy(() => import('./components/charts/HeavyChart'))

function Dashboard() {
  const [showChart, setShowChart] = useState(false)
  return (
    <div>
      {showChart && (
        <Suspense fallback={<div>Loading...</div>}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  )
}
```

### State Management Across Split Components

#### Context Pattern for Related Components
```typescript
// Create context for component families
const WaveContext = createContext()

function WaveProvider({ children }) {
  const [waveState, setWaveState] = useState()
  return (
    <WaveContext.Provider value={{ waveState, setWaveState }}>
      {children}
    </WaveContext.Provider>
  )
}
```

#### Shared State Hooks
```typescript
// Custom hooks for shared state
function useSharedWaveState() {
  const context = useContext(WaveContext)
  if (!context) throw new Error('Must be used within WaveProvider')
  return context
}
```

## Key Dependencies & Documentation

### React (v19.1.0)
- **Source**: React.dev official documentation
- **Best Practices**: Function components with hooks, avoid class components
- **Component Patterns**: Composition over inheritance, single responsibility
- **Hook Rules**: Always at top level, consistent dependency arrays
- **Migration Notes**: Update any remaining class components to function components

### Next.js (v15.3.5)
- **Source**: Next.js documentation
- **Router**: App Router (preferred over Pages Router)
- **File Organization**: App directory structure with colocation support
- **Performance**: Built-in optimizations, automatic code splitting
- **Migration Notes**: Migrate remaining pages/* routes to app/* directory

### @reown/appkit (v1.7.17)
- **Source**: Reown AppKit documentation
- **Security Patterns**: SIWX authentication, secure wallet connections
- **Integration**: Web3 wallet management with mobile support
- **Best Practices**: Environment-based configuration, error boundaries

### wagmi (v2.15.6)
- **Source**: Wagmi.sh documentation
- **Hook Patterns**: Reactive Web3 data fetching, optimistic updates
- **Performance**: Built-in caching, structural sharing
- **Best Practices**: Use scopeKey for cache management, avoid prop drilling hooks

### TypeScript (v5.8.3)
- **Source**: TypeScript documentation
- **Patterns**: Strict type checking, interface-based design
- **File Organization**: Co-locate types with components
- **Best Practices**: Use discriminated unions, avoid `any` type

## Code Style & Best Practices

### React Component Patterns
- **Function Components**: Use exclusively, avoid class components except for error boundaries
- **Hook Dependencies**: Always include in dependency arrays, use ESLint rules
- **Props Interface**: Define TypeScript interfaces for all props
- **Default Props**: Use default parameters instead of defaultProps
- **Ref Patterns**: Use useRef for DOM manipulation, forwardRef for component refs

### File Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Hooks**: camelCase starting with "use" (e.g., `useWaveData.ts`)
- **Utils**: camelCase (e.g., `formatCurrency.ts`)
- **Types**: PascalCase interfaces/types (e.g., `UserProfileTypes.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)

### Import/Export Patterns
- **Named Exports**: Preferred for utilities and hooks
- **Default Exports**: Use for main component in file
- **Index Files**: Create for clean directory imports
- **Relative Imports**: Use for local files, absolute for shared utilities

### Error Handling Patterns
- **Error Boundaries**: Wrap feature areas, provide recovery actions
- **Async Error Handling**: Use try-catch with proper user feedback
- **Form Validation**: Client-side validation with server-side verification
- **Network Errors**: Retry mechanisms with exponential backoff

## Testing Strategy

### Component Testing (Jest + React Testing Library)
- **Focus**: User interactions and component behavior
- **Patterns**: Test props variations, user events, accessibility
- **Mocking**: Mock external dependencies, API calls
- **Coverage**: Aim for >80% on critical user paths

### Integration Testing (Playwright)
- **Focus**: End-to-end user workflows
- **Critical Paths**: Authentication, wallet connection, core features
- **Performance**: Page load times, interaction responsiveness
- **Cross-browser**: Test on Chromium, Firefox, Safari

### Hook Testing
- **Custom Hooks**: Test in isolation with @testing-library/react-hooks
- **State Management**: Verify state transitions and side effects
- **Error Scenarios**: Test error handling and recovery

## Project Structure

### Root Level Directories
- `app/`: Next.js App Router pages and layouts
- `components/`: Reusable React components organized by feature
- `src/`: Core utilities, types, and business logic
- `hooks/`: Custom React hooks for shared logic
- `services/`: API integration and external service clients
- `utils/`: Pure utility functions and helpers
- `types/`: TypeScript type definitions
- `__tests__/`: Test files mirroring source structure

### Component Organization Hierarchy
```
components/
├── Layout Components (header, footer, navigation)
├── Feature Components (auth, waves, user, trading)
│   ├── Container Components (data fetching, state management)
│   ├── Presentation Components (pure rendering)
│   └── Shared Sub-components
└── Utility Components (buttons, forms, modals)
```

### Critical File Organization Rules
1. **One Component Per File**: Each component gets its own file
2. **Co-locate Related Files**: Keep components, styles, tests together
3. **Separate Concerns**: Split data logic from presentation logic
4. **Consistent Naming**: Use clear, descriptive names that indicate purpose
5. **Index Files**: Use for clean imports in component directories

## Mobile-First Development Considerations

### Responsive Design Patterns
- **Breakpoint Strategy**: Mobile-first with progressive enhancement
- **Component Variants**: Create mobile-specific variants for complex components
- **Touch Interactions**: Optimize for touch targets and gestures
- **Performance**: Lazy load non-critical components on mobile

### Capacitor Integration
- **Native Features**: Camera, file system, push notifications
- **Platform Detection**: Conditional rendering for native vs web
- **Performance**: Minimize bundle size for mobile app builds

## Security & Authentication

### Web3 Security Patterns
- **Wallet Connection**: Secure connection handling with error recovery
- **Transaction Signing**: User confirmation flows, gas estimation
- **Data Sanitization**: Input validation and output encoding
- **Error Handling**: Secure error messages without sensitive data exposure

### Authentication Flow
- **SIWX Integration**: Sign-in with X for social authentication
- **JWT Management**: Secure token storage and refresh patterns
- **Session Handling**: Proper cleanup on logout/disconnect

## Performance Optimization

### Bundle Optimization
- **Code Splitting**: Route-based and feature-based splitting
- **Tree Shaking**: Remove unused code with proper ES modules
- **Bundle Analysis**: Regular analysis with @next/bundle-analyzer
- **Dynamic Imports**: Lazy load heavy components and libraries

### Runtime Performance
- **React Optimization**: useMemo, useCallback for expensive operations
- **Virtual Scrolling**: For large lists (waves, NFT collections)
- **Image Optimization**: Next.js Image component with proper sizing
- **Caching Strategy**: Service worker for offline support

## Development Workflow

### Branch Strategy
- **Feature Branches**: Create from main for new features
- **Mobile Branch**: Current mobile-4 branch for mobile-specific work
- **Code Review**: Required for all changes to main branch
- **Testing**: All tests must pass before merge

### Commit Conventions
- **Format**: Conventional commits (feat:, fix:, refactor:, etc.)
- **Scope**: Include component/feature scope when relevant
- **Breaking Changes**: Document any breaking changes clearly

## Environment Setup

### Required Tools
- **Node.js**: Version specified in package.json engines
- **Package Manager**: npm (package-lock.json present)
- **IDE**: VS Code with TypeScript and ESLint extensions recommended

### Environment Variables
- **NEXT_PUBLIC_PROJECT_ID**: Reown/WalletConnect project ID
- **NEXTAUTH_SECRET**: NextAuth.js secret for session encryption
- **API Endpoints**: Configure for development/production environments

### Development Dependencies
- **ESLint**: Code quality and style enforcement
- **Prettier**: Code formatting (if configured)
- **TypeScript**: Type checking and IntelliSense
- **Jest**: Unit testing framework
- **Playwright**: End-to-end testing

## Refactoring Priority List

### Immediate Actions Required (700+ lines)
1. **CollectionDelegation.tsx** (1,984 lines) - Split into delegation flow components
2. **ReactQueryWrapper.tsx** (1,268 lines) - Extract provider setup logic
3. **MemeLabPage.tsx** (1,249 lines) - Split into lab sections and filters
4. **CreateDropContent.tsx** (1,080 lines) - Extract form sections and validation
5. **Header.tsx** (1,027 lines) - Split navigation, user menu, and mobile components

### High Priority (500-700 lines)
- **NextGenAdmin.tsx** (983 lines) - Split admin functions into separate components
- **BuildPhaseFormConfigModal.tsx** (973 lines) - Extract form sections
- **EULAModal.tsx** (910 lines) - Split terms display and acceptance logic

### Component Splitting Strategies for Large Files
1. **Extract Form Sections**: Separate validation, submission, and display logic
2. **Create Sub-components**: Split UI sections into focused components
3. **Extract Custom Hooks**: Move data fetching and state management to hooks
4. **Separate Business Logic**: Move calculations and transformations to utility functions

## Ultra-Aggressive Fail-Fast Error Handling Guidelines

### **CRITICAL: Fail-Fast Philosophy - No Fallbacks for Critical Operations**

**Core Principle**: Show all bugs clearly, fail aggressively, terminate immediately on security violations

#### 1. **Error Classification & Decision Matrix**

**ALWAYS FAIL-FAST (No Fallbacks)**:
- **Authentication errors** (JWT, wallet connection, SIWX)
- **Authorization failures** (insufficient permissions)
- **Transaction errors** (insufficient balance, gas estimation failures)
- **Security violations** (invalid signatures, unauthorized access)
- **Data integrity failures** (schema validation, sanitization failures)
- **API authentication/authorization errors**

**FAIL-FAST with Context (Structured Termination)**:
- **Network errors** (with retry exhaustion)
- **Parsing errors** (malformed JSON, invalid data types)
- **Validation errors** (form validation, input constraints)
- **Resource exhaustion** (rate limits, quotas)

```typescript
// ✅ CORRECT: Ultra-aggressive fail-fast for authentication
function handleAuthError(error: AuthenticationError): never {
  // Log with enhanced security context
  logSecurityEvent(SecurityEventType.AUTHENTICATION_FAILURE, {
    timestamp: new Date().toISOString(),
    source: 'auth_handler',
    errorCode: error.code,
    userAgent: navigator.userAgent
  });
  
  // Immediate termination - no fallbacks
  throw new AuthenticationError(
    'Authentication failed. Please reconnect your wallet.',
    error.code
  );
}

// ❌ INCORRECT: Soft fallback for critical security operation
function handleAuthError(error: AuthenticationError): AuthState {
  console.warn('Auth failed, using guest mode'); // NO!
  return { isAuthenticated: false, user: null }; // DANGEROUS!
}
```

#### 2. **Enhanced Error Class Architecture**

Building upon existing `WalletConnectionError`, `AuthenticationError`, `TokenRefreshError`:

```typescript
// Enhanced base error class with structured context
abstract class SeizeError extends Error {
  abstract readonly type: string;
  abstract readonly code: string;
  readonly timestamp: string;
  readonly context: Record<string, unknown>;

  constructor(
    message: string,
    code: string,
    context: Record<string, unknown> = {}
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.timestamp = new Date().toISOString();
    this.context = context;
  }

  toSecureLogEntry(): SecurityLogEntry {
    return {
      timestamp: this.timestamp,
      type: this.type,
      code: this.code,
      message: sanitizeErrorMessage(this.message),
      context: sanitizeMetadata(this.context)
    };
  }
}

// Critical security errors - ALWAYS fail-fast
class SecurityViolationError extends SeizeError {
  readonly type = 'SECURITY_VIOLATION';
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

class AuthenticationError extends SeizeError {
  readonly type = 'AUTHENTICATION_ERROR';
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

class TransactionError extends SeizeError {
  readonly type = 'TRANSACTION_ERROR';
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Non-critical errors - structured but can have recovery
class ValidationError extends SeizeError {
  readonly type = 'VALIDATION_ERROR';
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}
```

#### 3. **Ultra-Aggressive Error Boundary Strategy**

**Section-Level Failure** (No Graceful Fallbacks):

```tsx
// ✅ CORRECT: Aggressive error boundary with clear failure states
function CriticalFeatureErrorBoundary({ 
  children, 
  featureName 
}: {
  children: React.ReactNode;
  featureName: string;
}) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <div className="tw-bg-red-50 tw-border-2 tw-border-red-500 tw-rounded-lg tw-p-6 tw-text-center">
          <h3 className="tw-text-xl tw-font-bold tw-text-red-800 tw-mb-4">
            {featureName} Failed
          </h3>
          <p className="tw-text-red-700 tw-mb-6">
            A critical error occurred. The application cannot continue safely.
          </p>
          <div className="tw-space-y-3">
            <button
              onClick={resetErrorBoundary}
              className="tw-block tw-w-full tw-bg-red-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-red-700"
            >
              Reset Feature
            </button>
            <button
              onClick={() => window.location.reload()}
              className="tw-block tw-w-full tw-bg-gray-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-gray-700"
            >
              Reload Application
            </button>
          </div>
        </div>
      )}
      onError={(error, errorInfo) => {
        // Enhanced logging with security context
        logError(`${featureName}_boundary_error`, error);
        
        // Report to monitoring service
        if (error instanceof SecurityViolationError) {
          logSecurityEvent(SecurityEventType.SECURITY_BOUNDARY_VIOLATION, {
            featureName,
            source: 'error_boundary',
            componentStack: sanitizeErrorMessage(errorInfo.componentStack || '')
          });
        }
      }}
    >
      {children}
    </ErrorBoundary>
  );
}

// Usage: Wrap critical features with aggressive boundaries
<CriticalFeatureErrorBoundary featureName="Wallet Connection">
  <WalletProvider>
    <AuthenticatedApp />
  </WalletProvider>
</CriticalFeatureErrorBoundary>
```

#### 4. **Production-Ready Security Logging Enhancement**

Enhanced `security-logger.ts` patterns:

```typescript
// Enhanced error logging with structured codes
export const logCriticalError = (
  context: string,
  error: SeizeError,
  additionalContext?: Record<string, unknown>
): void => {
  const logEntry = {
    ...error.toSecureLogEntry(),
    context,
    additionalContext: additionalContext ? sanitizeMetadata(additionalContext) : undefined,
    severity: getSeverityLevel(error),
    actionRequired: getActionRequired(error),
    sessionId: generateSecureSessionId()
  };

  // Immediate alert for critical errors
  if (error instanceof SecurityViolationError) {
    // Send to security monitoring immediately
    sendSecurityAlert(logEntry);
  }

  // Structured logging for searchability
  if (process.env.NODE_ENV === 'production') {
    console.error(`[SEIZE_CRITICAL_ERROR][${error.code}]`, logEntry);
  } else {
    console.group(`🚨 CRITICAL ERROR: ${error.type}`);
    console.error('Error Details:', logEntry);
    console.error('Stack Trace:', error.stack);
    console.groupEnd();
  }
};

// Error severity classification
function getSeverityLevel(error: SeizeError): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
  if (error instanceof SecurityViolationError) return 'CRITICAL';
  if (error instanceof AuthenticationError) return 'HIGH';
  if (error instanceof TransactionError) return 'HIGH';
  if (error instanceof ValidationError) return 'MEDIUM';
  return 'LOW';
}

// Required actions for different error types
function getActionRequired(error: SeizeError): string {
  switch (error.type) {
    case 'SECURITY_VIOLATION':
      return 'IMMEDIATE_INVESTIGATION_REQUIRED';
    case 'AUTHENTICATION_ERROR':
      return 'USER_REAUTHENTICATION_REQUIRED';
    case 'TRANSACTION_ERROR':
      return 'TRANSACTION_RETRY_OR_USER_ACTION';
    default:
      return 'STANDARD_ERROR_HANDLING';
  }
}
```

#### 5. **Comprehensive Testing Strategy for Fail-Fast Patterns**

**Error Propagation Tests**:
```typescript
describe('Fail-Fast Error Propagation', () => {
  it('should propagate authentication errors without fallback', () => {
    const mockAuthError = new AuthenticationError(
      'Invalid JWT token',
      'AUTH_JWT_INVALID'
    );

    const mockWalletConnect = jest.fn().mockRejectedValue(mockAuthError);

    expect(async () => {
      await connectWallet(mockWalletConnect);
    }).rejects.toThrow(AuthenticationError);
    
    expect(async () => {
      await connectWallet(mockWalletConnect);
    }).rejects.toHaveProperty('code', 'AUTH_JWT_INVALID');
  });

  it('should never provide fallback for security violations', () => {
    const securityError = new SecurityViolationError(
      'Unauthorized signature attempt',
      'SECURITY_INVALID_SIGNATURE'
    );

    const result = handleSecurityError(securityError);
    
    // Should always throw, never return a value
    expect(result).toBeUndefined();
    expect(mockLogSecurityEvent).toHaveBeenCalledWith(
      SecurityEventType.SECURITY_VIOLATION,
      expect.objectContaining({
        errorCode: 'SECURITY_INVALID_SIGNATURE'
      })
    );
  });
});
```

**Security Leak Tests**:
```typescript
describe('Security Data Sanitization', () => {
  it('should never log sensitive data in error messages', () => {
    const error = new AuthenticationError(
      'JWT validation failed for token: eyJ0eXAiOiJKV1Q...',
      'AUTH_JWT_INVALID'
    );

    logCriticalError('test_context', error);

    expect(mockConsoleError).toHaveBeenCalledWith(
      expect.stringMatching(/\[SEIZE_CRITICAL_ERROR\]/),
      expect.objectContaining({
        message: expect.stringMatching(/\*\*\*JWT\*\*\*/) // Sanitized
      })
    );
  });
});
```

#### 6. **Recovery Pattern Documentation with Fail-Fast Integration**

**Retry Mechanisms** (with aggressive limits):
```typescript
// Ultra-conservative retry with immediate failure
const CRITICAL_OPERATION_MAX_RETRIES = 1; // Aggressive: only 1 retry
const CRITICAL_OPERATION_TIMEOUT = 5000; // 5 second timeout

async function retryWalletConnection(
  operation: () => Promise<WalletConnection>,
  maxRetries = CRITICAL_OPERATION_MAX_RETRIES
): Promise<WalletConnection> {
  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
    try {
      return await operation();
    } catch (error) {
      // Fail immediately on security errors
      if (error instanceof SecurityViolationError || 
          error instanceof AuthenticationError) {
        logCriticalError(
          'wallet_connection_security_failure',
          error as SeizeError,
          { attempt, maxRetries }
        );
        throw error; // No retry for security issues
      }

      // Last attempt - fail fast
      if (attempt > maxRetries) {
        const finalError = new WalletConnectionError(
          'Wallet connection failed after maximum retries',
          'WALLET_CONNECTION_EXHAUSTED',
          { totalAttempts: attempt, originalError: error }
        );
        
        logCriticalError('wallet_connection_exhausted', finalError);
        throw finalError;
      }

      // Brief pause only for non-security errors
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}
```

**User-Initiated Recovery** (with security checks):
```tsx
function SecurityAwareRecoveryButton({ 
  onRecover, 
  error, 
  featureName 
}: {
  onRecover: () => void;
  error: SeizeError;
  featureName: string;
}) {
  // No recovery allowed for security violations
  if (error instanceof SecurityViolationError) {
    return (
      <div className="tw-bg-red-100 tw-border tw-border-red-500 tw-p-4 tw-rounded">
        <p className="tw-text-red-800 tw-font-semibold">
          Security violation detected. Recovery not available.
        </p>
        <p className="tw-text-red-600 tw-text-sm tw-mt-2">
          Please refresh the page and ensure your wallet is secure.
        </p>
      </div>
    );
  }

  return (
    <button
      onClick={() => {
        logSecurityEvent(SecurityEventType.USER_INITIATED_RECOVERY, {
          featureName,
          errorType: error.type,
          source: 'user_recovery_button'
        });
        onRecover();
      }}
      className="tw-bg-blue-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-blue-700"
    >
      Try Again
    </button>
  );
}
```

#### 7. **Implementation Verification Commands**

```bash
# Verify error handling patterns
grep -r "catch.*AuthenticationError" components/ --include="*.tsx" --include="*.ts"
grep -r "SecurityViolationError" src/ --include="*.ts"
grep -r "logCriticalError" components/ --include="*.tsx"

# Check for forbidden fallback patterns
grep -r "catch.*console\.warn" components/ # Should find none
grep -r "|| null.*catch" components/ # Should find none for critical operations

# Verify security logging usage
grep -r "logSecurityEvent" components/ --include="*.tsx"
grep -r "sanitizeErrorMessage" utils/ --include="*.ts"

# Test error boundary integration
npm run test -- --testNamePattern="Error.*Boundary" --verbose
npm run test -- --testNamePattern="fail.*fast" --verbose
```

#### 8. **Web3-Specific Fail-Fast Patterns**

Based on 2024-2025 OWASP Smart Contract Top 10 and $1.42B in documented losses:

```typescript
// ✅ CORRECT: Fail-fast on wallet security violations
function validateWalletSignature(signature: string, message: string): never | void {
  if (!signature || signature.length < 132) {
    throw new SecurityViolationError(
      'Invalid signature format detected',
      'WALLET_INVALID_SIGNATURE',
      { signatureLength: signature?.length || 0 }
    );
  }

  // Additional security validations...
  const isValid = verifySignature(signature, message);
  if (!isValid) {
    throw new SecurityViolationError(
      'Signature verification failed',
      'WALLET_SIGNATURE_VERIFICATION_FAILED'
    );
  }
}

// ✅ CORRECT: Fail-fast on transaction anomalies
function validateTransactionSecurity(txParams: TransactionParams): never | void {
  // Check for potential oracle manipulation patterns
  if (txParams.gasPrice > MAX_REASONABLE_GAS_PRICE) {
    throw new SecurityViolationError(
      'Gas price exceeds security threshold',
      'TRANSACTION_GAS_ANOMALY',
      { gasPrice: txParams.gasPrice, threshold: MAX_REASONABLE_GAS_PRICE }
    );
  }

  // Validate recipient address
  if (!isValidEthereumAddress(txParams.to)) {
    throw new SecurityViolationError(
      'Invalid recipient address format',
      'TRANSACTION_INVALID_RECIPIENT'
    );
  }
}
```

---

**CRITICAL REMINDER**: This fail-fast approach prioritizes security and bug detection over user convenience. Every fallback removed is a potential vulnerability eliminated. In Web3 applications handling financial transactions, aggressive failure is safer than silent corruption.

## Migration & Deprecation Notes

### Outdated Patterns to Avoid
- **Class Components**: Convert to function components with hooks
- **Mixed State Management**: Use consistent patterns (Context + hooks or Zustand)
- **Inline Styles**: Move to CSS modules or styled-components
- **Large Monolithic Components**: Split following single responsibility principle
- **Soft Error Fallbacks**: Replace with fail-fast patterns for critical operations
- **Silent Error Swallowing**: All errors must be logged and handled explicitly
- **Generic Error Messages**: Use structured error classes with specific codes

### Migration Paths
- **Component Splitting**: Gradual extraction of sub-components
- **Hook Extraction**: Move repeated logic to custom hooks
- **Type Safety**: Add TypeScript interfaces to any untyped components
- **Testing**: Add tests for newly split components
- **Error Boundaries**: Wrap critical features with fail-fast boundaries
- **Security Logging**: Implement structured error logging with sanitization

## Known Issues & Performance Notes

### Component Size Issues
- Several components exceed recommended size limits
- Complex state management spread across large components
- Mixed concerns in presentation and data fetching

### Performance Considerations
- Large bundle sizes due to monolithic components
- Potential for unnecessary re-renders in complex components
- Memory usage in long-running user sessions

### Browser Compatibility
- Modern ES2020+ features used (ensure transpilation for older browsers)
- Service worker support for offline functionality
- WebRTC support required for peer-to-peer features

## TailwindCSS Styling Guidelines & Best Practices

### **CRITICAL RULE: Always Use TailwindCSS for Styling**

**All new components and styling MUST use TailwindCSS with the `tw-` prefix. This is non-negotiable.**

#### TailwindCSS Configuration
- **Version**: v3.4.4 with modern features and plugins
- **Prefix**: `tw-` (REQUIRED for all classes)
- **Preflight**: Disabled (`preflight: false`)
- **Dark Mode**: Class-based (`"class"` strategy)
- **Current Coexistence**: Running alongside Bootstrap (migration in progress)

### Mandatory TailwindCSS Usage Patterns

#### 1. **Prefix System (REQUIRED)**
```tsx
// ✅ CORRECT: Always use tw- prefix
<div className="tw-flex tw-items-center tw-gap-x-4 tw-p-6">
  <img className="tw-h-12 tw-w-12 tw-rounded-full tw-ring-2 tw-ring-white" />
  <div className="tw-text-xl tw-font-medium tw-text-iron-50">
</div>

// ❌ INCORRECT: No prefix (conflicts with Bootstrap)  
<div className="flex items-center gap-4">
```

#### 2. **Custom Design System Classes**
```tsx
// Custom Color Scale (MUST use these)
tw-bg-primary-500     // Primary brand blue
tw-bg-primary-600     // Darker primary
tw-text-iron-50       // Light text
tw-text-iron-300      // Medium text  
tw-text-iron-500      // Muted text
tw-bg-iron-800        // Dark backgrounds
tw-bg-iron-900        // Darker backgrounds
tw-bg-iron-950        // Darkest backgrounds

// Custom Shadows
tw-shadow-drop-btn-inactive
tw-shadow-drop-btn-active

// Custom Animations
tw-animate-loading-bar
tw-animate-trophy-appear  
tw-animate-gradient-shift
tw-animate-fadeIn
tw-animate-shake
tw-animate-gallery-reveal
```

#### 3. **Responsive Design Patterns**
```tsx
// Mobile-first approach with custom 3xl breakpoint
<div className="tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 lg:tw-grid-cols-3 tw-3xl:tw-grid-cols-4">

// Container queries (use @container)
<div className="tw-@container">
  <div className="tw-flex tw-flex-col @md:tw-flex-row">
```

### Headless UI + TailwindCSS Integration Patterns

#### 1. **State-Based Styling with Data Attributes**
```tsx
import { Dialog, DialogPanel } from '@headlessui/react'

// ✅ CORRECT: Using data attributes for state styling
<Dialog className="tw-fixed tw-inset-0 tw-z-[1010]">
  <DialogPanel className="tw-bg-iron-950 tw-shadow-xl data-open:tw-scale-100 data-closed:tw-scale-95">

// Alternative: Using Headless UI plugin (if installed)
<Tab className="ui-selected:tw-bg-primary-500 ui-not-selected:tw-bg-iron-800">
```

#### 2. **Component Composition with TailwindCSS**
```tsx
// Headless UI + TailwindCSS pattern
import { Combobox, ComboboxInput, ComboboxOptions, ComboboxOption } from '@headlessui/react'

<Combobox className="tw-relative">
  <ComboboxInput className="tw-w-full tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-px-3 tw-py-2 tw-text-iron-50 focus:tw-border-primary-500 focus:tw-outline-none" />
  <ComboboxOptions className="tw-absolute tw-z-10 tw-mt-1 tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-lg">
    <ComboboxOption className="tw-px-3 tw-py-2 data-focus:tw-bg-primary-500 data-selected:tw-bg-primary-600">
```

#### 3. **Transition and Animation Integration**
```tsx
import { Transition, TransitionChild } from '@headlessui/react'

<Transition show={open}>
  <TransitionChild
    enter="tw-ease-out tw-duration-300"
    enterFrom="tw-opacity-0"
    enterTo="tw-opacity-100"
    leave="tw-ease-in tw-duration-200"
    leaveFrom="tw-opacity-100"
    leaveTo="tw-opacity-0"
  >
    <div className="tw-fixed tw-inset-0 tw-bg-gray-500 tw-bg-opacity-50" />
  </TransitionChild>
</Transition>
```

### Advanced TailwindCSS Patterns

#### 1. **Arbitrary Values for Custom Properties**
```tsx
// ✅ Use arbitrary values for precise control
<div className="tw-h-[calc(100vh-4rem)] tw-w-[50cqw]">
<div className="tw-bg-[#9917FF] tw-text-[var(--custom-color)]">

// ✅ Container query length units
<div className="tw-@container">
  <div className="tw-w-[50cqw] tw-h-[25cqh]">
```

#### 2. **Custom CSS Variable Integration**
```tsx
// ✅ Setting CSS variables for dynamic styling
<button
  style={{
    "--bg-color": buttonColor,
    "--text-color": textColor,
  }}
  className="tw-bg-[var(--bg-color)] tw-text-[var(--text-color)] hover:tw-opacity-80"
>
```

#### 3. **Component Variant Patterns**
```tsx
// ✅ Create reusable utility patterns
const buttonVariants = {
  primary: "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600",
  secondary: "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500",
  danger: "tw-bg-red-600 tw-text-white hover:tw-bg-red-700"
}

<button className={`tw-px-4 tw-py-2 tw-rounded-lg tw-transition-colors ${buttonVariants.primary}`}>
```

### Migration Strategy from Bootstrap/SCSS

#### 1. **Immediate Actions for New Components**
```tsx
// ❌ AVOID: Bootstrap classes in new components
<div className="container-fluid d-flex justify-content-between">
<button className="btn btn-primary">

// ✅ REPLACE WITH: TailwindCSS equivalents
<div className="tw-container tw-mx-auto tw-flex tw-justify-between">
<button className="tw-bg-primary-500 tw-text-white tw-px-4 tw-py-2 tw-rounded-lg hover:tw-bg-primary-600 tw-transition-colors">
```

#### 2. **Gradual Migration for Existing Components**
```tsx
// ✅ ACCEPTABLE: Mixed during migration (mark for future cleanup)
<Container className="pt-4"> {/* Bootstrap - mark for migration */}
  <div className="tw-flex tw-items-center tw-gap-3"> {/* TailwindCSS */}
    <span className="tw-text-iron-300 tw-animate-pulse"> {/* TailwindCSS */}
```

#### 3. **Testing Strategy During Migration**
- Test components in both Bootstrap and TailwindCSS contexts
- Verify responsive behavior works correctly
- Check dark mode compatibility
- Validate accessibility is maintained

### Mobile-First & Performance Considerations

#### 1. **Capacitor-Specific Styling**
```tsx
// ✅ Safe area support
<div className="tw-pt-[env(safe-area-inset-top,0px)] tw-pb-[env(safe-area-inset-bottom,0px)]">

// ✅ Touch-optimized components
<button className="tw-min-h-[44px] tw-min-w-[44px] tw-touch-manipulation">
```

#### 2. **Performance Optimizations**
```tsx
// ✅ Use transform for animations (GPU accelerated)
<div className="tw-transform tw-translate-x-0 hover:tw-translate-x-1 tw-transition-transform">

// ✅ Efficient scrolling
<div className="tw-overflow-y-auto tw-scrollbar-thin tw-scrollbar-thumb-iron-500 tw-scrollbar-track-iron-800">
```

### Dark Mode & Theming Patterns

#### 1. **Dark Mode Implementation**
```tsx
// ✅ Using class-based dark mode strategy
<div className="tw-bg-white dark:tw-bg-iron-900 tw-text-iron-900 dark:tw-text-iron-50">

// ✅ Custom dark mode variants with iron scale
<div className="tw-bg-iron-100 dark:tw-bg-iron-800">
```

### Web3/Blockchain UI Patterns

#### 1. **Wallet Connection States**
```tsx
// ✅ State-based styling for wallet components
<button className={`
  tw-px-6 tw-py-3 tw-rounded-lg tw-font-semibold tw-transition-all tw-duration-200
  ${connected 
    ? 'tw-bg-success tw-text-white hover:tw-bg-green' 
    : 'tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600'
  }
`}>
```

#### 2. **Transaction Status UI**
```tsx
// ✅ Status indicators with custom animations
<div className="tw-flex tw-items-center tw-gap-2">
  <div className="tw-w-2 tw-h-2 tw-bg-primary-500 tw-rounded-full tw-animate-pulse" />
  <span className="tw-text-iron-300">Transaction pending...</span>
</div>
```

### Component Testing with TailwindCSS

#### 1. **Testing Responsive Classes**
```tsx
// ✅ Test responsive behavior
expect(screen.getByTestId('responsive-grid')).toHaveClass('tw-grid-cols-1', 'sm:tw-grid-cols-2')

// ✅ Test dark mode classes
expect(screen.getByTestId('themed-element')).toHaveClass('dark:tw-bg-iron-900')
```

#### 2. **Visual Regression Testing**
- Use Playwright for cross-device testing
- Test both light and dark modes
- Verify custom animations work correctly
- Check touch targets meet 44px minimum

### Verification Commands

```bash
# Check for non-prefixed Tailwind classes (should be rare and marked for migration)
grep -r "className.*=[\"'][^\"']*\\b(flex|grid|bg-|text-|p-|m-|w-|h-)" components/ --exclude-dir=node_modules

# Find Bootstrap classes that need migration
grep -r "className.*=[\"'][^\"']*\\b(btn|container|d-flex|justify-content)" components/ --exclude-dir=node_modules

# Verify tw- prefix usage
grep -r "tw-" components/ | wc -l

# Check for Headless UI integration
grep -r "@headlessui" components/ --include="*.tsx"
```

## Research Sources & Documentation

### Primary Sources (Context7 MCP)
- **TailwindCSS**: /websites/tailwindcss_com-plus-ui-blocks-documentation - Component composition patterns
- **TailwindCSS Core**: /tailwindlabs/tailwindcss.com - Utility-first methodology and best practices  
- **Headless UI**: /websites/headlessui_com - TailwindCSS integration patterns with state-based styling
- **React**: /reactjs/react.dev - Modern React patterns and best practices
- **Next.js**: /vercel/next.js - App Router patterns and optimization
- **Reown AppKit**: /reown-com/appkit - Web3 integration and security
- **Wagmi**: /websites/wagmi_sh - React hooks for Ethereum

### Best Practices Sources
- **TailwindCSS v3.4.4**: Latest utility-first patterns and modern features
- **Headless UI Integration**: Component composition and state-based styling
- **Mobile-First Design**: Responsive patterns and touch optimization
- **Web3 UI Patterns**: Blockchain-specific interface design
- **Performance**: Bundle optimization and runtime performance
- **Accessibility**: Modern a11y standards with utility classes

### Configuration References
- **TailwindCSS Config**: Custom prefix `tw-`, preflight disabled, dark mode class strategy
- **Custom Design System**: iron color scale, primary brand colors, custom shadows and animations
- **Plugin Integration**: @tailwindcss/forms, tailwind-scrollbar, @tailwindcss/container-queries
- **Responsive Strategy**: Mobile-first with custom 3xl breakpoint (2048px)

### Last Updated
- Research conducted: January 2025
- TailwindCSS patterns: Based on v3.4.4 documentation and Context7 research
- Component analysis: Based on current codebase state with Bootstrap migration context
- Dependencies: Reflect package.json v0.1.0

---

**Ready for development. All styling MUST use TailwindCSS with tw- prefix. Bootstrap migration ongoing - new components must be TailwindCSS only.**