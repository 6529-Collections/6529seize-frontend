# 6529 Seize Frontend Context

## Bash Commands
- npm run dev: Starts development server with Turbopack on port 3001
- npm run build: Builds the application for production (no lint)
- npm run build:lint: Builds the application with linting
- npm run test: Runs Jest test suite in silent mode
- npm run test:cov: Runs tests with coverage reporting
- npm run test:e2e: Runs Playwright end-to-end tests
- npm run lint: Runs ESLint on the codebase
- npm run lint:fix: Runs ESLint with auto-fix
- npm run type-check: Runs TypeScript compiler checks
- npm run knip: Removes unused code and files with Knip
- npm run generate: Generates TypeScript types from OpenAPI schema
- npm run improve-coverage: Runs coverage improvement script

## File Organization Guidelines & Single Responsibility Principles

### Component Size Limits & Split Indicators
**CRITICAL THRESHOLDS:**
- **200-300 lines**: Recommended maximum for React components
- **500+ lines**: Requires immediate review and consideration for splitting
- **700+ lines**: MUST be refactored into smaller components

**Components Currently Exceeding Limits (Need Refactoring):**
- `components/delegation/CollectionDelegation.tsx` (1,984 lines) - URGENT
- `components/react-query-wrapper/ReactQueryWrapper.tsx` (1,268 lines) - URGENT
- `components/memelab/MemeLabPage.tsx` (1,249 lines) - URGENT
- `components/waves/CreateDropContent.tsx` (1,080 lines) - URGENT
- `components/header/Header.tsx` (1,027 lines) - URGENT
- `components/nextGen/admin/NextGenAdmin.tsx` (983 lines) - HIGH PRIORITY

### Single Responsibility Split Indicators
**When to Split Components:**
1. **"And" Rule**: If component description uses "and", it has multiple responsibilities
2. **Multiple useEffect Hooks**: Different effects often indicate different concerns
3. **Mixed Concerns Pattern**: Data fetching + display + business logic in one component
4. **State Management Complexity**: More than 5-7 useState calls
5. **Event Handler Proliferation**: More than 10 event handlers
6. **Conditional Rendering Complexity**: Multiple nested ternary operators

### File Organization Structure

#### Feature-Based Organization (Current Pattern)
```
components/
├── auth/                     # Authentication-related components
│   ├── error-boundary/      # Error handling (well-organized)
│   └── SeizeConnectContext.tsx
├── waves/                   # Wave/social features
│   ├── create/              # Wave creation components
│   ├── drop/                # Individual drop components
│   └── hooks/               # Wave-specific custom hooks
├── user/                    # User profile components
│   ├── brain/               # User dashboard
│   ├── collected/           # User's NFT collection
│   └── settings/            # User preferences
└── utils/                   # Shared utility components
```

#### Component Splitting Strategies

**1. Extract Sub-Components (Composition Pattern)**
```typescript
// ❌ Bad: Monolithic component
function ComplexComponent() {
  // 500+ lines of mixed logic
  return (
    <div>
      {/* header logic */}
      {/* form logic */}
      {/* data display logic */}
    </div>
  )
}

// ✅ Good: Split into focused components
function ComplexComponentHeader() { /* header-specific logic */ }
function ComplexComponentForm() { /* form-specific logic */ }
function ComplexComponentDisplay() { /* display-specific logic */ }

function ComplexComponent() {
  return (
    <div>
      <ComplexComponentHeader />
      <ComplexComponentForm />
      <ComplexComponentDisplay />
    </div>
  )
}
```

**2. Extract Custom Hooks (Logic Separation)**
```typescript
// ❌ Bad: Business logic mixed with rendering
function WaveComponent() {
  const [waves, setWaves] = useState([])
  const [loading, setLoading] = useState(false)
  // 50+ lines of data fetching logic
  
  return <div>{/* rendering logic */}</div>
}

// ✅ Good: Extract custom hooks
function useWaveData() {
  // All data fetching logic here
  return { waves, loading, refetch }
}

function WaveComponent() {
  const { waves, loading, refetch } = useWaveData()
  return <div>{/* pure rendering logic */}</div>
}
```

**3. Separate Container and Presentation (Smart/Dumb Pattern)**
```typescript
// ❌ Bad: Data fetching mixed with presentation
function UserProfile() {
  // API calls, state management, AND rendering
}

// ✅ Good: Separate concerns
function UserProfileContainer() {
  // Data fetching and state management only
  const userData = useUserData()
  return <UserProfilePresentation data={userData} />
}

function UserProfilePresentation({ data }) {
  // Pure presentation logic only
}
```

### Performance-Focused File Organization

#### Code Splitting Strategies
1. **Route-Based Splitting**: Lazy load page-level components
```typescript
// Use React.lazy for page components
const MemeLabPage = lazy(() => import('./components/memelab/MemeLabPage'))
const WavesPage = lazy(() => import('./components/waves/WavesPage'))
```

2. **Feature-Based Splitting**: Split large feature modules
```typescript
// Split complex features into separate bundles
const AdminPanel = lazy(() => import('./components/nextGen/admin/NextGenAdmin'))
```

3. **Conditional Component Loading**: Load components only when needed
```typescript
// Load heavy components conditionally
const HeavyChart = lazy(() => import('./components/charts/HeavyChart'))

function Dashboard() {
  const [showChart, setShowChart] = useState(false)
  return (
    <div>
      {showChart && (
        <Suspense fallback={<div>Loading...</div>}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  )
}
```

### State Management Across Split Components

#### Context Pattern for Related Components
```typescript
// Create context for component families
const WaveContext = createContext()

function WaveProvider({ children }) {
  const [waveState, setWaveState] = useState()
  return (
    <WaveContext.Provider value={{ waveState, setWaveState }}>
      {children}
    </WaveContext.Provider>
  )
}
```

#### Shared State Hooks
```typescript
// Custom hooks for shared state
function useSharedWaveState() {
  const context = useContext(WaveContext)
  if (!context) throw new Error('Must be used within WaveProvider')
  return context
}
```

## Key Dependencies & Documentation

### React (v19.1.0)
- **Source**: React.dev official documentation
- **Best Practices**: Function components with hooks, avoid class components
- **Component Patterns**: Composition over inheritance, single responsibility
- **Hook Rules**: Always at top level, consistent dependency arrays
- **Migration Notes**: Update any remaining class components to function components

### Next.js (v15.3.5)
- **Source**: Next.js documentation
- **Router**: App Router (preferred over Pages Router)
- **File Organization**: App directory structure with colocation support
- **Performance**: Built-in optimizations, automatic code splitting
- **Migration Notes**: Migrate remaining pages/* routes to app/* directory

### @reown/appkit (v1.7.17)
- **Source**: Reown AppKit documentation
- **Security Patterns**: SIWX authentication, secure wallet connections
- **Integration**: Web3 wallet management with mobile support
- **Best Practices**: Environment-based configuration, error boundaries

### wagmi (v2.15.6)
- **Source**: Wagmi.sh documentation
- **Hook Patterns**: Reactive Web3 data fetching, optimistic updates
- **Performance**: Built-in caching, structural sharing
- **Best Practices**: Use scopeKey for cache management, avoid prop drilling hooks

### TypeScript (v5.8.3)
- **Source**: TypeScript documentation
- **Patterns**: Strict type checking, interface-based design
- **File Organization**: Co-locate types with components
- **Best Practices**: Use discriminated unions, avoid `any` type

## Code Style & Best Practices

### React Component Patterns
- **Function Components**: Use exclusively, avoid class components except for error boundaries
- **Hook Dependencies**: Always include in dependency arrays, use ESLint rules
- **Props Interface**: Define TypeScript interfaces for all props
- **Default Props**: Use default parameters instead of defaultProps
- **Ref Patterns**: Use useRef for DOM manipulation, forwardRef for component refs

### File Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Hooks**: camelCase starting with "use" (e.g., `useWaveData.ts`)
- **Utils**: camelCase (e.g., `formatCurrency.ts`)
- **Types**: PascalCase interfaces/types (e.g., `UserProfileTypes.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)

### Import/Export Patterns
- **Named Exports**: Preferred for utilities and hooks
- **Default Exports**: Use for main component in file
- **Index Files**: Create for clean directory imports
- **Relative Imports**: Use for local files, absolute for shared utilities

### Error Handling Patterns
- **Error Boundaries**: Wrap feature areas, provide recovery actions
- **Async Error Handling**: Use try-catch with proper user feedback
- **Form Validation**: Client-side validation with server-side verification
- **Network Errors**: Retry mechanisms with exponential backoff

## Testing Strategy

### Component Testing (Jest + React Testing Library)
- **Focus**: User interactions and component behavior
- **Patterns**: Test props variations, user events, accessibility
- **Mocking**: Mock external dependencies, API calls
- **Coverage**: Aim for >80% on critical user paths

### Integration Testing (Playwright)
- **Focus**: End-to-end user workflows
- **Critical Paths**: Authentication, wallet connection, core features
- **Performance**: Page load times, interaction responsiveness
- **Cross-browser**: Test on Chromium, Firefox, Safari

### Hook Testing
- **Custom Hooks**: Test in isolation with @testing-library/react-hooks
- **State Management**: Verify state transitions and side effects
- **Error Scenarios**: Test error handling and recovery

## Project Structure

### Root Level Directories
- `app/`: Next.js App Router pages and layouts
- `components/`: Reusable React components organized by feature
- `src/`: Core utilities, types, and business logic
- `hooks/`: Custom React hooks for shared logic
- `services/`: API integration and external service clients
- `utils/`: Pure utility functions and helpers
- `types/`: TypeScript type definitions
- `__tests__/`: Test files mirroring source structure

### Component Organization Hierarchy
```
components/
├── Layout Components (header, footer, navigation)
├── Feature Components (auth, waves, user, trading)
│   ├── Container Components (data fetching, state management)
│   ├── Presentation Components (pure rendering)
│   └── Shared Sub-components
└── Utility Components (buttons, forms, modals)
```

### Critical File Organization Rules
1. **One Component Per File**: Each component gets its own file
2. **Co-locate Related Files**: Keep components, styles, tests together
3. **Separate Concerns**: Split data logic from presentation logic
4. **Consistent Naming**: Use clear, descriptive names that indicate purpose
5. **Index Files**: Use for clean imports in component directories

## Mobile-First Development Considerations

### Responsive Design Patterns
- **Breakpoint Strategy**: Mobile-first with progressive enhancement
- **Component Variants**: Create mobile-specific variants for complex components
- **Touch Interactions**: Optimize for touch targets and gestures
- **Performance**: Lazy load non-critical components on mobile

### Capacitor Integration
- **Native Features**: Camera, file system, push notifications
- **Platform Detection**: Conditional rendering for native vs web
- **Performance**: Minimize bundle size for mobile app builds

## Security & Authentication

### Web3 Security Patterns
- **Wallet Connection**: Secure connection handling with error recovery
- **Transaction Signing**: User confirmation flows, gas estimation
- **Data Sanitization**: Input validation and output encoding
- **Error Handling**: Secure error messages without sensitive data exposure

### Authentication Flow
- **SIWX Integration**: Sign-in with X for social authentication
- **JWT Management**: Secure token storage and refresh patterns
- **Session Handling**: Proper cleanup on logout/disconnect

## Performance Optimization

### Bundle Optimization
- **Code Splitting**: Route-based and feature-based splitting
- **Tree Shaking**: Remove unused code with proper ES modules
- **Bundle Analysis**: Regular analysis with @next/bundle-analyzer
- **Dynamic Imports**: Lazy load heavy components and libraries

### Runtime Performance
- **React Optimization**: useMemo, useCallback for expensive operations
- **Virtual Scrolling**: For large lists (waves, NFT collections)
- **Image Optimization**: Next.js Image component with proper sizing
- **Caching Strategy**: Service worker for offline support

## Development Workflow

### Branch Strategy
- **Feature Branches**: Create from main for new features
- **Mobile Branch**: Current mobile-4 branch for mobile-specific work
- **Code Review**: Required for all changes to main branch
- **Testing**: All tests must pass before merge

### Commit Conventions
- **Format**: Conventional commits (feat:, fix:, refactor:, etc.)
- **Scope**: Include component/feature scope when relevant
- **Breaking Changes**: Document any breaking changes clearly

## Environment Setup

### Required Tools
- **Node.js**: Version specified in package.json engines
- **Package Manager**: npm (package-lock.json present)
- **IDE**: VS Code with TypeScript and ESLint extensions recommended

### Environment Variables
- **NEXT_PUBLIC_PROJECT_ID**: Reown/WalletConnect project ID
- **NEXTAUTH_SECRET**: NextAuth.js secret for session encryption
- **API Endpoints**: Configure for development/production environments

### Development Dependencies
- **ESLint**: Code quality and style enforcement
- **Prettier**: Code formatting (if configured)
- **TypeScript**: Type checking and IntelliSense
- **Jest**: Unit testing framework
- **Playwright**: End-to-end testing

## Refactoring Priority List

### Immediate Actions Required (700+ lines)
1. **CollectionDelegation.tsx** (1,984 lines) - Split into delegation flow components
2. **ReactQueryWrapper.tsx** (1,268 lines) - Extract provider setup logic
3. **MemeLabPage.tsx** (1,249 lines) - Split into lab sections and filters
4. **CreateDropContent.tsx** (1,080 lines) - Extract form sections and validation
5. **Header.tsx** (1,027 lines) - Split navigation, user menu, and mobile components

### High Priority (500-700 lines)
- **NextGenAdmin.tsx** (983 lines) - Split admin functions into separate components
- **BuildPhaseFormConfigModal.tsx** (973 lines) - Extract form sections
- **EULAModal.tsx** (910 lines) - Split terms display and acceptance logic

### Component Splitting Strategies for Large Files
1. **Extract Form Sections**: Separate validation, submission, and display logic
2. **Create Sub-components**: Split UI sections into focused components
3. **Extract Custom Hooks**: Move data fetching and state management to hooks
4. **Separate Business Logic**: Move calculations and transformations to utility functions

## Migration & Deprecation Notes

### Outdated Patterns to Avoid
- **Class Components**: Convert to function components with hooks
- **Mixed State Management**: Use consistent patterns (Context + hooks or Zustand)
- **Inline Styles**: Move to CSS modules or styled-components
- **Large Monolithic Components**: Split following single responsibility principle

### Migration Paths
- **Component Splitting**: Gradual extraction of sub-components
- **Hook Extraction**: Move repeated logic to custom hooks
- **Type Safety**: Add TypeScript interfaces to any untyped components
- **Testing**: Add tests for newly split components

## Known Issues & Performance Notes

### Component Size Issues
- Several components exceed recommended size limits
- Complex state management spread across large components
- Mixed concerns in presentation and data fetching

### Performance Considerations
- Large bundle sizes due to monolithic components
- Potential for unnecessary re-renders in complex components
- Memory usage in long-running user sessions

### Browser Compatibility
- Modern ES2020+ features used (ensure transpilation for older browsers)
- Service worker support for offline functionality
- WebRTC support required for peer-to-peer features

## Research Sources & Documentation

### Primary Sources (Context7 MCP)
- **React**: /reactjs/react.dev - Modern React patterns and best practices
- **Next.js**: /vercel/next.js - App Router patterns and optimization
- **Reown AppKit**: /reown-com/appkit - Web3 integration and security
- **Wagmi**: /websites/wagmi_sh - React hooks for Ethereum

### Best Practices Sources
- **React Performance**: Component optimization and rendering patterns
- **TypeScript**: Advanced type patterns and inference
- **Web3 Security**: OWASP guidelines for blockchain applications
- **Testing**: Modern testing strategies with RTL and Playwright

### Last Updated
- Research conducted: January 2025
- Component analysis: Based on current codebase state
- Dependencies: Reflect package.json v0.1.0

---

**Ready for development. All patterns documented reflect current best practices and project-specific needs.**