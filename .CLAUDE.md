# 6529 Seize Frontend Context

## Core Philosophy: Simple, Robust, and Maintainable

**"Favor simple, readable solutions over complex architectures. Document patterns that are easy to understand and maintain. Focus on battle-tested approaches rather than cutting-edge complexity."**

## **CRITICAL: Always Ask for Clarification When Unclear**

**If anything is unclear, ambiguous, or requires assumptions - STOP and ask immediately. Never proceed with uncertain understanding.**

### Clarification Guidelines

- **Ask Before Acting**: If requirements, context, or implementation details are unclear
- **Be Specific**: Ask focused questions about the unclear aspect
- **Explain Why**: State what specifically is confusing and why clarification is needed
- **Keep It Simple**: Avoid wall-of-text questions - be concise and direct
- **Provide Context**: Include relevant background about what you understand vs. what's unclear

### Question Format Examples

```
❌ BAD: "I'm not sure what you want me to do with this component..."

✅ GOOD: "I need clarification on the wallet connection flow:
- Should I maintain the existing error states or create new ones?
- Which specific error scenarios are you most concerned about?
- Reason: I see 3 different error handling patterns in the codebase."

❌ BAD: "There are many ways to implement this..."

✅ GOOD: "Two implementation approaches for the dropdown:
1. Headless UI with TailwindCSS (matches project standards)
2. Custom implementation with existing patterns
Which do you prefer? Reason: Affects maintainability and styling consistency."
```

### When to Ask Questions

- **Conflicting patterns** found in codebase
- **Multiple valid approaches** for implementation
- **Unclear requirements** or success criteria
- **Missing context** about user flows or business logic
- **Security implications** that need verification
- **Performance trade-offs** that need decision
- **Breaking changes** that might affect other components

**Remember: Better to ask one clear question than make wrong assumptions and waste time.**

### Simplicity Principles

- Choose clarity over cleverness
- Prefer composition over complex inheritance
- Use established patterns over experimental approaches
- Write code that new team members can quickly understand
- Focus on solutions that scale without becoming complex

## Bash Commands

- npm run dev: Starts development server with Turbopack on port 3001
- npm run build: Builds the application for production (no lint)
- npm run build:lint: Builds the application with linting
- npm run test: Runs Jest test suite in silent mode
- npm run test:cov: Runs tests with coverage reporting
- npm run test:e2e: Runs Playwright end-to-end tests
- npm run lint: Runs ESLint on the codebase
- npm run lint:fix: Runs ESLint with auto-fix
- npm run type-check: Runs TypeScript compiler checks
- npm run knip: Removes unused code and files with Knip
- npm run generate: Generates TypeScript types from OpenAPI schema
- npm run improve-coverage: Runs coverage improvement script

## File Organization Guidelines & Single Responsibility Principles

### Component Size Limits & Split Indicators

**CRITICAL THRESHOLDS:**

- **200-300 lines**: Recommended maximum for React components
- **500+ lines**: Requires immediate review and consideration for splitting
- **700+ lines**: MUST be refactored into smaller components

**Components Currently Exceeding Limits (Need Refactoring):**

- `components/delegation/CollectionDelegation.tsx` (1,984 lines) - URGENT
- `components/react-query-wrapper/ReactQueryWrapper.tsx` (1,268 lines) - URGENT
- `components/memelab/MemeLabPage.tsx` (1,249 lines) - URGENT
- `components/waves/CreateDropContent.tsx` (1,080 lines) - URGENT
- `components/header/Header.tsx` (1,027 lines) - URGENT
- `components/nextGen/admin/NextGenAdmin.tsx` (983 lines) - HIGH PRIORITY

### Single Responsibility Split Indicators

**When to Split Components:**

1. **"And" Rule**: If component description uses "and", it has multiple responsibilities
2. **Multiple useEffect Hooks**: Different effects often indicate different concerns
3. **Mixed Concerns Pattern**: Data fetching + display + business logic in one component
4. **State Management Complexity**: More than 5-7 useState calls
5. **Event Handler Proliferation**: More than 10 event handlers
6. **Conditional Rendering Complexity**: Multiple nested ternary operators

### File Organization Structure

#### Feature-Based Organization (Current Pattern)

```
components/
├── auth/                     # Authentication-related components
│   ├── error-boundary/      # Error handling (well-organized)
│   └── SeizeConnectContext.tsx
├── waves/                   # Wave/social features
│   ├── create/              # Wave creation components
│   ├── drop/                # Individual drop components
│   └── hooks/               # Wave-specific custom hooks
├── user/                    # User profile components
│   ├── brain/               # User dashboard
│   ├── collected/           # User's NFT collection
│   └── settings/            # User preferences
└── utils/                   # Shared utility components
```

#### Component Splitting Strategies

**1. Extract Sub-Components (Composition Pattern)**

```typescript
// ❌ Bad: Monolithic component
function ComplexComponent() {
  // 500+ lines of mixed logic
  return (
    <div>
      {/* header logic */}
      {/* form logic */}
      {/* data display logic */}
    </div>
  );
}

// ✅ Good: Split into focused components
function ComplexComponentHeader() {
  /* header-specific logic */
}
function ComplexComponentForm() {
  /* form-specific logic */
}
function ComplexComponentDisplay() {
  /* display-specific logic */
}

function ComplexComponent() {
  return (
    <div>
      <ComplexComponentHeader />
      <ComplexComponentForm />
      <ComplexComponentDisplay />
    </div>
  );
}
```

**2. Extract Custom Hooks (Logic Separation)**

```typescript
// ❌ Bad: Business logic mixed with rendering
function WaveComponent() {
  const [waves, setWaves] = useState([]);
  const [loading, setLoading] = useState(false);
  // 50+ lines of data fetching logic

  return <div>{/* rendering logic */}</div>;
}

// ✅ Good: Extract custom hooks
function useWaveData() {
  // All data fetching logic here
  return { waves, loading, refetch };
}

function WaveComponent() {
  const { waves, loading, refetch } = useWaveData();
  return <div>{/* pure rendering logic */}</div>;
}
```

**3. Separate Container and Presentation (Smart/Dumb Pattern)**

```typescript
// ❌ Bad: Data fetching mixed with presentation
function UserProfile() {
  // API calls, state management, AND rendering
}

// ✅ Good: Separate concerns
function UserProfileContainer() {
  // Data fetching and state management only
  const userData = useUserData();
  return <UserProfilePresentation data={userData} />;
}

function UserProfilePresentation({ data }) {
  // Pure presentation logic only
}
```

### Performance-Focused File Organization

#### Code Splitting Strategies

1. **Route-Based Splitting**: Lazy load page-level components

```typescript
// Use React.lazy for page components
const MemeLabPage = lazy(() => import("./components/memelab/MemeLabPage"));
const WavesPage = lazy(() => import("./components/waves/WavesPage"));
```

2. **Feature-Based Splitting**: Split large feature modules

```typescript
// Split complex features into separate bundles
const AdminPanel = lazy(
  () => import("./components/nextGen/admin/NextGenAdmin")
);
```

3. **Conditional Component Loading**: Load components only when needed

```typescript
// Load heavy components conditionally
const HeavyChart = lazy(() => import("./components/charts/HeavyChart"));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);
  return (
    <div>
      {showChart && (
        <Suspense fallback={<div>Loading...</div>}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  );
}
```

### State Management Across Split Components

#### Context Pattern for Related Components

```typescript
// Create context for component families
const WaveContext = createContext();

function WaveProvider({ children }) {
  const [waveState, setWaveState] = useState();
  return (
    <WaveContext.Provider value={{ waveState, setWaveState }}>
      {children}
    </WaveContext.Provider>
  );
}
```

#### Shared State Hooks

```typescript
// Custom hooks for shared state
function useSharedWaveState() {
  const context = useContext(WaveContext);
  if (!context) throw new Error("Must be used within WaveProvider");
  return context;
}
```

## Key Dependencies & Documentation

### React (v19.1.0) - Latest Research Findings 2025

- **Source**: React.dev official documentation + Latest 2025 research
- **Best Practices**: Function components exclusively, use React 19's new features
  - **useOptimistic**: Show users instant feedback during async operations
  - **useFormStatus**: Access form state without prop drilling
  - **use() API**: Read resources conditionally in render (unlike hooks)
- **Component Patterns**: Composition over inheritance, single responsibility
- **Hook Rules**: Always at top level, consistent dependency arrays, leverage React Compiler optimizations
- **Migration Notes**: Server Components and React Compiler are opt-in, legacy code continues working
- **Simple Approach**: Start with basic hooks, add complexity only when needed

### Next.js (v15.3.5) - App Router Best Practices 2025

- **Source**: Next.js 15 documentation + 2025 project structure research
- **Router**: App Router with React Server Components (RSC)
- **File Organization**: Feature-based structure with route groups and private folders
  - **Route Groups**: `(folderName)` for organization without URL impact
  - **Private Folders**: `_folderName` for internal organization
- **TypeScript Integration**: next.config.ts support with NextConfig types
- **Performance**: Turbopack in development, automatic optimizations
- **Simple Patterns**: Use Server Components for data, Client Components for interactivity

### @reown/appkit (v1.7.17) - 2025 Web3 Security Focus

- **Source**: Reown AppKit documentation + 2025 security research
- **Security Features**: Enhanced phishing protection with Verify API
  - **Threat Data**: 45% of web3 domains in 2023 were malicious
  - **Protection**: Domain registry + Blowfish + BlockAid integration
- **Multi-Chain**: EVM, Solana, Bitcoin support with single integration
- **Simple Authentication**: Email, social login, embedded wallets (no seed phrases)
- **Best Practices**: Smart Account functionality with Safe Core, analytics integration
- **Security Philosophy**: Fail-fast on suspicious domains, user education over complexity

### wagmi (v2.15.6) - TypeScript-First Patterns 2025

- **Source**: Wagmi.sh v2 documentation + 2025 hook composition research
- **TypeScript Integration**: Full end-to-end type safety with ABI inference
- **Hook Composition**: Removed watch properties, compose useBlock + useEffect instead
- **Migration Pattern**: useSimulateContract replaces usePrepareContractWrite
- **TanStack Query**: Built-in caching, no more suspense (use useSuspenseQuery)
- **Simple Patterns**: Compose small hooks rather than large multi-purpose ones
- **Performance**: Global config registration, structural sharing

### TypeScript (v5.8.3) - 2025 Strict Patterns

- **Source**: TypeScript documentation + Next.js 15 integration research
- **Strict Configuration**: Enable all strict mode flags for better type safety
- **Next.js Integration**: Full support for TypeScript in config files
- **Simple Patterns**: Interface over type aliases, discriminated unions for states
- **Best Practices**: Co-locate types, avoid `any`, use const assertions

## Code Style & Best Practices

### React Component Patterns

- **Function Components**: Use exclusively, avoid class components except for error boundaries
- **Hook Dependencies**: Always include in dependency arrays, use ESLint rules
- **Props Interface**: Define TypeScript interfaces for all props with readonly properties
- **Default Props**: Use default parameters instead of defaultProps
- **Ref Patterns**: Use useRef for DOM manipulation, forwardRef for component refs

## **CRITICAL: Component Props Must Be Readonly**

**All component prop interfaces MUST use readonly properties. This prevents accidental mutation and provides better type safety.**

### Readonly Props Guidelines

```typescript
// ✅ CORRECT: Always use readonly for component props
interface UserCardProps {
  readonly user: User;
  readonly onEdit: (id: string) => void;
  readonly className?: string;
}

// ❌ INCORRECT: Mutable props can cause issues
interface UserCardProps {
  user: User; // Missing readonly
  onEdit: (id: string) => void; // Missing readonly
  className?: string; // Missing readonly
}

// ✅ CORRECT: Complex nested props should also be readonly
interface ComplexProps {
  readonly config: {
    readonly theme: "light" | "dark";
    readonly settings: {
      readonly autoSave: boolean;
      readonly timeout: number;
    };
  };
  readonly items: readonly Item[];
  readonly handlers: {
    readonly onSave: () => void;
    readonly onCancel: () => void;
  };
}
```

### Benefits of Readonly Props

- **Immutability**: Prevents accidental prop mutation within components
- **Type Safety**: TypeScript catches attempts to modify props
- **Performance**: React can optimize better with immutable props
- **Debugging**: Easier to track data flow and identify mutation bugs
- **Best Practice**: Aligns with React's unidirectional data flow principle

### File Naming Conventions

- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Hooks**: camelCase starting with "use" (e.g., `useWaveData.ts`)
- **Utils**: camelCase (e.g., `formatCurrency.ts`)
- **Types**: PascalCase interfaces/types (e.g., `UserProfileTypes.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)

### Import/Export Patterns

- **Named Exports**: Preferred for utilities and hooks
- **Default Exports**: Use for main component in file
- **Index Files**: Create for clean directory imports
- **Relative Imports**: Use for local files, absolute for shared utilities

### Error Handling Patterns

- **Error Boundaries**: Wrap feature areas, provide recovery actions
- **Async Error Handling**: Use try-catch with proper user feedback
- **Form Validation**: Client-side validation with server-side verification
- **Network Errors**: Retry mechanisms with exponential backoff

## Testing Strategy

### Component Testing (Jest + React Testing Library)

- **Focus**: User interactions and component behavior
- **Patterns**: Test props variations, user events, accessibility
- **Mocking**: Mock external dependencies, API calls
- **Coverage**: Aim for >80% on critical user paths

### Integration Testing (Playwright)

- **Focus**: End-to-end user workflows
- **Critical Paths**: Authentication, wallet connection, core features
- **Performance**: Page load times, interaction responsiveness
- **Cross-browser**: Test on Chromium, Firefox, Safari

### Hook Testing

- **Custom Hooks**: Test in isolation with @testing-library/react-hooks
- **State Management**: Verify state transitions and side effects
- **Error Scenarios**: Test error handling and recovery

## Project Structure

### Root Level Directories

- `app/`: Next.js App Router pages and layouts
- `components/`: Reusable React components organized by feature
- `src/`: Core utilities, types, and business logic
- `hooks/`: Custom React hooks for shared logic
- `services/`: API integration and external service clients
- `utils/`: Pure utility functions and helpers
- `types/`: TypeScript type definitions
- `__tests__/`: Test files mirroring source structure

### Component Organization Hierarchy

```
components/
├── Layout Components (header, footer, navigation)
├── Feature Components (auth, waves, user, trading)
│   ├── Container Components (data fetching, state management)
│   ├── Presentation Components (pure rendering)
│   └── Shared Sub-components
└── Utility Components (buttons, forms, modals)
```

### Critical File Organization Rules

1. **One Component Per File**: Each component gets its own file
2. **Co-locate Related Files**: Keep components, styles, tests together
3. **Separate Concerns**: Split data logic from presentation logic
4. **Consistent Naming**: Use clear, descriptive names that indicate purpose
5. **Index Files**: Use for clean imports in component directories

## Mobile-First Development Considerations

### Responsive Design Patterns

- **Breakpoint Strategy**: Mobile-first with progressive enhancement
- **Component Variants**: Create mobile-specific variants for complex components
- **Touch Interactions**: Optimize for touch targets and gestures
- **Performance**: Lazy load non-critical components on mobile

### Capacitor Integration

- **Native Features**: Camera, file system, push notifications
- **Platform Detection**: Conditional rendering for native vs web
- **Performance**: Minimize bundle size for mobile app builds

## Security & Authentication

### Web3 Security Patterns - OWASP 2025 Guidelines

Based on analysis of 149 security incidents documenting $1.42 billion in losses (2024):

**Critical Vulnerabilities to Address:**

- **Access Control Flaws**: $953.2M in losses - Implement proper permission checks
- **Logic Errors**: $63.8M in losses - Use formal verification for critical paths
- **Reentrancy Attacks**: $35.7M in losses - Follow checks-effects-interactions pattern
- **Price Oracle Manipulation**: $8.8M in losses - Use multiple oracle sources

**Simple Security Patterns:**

```typescript
// ✅ Good: Simple address validation
function validateAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

// ✅ Good: Simple transaction validation
function validateTransaction(amount: bigint, balance: bigint): boolean {
  return amount > 0n && amount <= balance;
}

// ❌ Avoid: Over-engineered validation with complex abstractions
```

**Wallet Connection Security:**

- **Address Validation**: Use simple regex + checksum validation
- **Connection State**: Clear state machine, no ambiguous states
- **Error Handling**: Fail-fast on invalid addresses, log security events
- **Session Management**: Clean disconnection, no orphaned connections

**Authentication Flow - Keep It Simple:**

- **Multi-Method Auth**: Email, social, wallet - user chooses complexity level
- **JWT Lifecycle**: Standard patterns, secure storage, proper expiration
- **Session Cleanup**: Logout clears all auth state, forces wallet disconnect
- **Error Recovery**: Clear user guidance, no silent failures

## Performance Optimization

### Bundle Optimization

- **Code Splitting**: Route-based and feature-based splitting
- **Tree Shaking**: Remove unused code with proper ES modules
- **Bundle Analysis**: Regular analysis with @next/bundle-analyzer
- **Dynamic Imports**: Lazy load heavy components and libraries

### Runtime Performance

- **React Optimization**: useMemo, useCallback for expensive operations
- **Virtual Scrolling**: For large lists (waves, NFT collections)
- **Image Optimization**: Next.js Image component with proper sizing
- **Caching Strategy**: Service worker for offline support

## Development Workflow

### Branch Strategy

- **Feature Branches**: Create from main for new features
- **Mobile Branch**: Current mobile-4 branch for mobile-specific work
- **Code Review**: Required for all changes to main branch
- **Testing**: All tests must pass before merge

### Commit Conventions

- **Format**: Conventional commits (feat:, fix:, refactor:, etc.)
- **Scope**: Include component/feature scope when relevant
- **Breaking Changes**: Document any breaking changes clearly

## Environment Setup

### Required Tools

- **Node.js**: Version specified in package.json engines
- **Package Manager**: npm (package-lock.json present)
- **IDE**: VS Code with TypeScript and ESLint extensions recommended

### Environment Variables

- **NEXT_PUBLIC_PROJECT_ID**: Reown/WalletConnect project ID
- **NEXTAUTH_SECRET**: NextAuth.js secret for session encryption
- **API Endpoints**: Configure for development/production environments

### Development Dependencies

- **ESLint**: Code quality and style enforcement
- **Prettier**: Code formatting (if configured)
- **TypeScript**: Type checking and IntelliSense
- **Jest**: Unit testing framework
- **Playwright**: End-to-end testing

## Refactoring Priority List

### Immediate Actions Required (700+ lines)

1. **CollectionDelegation.tsx** (1,984 lines) - Split into delegation flow components
2. **ReactQueryWrapper.tsx** (1,268 lines) - Extract provider setup logic
3. **MemeLabPage.tsx** (1,249 lines) - Split into lab sections and filters
4. **CreateDropContent.tsx** (1,080 lines) - Extract form sections and validation
5. **Header.tsx** (1,027 lines) - Split navigation, user menu, and mobile components

### High Priority (500-700 lines)

- **NextGenAdmin.tsx** (983 lines) - Split admin functions into separate components
- **BuildPhaseFormConfigModal.tsx** (973 lines) - Extract form sections
- **EULAModal.tsx** (910 lines) - Split terms display and acceptance logic

### Component Splitting Strategies for Large Files

1. **Extract Form Sections**: Separate validation, submission, and display logic
2. **Create Sub-components**: Split UI sections into focused components
3. **Extract Custom Hooks**: Move data fetching and state management to hooks
4. **Separate Business Logic**: Move calculations and transformations to utility functions

## Ultra-Aggressive Fail-Fast Error Handling Guidelines

### **CRITICAL: Fail-Fast Philosophy - No Fallbacks for Critical Operations**

**Core Principle**: Show all bugs clearly, fail aggressively, terminate immediately on security violations

#### 1. **Error Classification & Decision Matrix**

**ALWAYS FAIL-FAST (No Fallbacks)**:

- **Authentication errors** (JWT, wallet connection, SIWX)
- **Authorization failures** (insufficient permissions)
- **Transaction errors** (insufficient balance, gas estimation failures)
- **Security violations** (invalid signatures, unauthorized access)
- **Data integrity failures** (schema validation, sanitization failures)
- **API authentication/authorization errors**

**FAIL-FAST with Context (Structured Termination)**:

- **Network errors** (with retry exhaustion)
- **Parsing errors** (malformed JSON, invalid data types)
- **Validation errors** (form validation, input constraints)
- **Resource exhaustion** (rate limits, quotas)

```typescript
// ✅ CORRECT: Ultra-aggressive fail-fast for authentication
function handleAuthError(error: AuthenticationError): never {
  // Log with enhanced security context
  logSecurityEvent(SecurityEventType.AUTHENTICATION_FAILURE, {
    timestamp: new Date().toISOString(),
    source: "auth_handler",
    errorCode: error.code,
    userAgent: navigator.userAgent,
  });

  // Immediate termination - no fallbacks
  throw new AuthenticationError(
    "Authentication failed. Please reconnect your wallet.",
    error.code
  );
}

// ❌ INCORRECT: Soft fallback for critical security operation
function handleAuthError(error: AuthenticationError): AuthState {
  console.warn("Auth failed, using guest mode"); // NO!
  return { isAuthenticated: false, user: null }; // DANGEROUS!
}
```

#### 2. **Enhanced Error Class Architecture**

Building upon existing `WalletConnectionError`, `AuthenticationError`, `TokenRefreshError`:

```typescript
// Enhanced base error class with structured context
abstract class SeizeError extends Error {
  abstract readonly type: string;
  abstract readonly code: string;
  readonly timestamp: string;
  readonly context: Record<string, unknown>;

  constructor(
    message: string,
    code: string,
    context: Record<string, unknown> = {}
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.timestamp = new Date().toISOString();
    this.context = context;
  }

  toSecureLogEntry(): SecurityLogEntry {
    return {
      timestamp: this.timestamp,
      type: this.type,
      code: this.code,
      message: sanitizeErrorMessage(this.message),
      context: sanitizeMetadata(this.context),
    };
  }
}

// Critical security errors - ALWAYS fail-fast
class SecurityViolationError extends SeizeError {
  readonly type = "SECURITY_VIOLATION";
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

class AuthenticationError extends SeizeError {
  readonly type = "AUTHENTICATION_ERROR";
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

class TransactionError extends SeizeError {
  readonly type = "TRANSACTION_ERROR";
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}

// Non-critical errors - structured but can have recovery
class ValidationError extends SeizeError {
  readonly type = "VALIDATION_ERROR";
  constructor(message: string, code: string, context = {}) {
    super(message, code, context);
  }
}
```

#### 3. **Ultra-Aggressive Error Boundary Strategy**

**Section-Level Failure** (No Graceful Fallbacks):

```tsx
// ✅ CORRECT: Aggressive error boundary with clear failure states
function CriticalFeatureErrorBoundary({
  children,
  featureName,
}: {
  children: React.ReactNode;
  featureName: string;
}) {
  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <div className="tw-bg-red-50 tw-border-2 tw-border-red-500 tw-rounded-lg tw-p-6 tw-text-center">
          <h3 className="tw-text-xl tw-font-bold tw-text-red-800 tw-mb-4">
            {featureName} Failed
          </h3>
          <p className="tw-text-red-700 tw-mb-6">
            A critical error occurred. The application cannot continue safely.
          </p>
          <div className="tw-space-y-3">
            <button
              onClick={resetErrorBoundary}
              className="tw-block tw-w-full tw-bg-red-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-red-700">
              Reset Feature
            </button>
            <button
              onClick={() => window.location.reload()}
              className="tw-block tw-w-full tw-bg-gray-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-gray-700">
              Reload Application
            </button>
          </div>
        </div>
      )}
      onError={(error, errorInfo) => {
        // Enhanced logging with security context
        logError(`${featureName}_boundary_error`, error);

        // Report to monitoring service
        if (error instanceof SecurityViolationError) {
          logSecurityEvent(SecurityEventType.SECURITY_BOUNDARY_VIOLATION, {
            featureName,
            source: "error_boundary",
            componentStack: sanitizeErrorMessage(
              errorInfo.componentStack || ""
            ),
          });
        }
      }}>
      {children}
    </ErrorBoundary>
  );
}

// Usage: Wrap critical features with aggressive boundaries
<CriticalFeatureErrorBoundary featureName="Wallet Connection">
  <WalletProvider>
    <AuthenticatedApp />
  </WalletProvider>
</CriticalFeatureErrorBoundary>;
```

#### 4. **Production-Ready Security Logging Enhancement**

Enhanced `security-logger.ts` patterns:

```typescript
// Enhanced error logging with structured codes
export const logCriticalError = (
  context: string,
  error: SeizeError,
  additionalContext?: Record<string, unknown>
): void => {
  const logEntry = {
    ...error.toSecureLogEntry(),
    context,
    additionalContext: additionalContext
      ? sanitizeMetadata(additionalContext)
      : undefined,
    severity: getSeverityLevel(error),
    actionRequired: getActionRequired(error),
    sessionId: generateSecureSessionId(),
  };

  // Immediate alert for critical errors
  if (error instanceof SecurityViolationError) {
    // Send to security monitoring immediately
    sendSecurityAlert(logEntry);
  }

  // Structured logging for searchability
  if (publicEnv.NODE_ENV === "production") {
    console.error(`[SEIZE_CRITICAL_ERROR][${error.code}]`, logEntry);
  } else {
    console.group(`🚨 CRITICAL ERROR: ${error.type}`);
    console.error("Error Details:", logEntry);
    console.error("Stack Trace:", error.stack);
    console.groupEnd();
  }
};

// Error severity classification
function getSeverityLevel(
  error: SeizeError
): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
  if (error instanceof SecurityViolationError) return "CRITICAL";
  if (error instanceof AuthenticationError) return "HIGH";
  if (error instanceof TransactionError) return "HIGH";
  if (error instanceof ValidationError) return "MEDIUM";
  return "LOW";
}

// Required actions for different error types
function getActionRequired(error: SeizeError): string {
  switch (error.type) {
    case "SECURITY_VIOLATION":
      return "IMMEDIATE_INVESTIGATION_REQUIRED";
    case "AUTHENTICATION_ERROR":
      return "USER_REAUTHENTICATION_REQUIRED";
    case "TRANSACTION_ERROR":
      return "TRANSACTION_RETRY_OR_USER_ACTION";
    default:
      return "STANDARD_ERROR_HANDLING";
  }
}
```

#### 5. **Comprehensive Testing Strategy for Fail-Fast Patterns**

**Error Propagation Tests**:

```typescript
describe("Fail-Fast Error Propagation", () => {
  it("should propagate authentication errors without fallback", () => {
    const mockAuthError = new AuthenticationError(
      "Invalid JWT token",
      "AUTH_JWT_INVALID"
    );

    const mockWalletConnect = jest.fn().mockRejectedValue(mockAuthError);

    expect(async () => {
      await connectWallet(mockWalletConnect);
    }).rejects.toThrow(AuthenticationError);

    expect(async () => {
      await connectWallet(mockWalletConnect);
    }).rejects.toHaveProperty("code", "AUTH_JWT_INVALID");
  });

  it("should never provide fallback for security violations", () => {
    const securityError = new SecurityViolationError(
      "Unauthorized signature attempt",
      "SECURITY_INVALID_SIGNATURE"
    );

    const result = handleSecurityError(securityError);

    // Should always throw, never return a value
    expect(result).toBeUndefined();
    expect(mockLogSecurityEvent).toHaveBeenCalledWith(
      SecurityEventType.SECURITY_VIOLATION,
      expect.objectContaining({
        errorCode: "SECURITY_INVALID_SIGNATURE",
      })
    );
  });
});
```

**Security Leak Tests**:

```typescript
describe("Security Data Sanitization", () => {
  it("should never log sensitive data in error messages", () => {
    const error = new AuthenticationError(
      "JWT validation failed for token: eyJ0eXAiOiJKV1Q...",
      "AUTH_JWT_INVALID"
    );

    logCriticalError("test_context", error);

    expect(mockConsoleError).toHaveBeenCalledWith(
      expect.stringMatching(/\[SEIZE_CRITICAL_ERROR\]/),
      expect.objectContaining({
        message: expect.stringMatching(/\*\*\*JWT\*\*\*/), // Sanitized
      })
    );
  });
});
```

#### 6. **Recovery Pattern Documentation with Fail-Fast Integration**

**Retry Mechanisms** (with aggressive limits):

```typescript
// Ultra-conservative retry with immediate failure
const CRITICAL_OPERATION_MAX_RETRIES = 1; // Aggressive: only 1 retry
const CRITICAL_OPERATION_TIMEOUT = 5000; // 5 second timeout

async function retryWalletConnection(
  operation: () => Promise<WalletConnection>,
  maxRetries = CRITICAL_OPERATION_MAX_RETRIES
): Promise<WalletConnection> {
  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
    try {
      return await operation();
    } catch (error) {
      // Fail immediately on security errors
      if (
        error instanceof SecurityViolationError ||
        error instanceof AuthenticationError
      ) {
        logCriticalError(
          "wallet_connection_security_failure",
          error as SeizeError,
          { attempt, maxRetries }
        );
        throw error; // No retry for security issues
      }

      // Last attempt - fail fast
      if (attempt > maxRetries) {
        const finalError = new WalletConnectionError(
          "Wallet connection failed after maximum retries",
          "WALLET_CONNECTION_EXHAUSTED",
          { totalAttempts: attempt, originalError: error }
        );

        logCriticalError("wallet_connection_exhausted", finalError);
        throw finalError;
      }

      // Brief pause only for non-security errors
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
  }
}
```

**User-Initiated Recovery** (with security checks):

```tsx
function SecurityAwareRecoveryButton({
  onRecover,
  error,
  featureName,
}: {
  onRecover: () => void;
  error: SeizeError;
  featureName: string;
}) {
  // No recovery allowed for security violations
  if (error instanceof SecurityViolationError) {
    return (
      <div className="tw-bg-red-100 tw-border tw-border-red-500 tw-p-4 tw-rounded">
        <p className="tw-text-red-800 tw-font-semibold">
          Security violation detected. Recovery not available.
        </p>
        <p className="tw-text-red-600 tw-text-sm tw-mt-2">
          Please refresh the page and ensure your wallet is secure.
        </p>
      </div>
    );
  }

  return (
    <button
      onClick={() => {
        logSecurityEvent(SecurityEventType.USER_INITIATED_RECOVERY, {
          featureName,
          errorType: error.type,
          source: "user_recovery_button",
        });
        onRecover();
      }}
      className="tw-bg-blue-600 tw-text-white tw-px-4 tw-py-2 tw-rounded hover:tw-bg-blue-700">
      Try Again
    </button>
  );
}
```

#### 7. **Implementation Verification Commands**

```bash
# Verify error handling patterns
grep -r "catch.*AuthenticationError" components/ --include="*.tsx" --include="*.ts"
grep -r "SecurityViolationError" src/ --include="*.ts"
grep -r "logCriticalError" components/ --include="*.tsx"

# Check for forbidden fallback patterns
grep -r "catch.*console\.warn" components/ # Should find none
grep -r "|| null.*catch" components/ # Should find none for critical operations

# Verify security logging usage
grep -r "logSecurityEvent" components/ --include="*.tsx"
grep -r "sanitizeErrorMessage" utils/ --include="*.ts"

# Test error boundary integration
npm run test -- --testNamePattern="Error.*Boundary" --verbose
npm run test -- --testNamePattern="fail.*fast" --verbose
```

#### 8. **Web3-Specific Fail-Fast Patterns**

Based on 2024-2025 OWASP Smart Contract Top 10 and $1.42B in documented losses:

```typescript
// ✅ CORRECT: Fail-fast on wallet security violations
function validateWalletSignature(
  signature: string,
  message: string
): never | void {
  if (!signature || signature.length < 132) {
    throw new SecurityViolationError(
      "Invalid signature format detected",
      "WALLET_INVALID_SIGNATURE",
      { signatureLength: signature?.length || 0 }
    );
  }

  // Additional security validations...
  const isValid = verifySignature(signature, message);
  if (!isValid) {
    throw new SecurityViolationError(
      "Signature verification failed",
      "WALLET_SIGNATURE_VERIFICATION_FAILED"
    );
  }
}

// ✅ CORRECT: Fail-fast on transaction anomalies
function validateTransactionSecurity(
  txParams: TransactionParams
): never | void {
  // Check for potential oracle manipulation patterns
  if (txParams.gasPrice > MAX_REASONABLE_GAS_PRICE) {
    throw new SecurityViolationError(
      "Gas price exceeds security threshold",
      "TRANSACTION_GAS_ANOMALY",
      { gasPrice: txParams.gasPrice, threshold: MAX_REASONABLE_GAS_PRICE }
    );
  }

  // Validate recipient address
  if (!isValidEthereumAddress(txParams.to)) {
    throw new SecurityViolationError(
      "Invalid recipient address format",
      "TRANSACTION_INVALID_RECIPIENT"
    );
  }
}
```

---

**CRITICAL REMINDER**: This fail-fast approach prioritizes security and bug detection over user convenience. Every fallback removed is a potential vulnerability eliminated. In Web3 applications handling financial transactions, aggressive failure is safer than silent corruption.

## Current Codebase Patterns & Simple Solutions

### Good Patterns Already in Use

- **SeizeConnectContext**: Well-structured wallet state management with TypeScript
- **Unified State Machine**: Single `WalletState` type eliminates multiple boolean flags
- **Error Classification**: Specific error classes (WalletConnectionError, AuthenticationError)
- **Address Validation**: Uses viem's isAddress + getAddress for checksumming
- **Security Logging**: Structured logging with sanitized error context
- **Provider Composition**: Clear provider hierarchy in Providers.tsx

### Simple Improvements to Consider

**1. Component Size Management:**

```typescript
// ✅ Current good pattern: Focused components like SeizeConnectContext
// ⚠️  Watch out for: Large components mentioned in docs (1000+ lines)

// Simple approach: Extract 1-2 sub-components at a time
function LargeComponent() {
  return (
    <div>
      <ComponentHeader /> {/* Extract first */}
      <ComponentBody /> {/* Extract second */}
      {/* Keep rest until above are working */}
    </div>
  );
}
```

**2. Hook Composition (Following wagmi v2 patterns):**

```typescript
// ✅ Good: Compose small, focused hooks
function useWalletConnection() {
  const { address, isConnected } = useAccount();
  const { disconnect } = useDisconnect();
  const { data: balance } = useBalance({ address });

  return { address, isConnected, disconnect, balance };
}

// ❌ Avoid: One hook that does everything
```

**3. TailwindCSS Migration (Already Underway):**

```typescript
// ✅ Current good pattern: tw- prefix usage
<div className="tw-flex tw-items-center tw-gap-4">

// 🔄 Migration in progress: Some Bootstrap remains
<div className="d-flex align-items-center"> {/* Mark for migration */}
```

**4. Error Handling - Keep Existing Fail-Fast Approach:**

```typescript
// ✅ Keep current pattern: Specific error types + immediate failure
if (!isAddress(address)) {
  throw new SecurityViolationError("Invalid address format");
}

// ✅ Keep current pattern: Structured logging
logSecurityEvent(SecurityEventType.INVALID_ADDRESS, context);
```

## Migration & Deprecation Notes

### Simple Migration Strategy

- **Phase 1**: Extract 1-2 sub-components from largest files (1000+ lines)
- **Phase 2**: Convert remaining Bootstrap classes to TailwindCSS (with tw- prefix)
- **Phase 3**: Add React 19 features incrementally (useOptimistic for forms)
- **Phase 4**: Migrate Pages Router routes to App Router (as needed)

### Keep These Patterns

- **Error Classification**: Current error classes are well-designed
- **State Machine**: WalletState union type is clean and clear
- **Provider Architecture**: Current provider composition works well
- **Security Logging**: Existing patterns follow OWASP guidelines

## Known Issues & Performance Notes

### Component Size Issues

- Several components exceed recommended size limits
- Complex state management spread across large components
- Mixed concerns in presentation and data fetching

### Performance Considerations

- Large bundle sizes due to monolithic components
- Potential for unnecessary re-renders in complex components
- Memory usage in long-running user sessions

### Browser Compatibility

- Modern ES2020+ features used (ensure transpilation for older browsers)
- Service worker support for offline functionality
- WebRTC support required for peer-to-peer features

## TailwindCSS Styling Guidelines & Best Practices

### **CRITICAL RULE: Always Use TailwindCSS for Styling**

**All new components and styling MUST use TailwindCSS with the `tw-` prefix. This is non-negotiable.**

#### TailwindCSS Configuration

- **Version**: v3.4.4 with modern features and plugins
- **Prefix**: `tw-` (REQUIRED for all classes)
- **Preflight**: Disabled (`preflight: false`)
- **Dark Mode**: Class-based (`"class"` strategy)
- **Current Coexistence**: Running alongside Bootstrap (migration in progress)

### Mandatory TailwindCSS Usage Patterns

#### 1. **Prefix System (REQUIRED)**

```tsx
// ✅ CORRECT: Always use tw- prefix
<div className="tw-flex tw-items-center tw-gap-x-4 tw-p-6">
  <img className="tw-h-12 tw-w-12 tw-rounded-full tw-ring-2 tw-ring-white" />
  <div className="tw-text-xl tw-font-medium tw-text-iron-50">
</div>

// ❌ INCORRECT: No prefix (conflicts with Bootstrap)
<div className="flex items-center gap-4">
```

#### 2. **Custom Design System Classes**

```tsx
// Custom Color Scale (MUST use these)
tw - bg - primary - 500; // Primary brand blue
tw - bg - primary - 600; // Darker primary
tw - text - iron - 50; // Light text
tw - text - iron - 300; // Medium text
tw - text - iron - 500; // Muted text
tw - bg - iron - 800; // Dark backgrounds
tw - bg - iron - 900; // Darker backgrounds
tw - bg - iron - 950; // Darkest backgrounds

// Custom Shadows
tw - shadow - drop - btn - inactive;
tw - shadow - drop - btn - active;

// Custom Animations
tw - animate - loading - bar;
tw - animate - trophy - appear;
tw - animate - gradient - shift;
tw - animate - fadeIn;
tw - animate - shake;
tw - animate - gallery - reveal;
```

#### 3. **Responsive Design Patterns**

```tsx
// Mobile-first approach with custom 3xl breakpoint
<div className="tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 lg:tw-grid-cols-3 tw-3xl:tw-grid-cols-4">

// Container queries (use @container)
<div className="tw-@container">
  <div className="tw-flex tw-flex-col @md:tw-flex-row">
```

### Headless UI + TailwindCSS Integration Patterns

#### 1. **State-Based Styling with Data Attributes**

```tsx
import { Dialog, DialogPanel } from '@headlessui/react'

// ✅ CORRECT: Using data attributes for state styling
<Dialog className="tw-fixed tw-inset-0 tw-z-[1010]">
  <DialogPanel className="tw-bg-iron-950 tw-shadow-xl data-open:tw-scale-100 data-closed:tw-scale-95">

// Alternative: Using Headless UI plugin (if installed)
<Tab className="ui-selected:tw-bg-primary-500 ui-not-selected:tw-bg-iron-800">
```

#### 2. **Component Composition with TailwindCSS**

```tsx
// Headless UI + TailwindCSS pattern
import { Combobox, ComboboxInput, ComboboxOptions, ComboboxOption } from '@headlessui/react'

<Combobox className="tw-relative">
  <ComboboxInput className="tw-w-full tw-bg-iron-800 tw-border tw-border-iron-600 tw-rounded-lg tw-px-3 tw-py-2 tw-text-iron-50 focus:tw-border-primary-500 focus:tw-outline-none" />
  <ComboboxOptions className="tw-absolute tw-z-10 tw-mt-1 tw-bg-iron-900 tw-border tw-border-iron-700 tw-rounded-lg tw-shadow-lg">
    <ComboboxOption className="tw-px-3 tw-py-2 data-focus:tw-bg-primary-500 data-selected:tw-bg-primary-600">
```

#### 3. **Transition and Animation Integration**

```tsx
import { Transition, TransitionChild } from "@headlessui/react";

<Transition show={open}>
  <TransitionChild
    enter="tw-ease-out tw-duration-300"
    enterFrom="tw-opacity-0"
    enterTo="tw-opacity-100"
    leave="tw-ease-in tw-duration-200"
    leaveFrom="tw-opacity-100"
    leaveTo="tw-opacity-0">
    <div className="tw-fixed tw-inset-0 tw-bg-gray-500 tw-bg-opacity-50" />
  </TransitionChild>
</Transition>;
```

### Advanced TailwindCSS Patterns

#### 1. **Arbitrary Values for Custom Properties**

```tsx
// ✅ Use arbitrary values for precise control
<div className="tw-h-[calc(100vh-4rem)] tw-w-[50cqw]">
<div className="tw-bg-[#9917FF] tw-text-[var(--custom-color)]">

// ✅ Container query length units
<div className="tw-@container">
  <div className="tw-w-[50cqw] tw-h-[25cqh]">
```

#### 2. **Custom CSS Variable Integration**

```tsx
// ✅ Setting CSS variables for dynamic styling
<button
  style={{
    "--bg-color": buttonColor,
    "--text-color": textColor,
  }}
  className="tw-bg-[var(--bg-color)] tw-text-[var(--text-color)] hover:tw-opacity-80"
>
```

#### 3. **Component Variant Patterns**

```tsx
// ✅ Create reusable utility patterns
const buttonVariants = {
  primary: "tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600",
  secondary: "tw-bg-iron-600 tw-text-iron-50 hover:tw-bg-iron-500",
  danger: "tw-bg-red-600 tw-text-white hover:tw-bg-red-700"
}

<button className={`tw-px-4 tw-py-2 tw-rounded-lg tw-transition-colors ${buttonVariants.primary}`}>
```

### Migration Strategy from Bootstrap/SCSS

#### 1. **Immediate Actions for New Components**

```tsx
// ❌ AVOID: Bootstrap classes in new components
<div className="container-fluid d-flex justify-content-between">
<button className="btn btn-primary">

// ✅ REPLACE WITH: TailwindCSS equivalents
<div className="tw-container tw-mx-auto tw-flex tw-justify-between">
<button className="tw-bg-primary-500 tw-text-white tw-px-4 tw-py-2 tw-rounded-lg hover:tw-bg-primary-600 tw-transition-colors">
```

#### 2. **Gradual Migration for Existing Components**

```tsx
// ✅ ACCEPTABLE: Mixed during migration (mark for future cleanup)
<Container className="pt-4"> {/* Bootstrap - mark for migration */}
  <div className="tw-flex tw-items-center tw-gap-3"> {/* TailwindCSS */}
    <span className="tw-text-iron-300 tw-animate-pulse"> {/* TailwindCSS */}
```

#### 3. **Testing Strategy During Migration**

- Test components in both Bootstrap and TailwindCSS contexts
- Verify responsive behavior works correctly
- Check dark mode compatibility
- Validate accessibility is maintained

### Mobile-First & Performance Considerations

#### 1. **Capacitor-Specific Styling**

```tsx
// ✅ Safe area support
<div className="tw-pt-[env(safe-area-inset-top,0px)] tw-pb-[env(safe-area-inset-bottom,0px)]">

// ✅ Touch-optimized components
<button className="tw-min-h-[44px] tw-min-w-[44px] tw-touch-manipulation">
```

#### 2. **Performance Optimizations**

```tsx
// ✅ Use transform for animations (GPU accelerated)
<div className="tw-transform tw-translate-x-0 hover:tw-translate-x-1 tw-transition-transform">

// ✅ Efficient scrolling
<div className="tw-overflow-y-auto tw-scrollbar-thin tw-scrollbar-thumb-iron-500 tw-scrollbar-track-iron-800">
```

### Dark Mode & Theming Patterns

#### 1. **Dark Mode Implementation**

```tsx
// ✅ Using class-based dark mode strategy
<div className="tw-bg-white dark:tw-bg-iron-900 tw-text-iron-900 dark:tw-text-iron-50">

// ✅ Custom dark mode variants with iron scale
<div className="tw-bg-iron-100 dark:tw-bg-iron-800">
```

### Web3/Blockchain UI Patterns

#### 1. **Wallet Connection States**

```tsx
// ✅ State-based styling for wallet components
<button className={`
  tw-px-6 tw-py-3 tw-rounded-lg tw-font-semibold tw-transition-all tw-duration-200
  ${connected
    ? 'tw-bg-success tw-text-white hover:tw-bg-green'
    : 'tw-bg-primary-500 tw-text-white hover:tw-bg-primary-600'
  }
`}>
```

#### 2. **Transaction Status UI**

```tsx
// ✅ Status indicators with custom animations
<div className="tw-flex tw-items-center tw-gap-2">
  <div className="tw-w-2 tw-h-2 tw-bg-primary-500 tw-rounded-full tw-animate-pulse" />
  <span className="tw-text-iron-300">Transaction pending...</span>
</div>
```

### Component Testing with TailwindCSS

#### 1. **Testing Responsive Classes**

```tsx
// ✅ Test responsive behavior
expect(screen.getByTestId("responsive-grid")).toHaveClass(
  "tw-grid-cols-1",
  "sm:tw-grid-cols-2"
);

// ✅ Test dark mode classes
expect(screen.getByTestId("themed-element")).toHaveClass("dark:tw-bg-iron-900");
```

#### 2. **Visual Regression Testing**

- Use Playwright for cross-device testing
- Test both light and dark modes
- Verify custom animations work correctly
- Check touch targets meet 44px minimum

### Verification Commands

```bash
# Check for non-prefixed Tailwind classes (should be rare and marked for migration)
grep -r "className.*=[\"'][^\"']*\\b(flex|grid|bg-|text-|p-|m-|w-|h-)" components/ --exclude-dir=node_modules

# Find Bootstrap classes that need migration
grep -r "className.*=[\"'][^\"']*\\b(btn|container|d-flex|justify-content)" components/ --exclude-dir=node_modules

# Verify tw- prefix usage
grep -r "tw-" components/ | wc -l

# Check for Headless UI integration
grep -r "@headlessui" components/ --include="*.tsx"
```

## Research Sources & Documentation

### Primary Sources (Context7 MCP)

- **TailwindCSS**: /websites/tailwindcss_com-plus-ui-blocks-documentation - Component composition patterns
- **TailwindCSS Core**: /tailwindlabs/tailwindcss.com - Utility-first methodology and best practices
- **Headless UI**: /websites/headlessui_com - TailwindCSS integration patterns with state-based styling
- **React**: /reactjs/react.dev - Modern React patterns and best practices
- **Next.js**: /vercel/next.js - App Router patterns and optimization
- **Reown AppKit**: /reown-com/appkit - Web3 integration and security
- **Wagmi**: /websites/wagmi_sh - React hooks for Ethereum

### Best Practices Sources

- **TailwindCSS v3.4.4**: Latest utility-first patterns and modern features
- **Headless UI Integration**: Component composition and state-based styling
- **Mobile-First Design**: Responsive patterns and touch optimization
- **Web3 UI Patterns**: Blockchain-specific interface design
- **Performance**: Bundle optimization and runtime performance
- **Accessibility**: Modern a11y standards with utility classes

### Configuration References

- **TailwindCSS Config**: Custom prefix `tw-`, preflight disabled, dark mode class strategy
- **Custom Design System**: iron color scale, primary brand colors, custom shadows and animations
- **Plugin Integration**: @tailwindcss/forms, tailwind-scrollbar, @tailwindcss/container-queries
- **Responsive Strategy**: Mobile-first with custom 3xl breakpoint (2048px)

### Last Updated

- Research conducted: January 2025
- TailwindCSS patterns: Based on v3.4.4 documentation and Context7 research
- Component analysis: Based on current codebase state with Bootstrap migration context
- Dependencies: Reflect package.json v0.1.0

---

**Ready for development. All styling MUST use TailwindCSS with tw- prefix. Bootstrap migration ongoing - new components must be TailwindCSS only.**

## Research Sources & Documentation

### Primary Research (January 2025)

- **React 19**: React.dev official blog + 2025 best practices research
- **Next.js 15**: Next.js documentation + App Router project structure research
- **Reown AppKit**: Official documentation + 2025 web3 security threat analysis
- **wagmi v2.15+**: Wagmi.sh documentation + TypeScript-first patterns research
- **OWASP 2025**: Smart Contract Top 10 + $1.42B loss analysis from 149 incidents
- **TailwindCSS**: v3.4.4 documentation + custom design system patterns

### Security Research Sources

- **OWASP Smart Contract Top 10 (2025)**: Analysis of 149 incidents, $1.42B in losses
- **Reown Security Study**: 45% of web3 domains in 2023 were malicious
- **Web3 Threat Landscape**: Phishing attacks, oracle manipulation, access control flaws

### Best Practices Sources

- **Component Architecture**: Single responsibility, composition patterns
- **Hook Composition**: wagmi v2 patterns, TanStack Query integration
- **TypeScript Patterns**: Strict mode, discriminated unions, type inference
- **Performance Optimization**: Bundle splitting, React Compiler, Server Components

### Last Updated

- **Research Date**: January 2025
- **Dependencies**: Based on package.json v0.1.0
- **Codebase Analysis**: Current file structure and patterns
- **Security Guidelines**: 2025 OWASP standards and recent threat data

**Philosophy**: All recommendations favor simplicity, maintainability, and security over cutting-edge complexity. Patterns chosen are battle-tested and easy for new developers to understand and implement.
